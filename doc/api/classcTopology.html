<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OMNeT++ Simulation Library: cTopology Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cTopology Class Reference<br/>
<small>
[<a class="el" href="group__SimSupport.html">Utility classes</a>]</small>
</h1><!-- doxytag: class="cTopology" --><!-- doxytag: inherits="cOwnedObject" -->
<p>Routing support.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ctopology_8h_source.html">ctopology.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cTopology:</div>
<div class="dynsection">
 <div class="center">
  <img src="classcTopology.png" usemap="#cTopology_map" alt=""/>
  <map id="cTopology_map" name="cTopology_map">
<area href="classcOwnedObject.html" alt="cOwnedObject" shape="rect" coords="0,112,96,136"/>
<area href="classcNamedObject.html" alt="cNamedObject" shape="rect" coords="0,56,96,80"/>
<area href="classcObject.html" alt="cObject" shape="rect" coords="0,0,96,24"/>
</map>
 </div>
</div>

<p><a href="classcTopology-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology_1_1Link.html">Link</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supporting class for <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a>, represents a link in the graph.  <a href="classcTopology_1_1Link.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology_1_1LinkIn.html">LinkIn</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supporting class for <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a>.  <a href="classcTopology_1_1LinkIn.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology_1_1LinkOut.html">LinkOut</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supporting class for <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a>.  <a href="classcTopology_1_1LinkOut.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology_1_1Node.html">Node</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supporting class for <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a>, represents a node in the graph.  <a href="classcTopology_1_1Node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology_1_1Predicate.html">Predicate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for selector objects used in extract.  <a href="classcTopology_1_1Predicate.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructor, assignment</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6e91a2e6cf9e8ed0bc0b076ddff21286"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa540fd27dcbbd67714c1eb46980c049d"></a><!-- doxytag: member="cTopology::cTopology" ref="aa540fd27dcbbd67714c1eb46980c049d" args="(const char *name=NULL)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#aa540fd27dcbbd67714c1eb46980c049d">cTopology</a> (const char *name=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b4430e9e3a4b3ffe346d8dc85e29987"></a><!-- doxytag: member="cTopology::cTopology" ref="a6b4430e9e3a4b3ffe346d8dc85e29987" args="(const cTopology &amp;topo)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a6b4430e9e3a4b3ffe346d8dc85e29987">cTopology</a> (const <a class="el" href="classcTopology.html">cTopology</a> &amp;topo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97436f45bc7fc20ba3802d11a4cfe173"></a><!-- doxytag: member="cTopology::~cTopology" ref="a97436f45bc7fc20ba3802d11a4cfe173" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a97436f45bc7fc20ba3802d11a4cfe173">~cTopology</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcTopology.html">cTopology</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#af9ebab8c0519c82df3f3e358ffd035b2">operator=</a> (const <a class="el" href="classcTopology.html">cTopology</a> &amp;topo)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Redefined cObject member functions.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa1f41a2538be95e9e7389d73943b4719"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcTopology.html">cTopology</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#af9fb1215e25675e3f49ada50acae1605">dup</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a644049ca8239eb389fe20a49e3d3c428">info</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a790b08ba3baa3a66808e5f72525f52d9">parsimPack</a> (<a class="el" href="classcCommBuffer.html">cCommBuffer</a> *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a40a84d778bad4bf009bfe6a7661fc33c">parsimUnpack</a> (<a class="el" href="classcCommBuffer.html">cCommBuffer</a> *buffer)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extracting the topology from a network.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd54dd75863dd7e37d4a05b83cc02fc7e"></a>extract.</p>
<p>..() functions build topology from the model. User can select which modules to include. All connections between those modules will be in the topology. Connections can cross compound module boundaries. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a449b5ad0c2916511e76d7b0131a6ef09">extractFromNetwork</a> (bool(*selfunc)(<a class="el" href="classcModule.html">cModule</a> *, void *), void *userdata=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a688e0515aa814e872564cfb122c87d85"></a><!-- doxytag: member="cTopology::extractFromNetwork" ref="a688e0515aa814e872564cfb122c87d85" args="(Predicate *predicate)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a688e0515aa814e872564cfb122c87d85">extractFromNetwork</a> (<a class="el" href="classcTopology_1_1Predicate.html">Predicate</a> *predicate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a54b4891abd28e1a9700946654034d367">extractByModulePath</a> (const std::vector&lt; std::string &gt; &amp;fullPathPatterns)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#ae2b6970c74322b7179e136029a187f9c">extractByNedTypeName</a> (const std::vector&lt; std::string &gt; &amp;nedTypeNames)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a387ea85304d459e6da463fea8aeb7f72">extractByProperty</a> (const char *propertyName, const char *value=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a5a5f9bd454fb850d158640e4f8c7cd0c">extractByParameter</a> (const char *paramName, const char *paramValue=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d96a698039156fb857a9ba72a41379c"></a><!-- doxytag: member="cTopology::clear" ref="a7d96a698039156fb857a9ba72a41379c" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a7d96a698039156fb857a9ba72a41379c">clear</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to examine topology by hand.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc47479c5353d5c788b4d2018d29c7812"></a>Users also need to rely on <a class="el" href="classcTopology_1_1Node.html" title="Supporting class for cTopology, represents a node in the graph.">Node</a> and <a class="el" href="classcTopology_1_1Link.html" title="Supporting class for cTopology, represents a link in the graph.">Link</a> member functions to explore the graph stored in the object. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ab37e112ec07e7cdded2c5046910957"></a><!-- doxytag: member="cTopology::getNumNodes" ref="a9ab37e112ec07e7cdded2c5046910957" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a9ab37e112ec07e7cdded2c5046910957">getNumNodes</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcTopology_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a90e795af4b961529b8e2d83eca316079">getNode</a> (int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcTopology_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a4000b9e28b62b3c1816d69695d93da95">getNodeFor</a> (<a class="el" href="classcModule.html">cModule</a> *mod)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Algorithms to find shortest paths.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp8b53a5a2d31c4132ca637a9dd3f4b104"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#acac27e130259f6992b726d31cc9f10fd">calculateUnweightedSingleShortestPathsTo</a> (<a class="el" href="classcTopology_1_1Node.html">Node</a> *target)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a51a47079b356ff3a70964f4f518e3a3e">calculateWeightedSingleShortestPathsTo</a> (<a class="el" href="classcTopology_1_1Node.html">Node</a> *target)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78dbad0c81c4242b6aa4584c1b47f6cb"></a><!-- doxytag: member="cTopology::getTargetNode" ref="a78dbad0c81c4242b6aa4584c1b47f6cb" args="() const " -->
<a class="el" href="classcTopology_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a78dbad0c81c4242b6aa4584c1b47f6cb">getTargetNode</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Routing support. </p>
<p>The <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a> class was designed primarily to support routing in telecommunication or multiprocessor networks.</p>
<p>A <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a> object stores an abstract representation of the network in graph form: </p>
<ul>
<li>
each <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a> node corresponds to a module (simple or compound), and </li>
<li>
each <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a> edge corresponds to a link or series of connecting links. </li>
</ul>
<p>You can specify which modules (either simple or compound) you want to include in the graph. The graph will include all connections among the selected modules. In the graph, all nodes are at the same level, there is no submodule nesting. Connections which span across compound module boundaries are also represented as one graph edge. Graph edges are directed, just as module gates are.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcTopology_1_1Node.html" title="Supporting class for cTopology, represents a node in the graph.">cTopology::Node</a>, <a class="el" href="classcTopology_1_1Link.html" title="Supporting class for cTopology, represents a link in the graph.">cTopology::Link</a>, <a class="el" href="classcTopology_1_1LinkIn.html" title="Supporting class for cTopology.">cTopology::LinkIn</a>, <a class="el" href="classcTopology_1_1LinkOut.html" title="Supporting class for cTopology.">cTopology::LinkOut</a> </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acac27e130259f6992b726d31cc9f10fd"></a><!-- doxytag: member="cTopology::calculateUnweightedSingleShortestPathsTo" ref="acac27e130259f6992b726d31cc9f10fd" args="(Node *target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::calculateUnweightedSingleShortestPathsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcTopology_1_1Node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply the Dijkstra algorithm to find all shortest paths to the given graph node. </p>
<p>The paths found can be extracted via Node's methods. </p>

</div>
</div>
<a class="anchor" id="a51a47079b356ff3a70964f4f518e3a3e"></a><!-- doxytag: member="cTopology::calculateWeightedSingleShortestPathsTo" ref="a51a47079b356ff3a70964f4f518e3a3e" args="(Node *target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::calculateWeightedSingleShortestPathsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcTopology_1_1Node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply the Dijkstra algorithm to find all shortest paths to the given graph node. </p>
<p>The paths found can be extracted via Node's methods. Uses weights in nodes and links. </p>

</div>
</div>
<a class="anchor" id="af9fb1215e25675e3f49ada50acae1605"></a><!-- doxytag: member="cTopology::dup" ref="af9fb1215e25675e3f49ada50acae1605" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcTopology.html">cTopology</a>* cTopology::dup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates and returns an exact copy of this object. </p>
<p>See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarchy.">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classcObject.html#aa5c41ae00a77e27af6c7b52d3b63669a">cObject</a>.</p>

</div>
</div>
<a class="anchor" id="a54b4891abd28e1a9700946654034d367"></a><!-- doxytag: member="cTopology::extractByModulePath" ref="a54b4891abd28e1a9700946654034d367" args="(const std::vector&lt; std::string &gt; &amp;fullPathPatterns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::extractByModulePath </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fullPathPatterns</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts model topology by module full path. </p>
<p>All modules whole <a class="el" href="classcObject.html#a26c918d8176ea1ce3bc6b87cc7e45464" title="Returns the full path of the object in the object hierarchy, like &quot;net.host[2]...">getFullPath()</a> matches one of the patterns in given string vector will get included. The patterns may contain wilcards in the same syntax as in ini files.</p>
<p>An example:</p>
<p><code>topo.extractByModulePath(<a class="el" href="classcStringTokenizer.html" title="String tokenizer class, modelled after strtok().">cStringTokenizer</a>("**.host[*] **.router*").asVector());</code> </p>

</div>
</div>
<a class="anchor" id="ae2b6970c74322b7179e136029a187f9c"></a><!-- doxytag: member="cTopology::extractByNedTypeName" ref="ae2b6970c74322b7179e136029a187f9c" args="(const std::vector&lt; std::string &gt; &amp;nedTypeNames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::extractByNedTypeName </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nedTypeNames</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts model topology by the fully qualified NED type name of the modules. </p>
<p>All modules whose getNedTypeName() is listed in the given string vector will get included.</p>
<p>Note: If you have all class names as a single, space-separated string, you can use <a class="el" href="classcStringTokenizer.html" title="String tokenizer class, modelled after strtok().">cStringTokenizer</a> to turn it into a string vector:</p>
<p><code>topo.extractByNedTypeName(<a class="el" href="classcStringTokenizer.html" title="String tokenizer class, modelled after strtok().">cStringTokenizer</a>("some.package.Host other.package.Router").asVector());</code> </p>

</div>
</div>
<a class="anchor" id="a5a5f9bd454fb850d158640e4f8c7cd0c"></a><!-- doxytag: member="cTopology::extractByParameter" ref="a5a5f9bd454fb850d158640e4f8c7cd0c" args="(const char *paramName, const char *paramValue=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::extractByParameter </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>paramName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>paramValue</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts model topology by a module parameter. </p>
<p>All modules get included that have a parameter with the given name, and the parameter's str() method returns the paramValue string. If paramValue is NULL, only the parameter's existence is checked but not its value. </p>

</div>
</div>
<a class="anchor" id="a387ea85304d459e6da463fea8aeb7f72"></a><!-- doxytag: member="cTopology::extractByProperty" ref="a387ea85304d459e6da463fea8aeb7f72" args="(const char *propertyName, const char *value=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::extractByProperty </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>propertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts model topology by a module property. </p>
<p>All modules get included that have a property with the given name and the given value (more precisely, the first value of its default key being the specified value). If value is NULL, the property's value may be anything except "false" (i.e. the first value of the default key may not be "false").</p>
<p>For example, <code>topo.extractByProperty("node");</code> would extract all modules that contain the <code>@node</code> property, like the following one:</p>
<pre>
 module X {
     @node;
 }
 </pre> 
</div>
</div>
<a class="anchor" id="a449b5ad0c2916511e76d7b0131a6ef09"></a><!-- doxytag: member="cTopology::extractFromNetwork" ref="a449b5ad0c2916511e76d7b0131a6ef09" args="(bool(*selfunc)(cModule *, void *), void *userdata=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::extractFromNetwork </td>
          <td>(</td>
          <td class="paramtype">bool(*)(<a class="el" href="classcModule.html">cModule</a> *, void *)&nbsp;</td>
          <td class="paramname"> <em>selfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userdata</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts model topology by a user-defined criteria. </p>
<p>Includes into the graph modules for which the passed selfunc() returns nonzero. The userdata parameter may take any value you like, and it is passed back to selfunc() in its second argument. </p>

</div>
</div>
<a class="anchor" id="a90e795af4b961529b8e2d83eca316079"></a><!-- doxytag: member="cTopology::getNode" ref="a90e795af4b961529b8e2d83eca316079" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcTopology_1_1Node.html">Node</a>* cTopology::getNode </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns pointer to the ith node in the graph. </p>
<p>Node's methods can be used to further examine the node's connectivity, etc. </p>

</div>
</div>
<a class="anchor" id="a4000b9e28b62b3c1816d69695d93da95"></a><!-- doxytag: member="cTopology::getNodeFor" ref="a4000b9e28b62b3c1816d69695d93da95" args="(cModule *mod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcTopology_1_1Node.html">Node</a>* cTopology::getNodeFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td>
          <td class="paramname"> <em>mod</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the graph node which corresponds to the given module in the network. </p>
<p>If no graph node corresponds to the module, the method returns NULL. This method assumes that the topology corresponds to the network, that is, it was probably created with one of the extract...() functions. </p>

</div>
</div>
<a class="anchor" id="a644049ca8239eb389fe20a49e3d3c428"></a><!-- doxytag: member="cTopology::info" ref="a644049ca8239eb389fe20a49e3d3c428" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cTopology::info </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produces a one-line description of the object's contents. </p>
<p>See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarchy.">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classcObject.html#a28c24b5dcb3703c5f6ae92a67bd61c31">cObject</a>.</p>

</div>
</div>
<a class="anchor" id="af9ebab8c0519c82df3f3e358ffd035b2"></a><!-- doxytag: member="cTopology::operator=" ref="af9ebab8c0519c82df3f3e358ffd035b2" args="(const cTopology &amp;topo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcTopology.html">cTopology</a>&amp; cTopology::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcTopology.html">cTopology</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>topo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>
<p>The name member is not copied; see cNamedObject's <a class="el" href="classcTopology.html#af9ebab8c0519c82df3f3e358ffd035b2" title="Assignment operator.">operator=()</a> for more details. </p>

</div>
</div>
<a class="anchor" id="a790b08ba3baa3a66808e5f72525f52d9"></a><!-- doxytag: member="cTopology::parsimPack" ref="a790b08ba3baa3a66808e5f72525f52d9" args="(cCommBuffer *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cTopology::parsimPack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcCommBuffer.html">cCommBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Serializes the object into an MPI send buffer. </p>
<p>Used by the simulation kernel for parallel execution. See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarchy.">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classcOwnedObject.html#a56c49bc9247353a2bb722f6ffa8ba287">cOwnedObject</a>.</p>

</div>
</div>
<a class="anchor" id="a40a84d778bad4bf009bfe6a7661fc33c"></a><!-- doxytag: member="cTopology::parsimUnpack" ref="a40a84d778bad4bf009bfe6a7661fc33c" args="(cCommBuffer *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cTopology::parsimUnpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcCommBuffer.html">cCommBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deserializes the object from an MPI receive buffer Used by the simulation kernel for parallel execution. </p>
<p>See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarchy.">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classcOwnedObject.html#a99ab774a7da23edf9d9f9ac96a066637">cOwnedObject</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ctopology_8h_source.html">ctopology.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Dec 2 11:16:30 2014 for OMNeT++ Simulation Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OMNeT++ Simulation Library: cModule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cModule Class Reference<br/>
<small>
[<a class="el" href="group__SimCore.html">Simulation core classes</a>]</small>
</h1><!-- doxytag: class="cModule" --><!-- doxytag: inherits="cComponent" -->
<p>This class represents modules in the simulation.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cmodule_8h_source.html">cmodule.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cModule:</div>
<div class="dynsection">
 <div class="center">
  <img src="classcModule.png" usemap="#cModule_map" alt=""/>
  <map id="cModule_map" name="cModule_map">
<area href="classcComponent.html" alt="cComponent" shape="rect" coords="90,280,261,304"/>
<area href="classcDefaultList.html" alt="cDefaultList" shape="rect" coords="90,224,261,248"/>
<area href="classcNoncopyableOwnedObject.html" alt="cNoncopyableOwnedObject" shape="rect" coords="90,168,261,192"/>
<area href="classcOwnedObject.html" alt="cOwnedObject" shape="rect" coords="0,112,171,136"/>
<area href="classnoncopyable.html" alt="noncopyable" shape="rect" coords="181,112,352,136"/>
<area href="classcNamedObject.html" alt="cNamedObject" shape="rect" coords="0,56,171,80"/>
<area href="classcObject.html" alt="cObject" shape="rect" coords="0,0,171,24"/>
<area href="classcSimpleModule.html" alt="cSimpleModule" shape="rect" coords="90,392,261,416"/>
</map>
 </div>
</div>

<p><a href="classcModule-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule_1_1ChannelIterator.html">ChannelIterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walks along the channels inside a module, that is, the channels among the module and its submodules.  <a href="classcModule_1_1ChannelIterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule_1_1GateIterator.html">GateIterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates through the gates of a module.  <a href="classcModule_1_1GateIterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule_1_1SubmoduleIterator.html">SubmoduleIterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates through submodules of a compound module.  <a href="classcModule_1_1SubmoduleIterator.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructor, assignment.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp962bc5d4980da519f7427e5c339b2a0c"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#aa91df47dc373480450b61c62fbad934c">cModule</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a621fa6673160bb69c7dc4fe9eb64c8"></a><!-- doxytag: member="cModule::~cModule" ref="a6a621fa6673160bb69c7dc4fe9eb64c8" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a6a621fa6673160bb69c7dc4fe9eb64c8">~cModule</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Redefined cObject member functions.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa1f41a2538be95e9e7389d73943b4719"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a091296dfd37373944cb1532b5c11dd87">forEachChild</a> (<a class="el" href="classcVisitor.html">cVisitor</a> *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a146a9b2d1c67a5c8bb1b54700fca465d">setName</a> (const char *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a8adab0f2496267094680580de65fe1a0">getFullName</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a6aa348e7021a44dd3ce9170569ee210a">getFullPath</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65c95ee15c027f7d4025a098df236787"></a><!-- doxytag: member="cModule::info" ref="a65c95ee15c027f7d4025a098df236787" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a65c95ee15c027f7d4025a098df236787">info</a> () const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Setting up the module.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc7b61236f1bfc3910860070c19b394fe"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a7e62ef5ed283503f29923fea5f2db310">addGate</a> (const char *gatename, <a class="el" href="classcGate.html#ac548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a> type, bool isvector=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#aaa4fcf1c668078ab20be7f56ced5c5d6">setGateSize</a> (const char *gatename, int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a26cef93c2761379ac06ae4b2d66ade27">getOrCreateFirstUnconnectedGate</a> (const char *gatename, char suffix, bool inside, bool expand)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a8995ef1fc6ed92f6b833cf9c9ad1b88f">getOrCreateFirstUnconnectedGatePair</a> (const char *gatename, bool inside, bool expand, <a class="el" href="classcGate.html">cGate</a> *&amp;gatein, <a class="el" href="classcGate.html">cGate</a> *&amp;gateout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a4bbe79e47eae7740fa696afaf0f5f031">finalizeParameters</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a086c439380f400dc6254b5b2d5f1d408">buildInside</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information about the module itself.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpfad33927bc33f09a1e96a1fa512cea58"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a71ee3edc64c50bd9efa5b8d43d155d99">isSimple</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad70f0f04b3a3ec056d2fd139edc30ee"></a><!-- doxytag: member="cModule::isModule" ref="aad70f0f04b3a3ec056d2fd139edc30ee" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#aad70f0f04b3a3ec056d2fd139edc30ee">isModule</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a5cd9789d5e4e5c7ee172cb5f251e3951">isPlaceholder</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcModule.html">cModule</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a6e487556d9301e41654d25c767d58148">getParentModule</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32187b0d8cfa7cee175432073caf6d5c"></a><!-- doxytag: member="cModule::getModuleType" ref="a32187b0d8cfa7cee175432073caf6d5c" args="() const " -->
<a class="el" href="classcModuleType.html">cModuleType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a32187b0d8cfa7cee175432073caf6d5c">getModuleType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcProperties.html">cProperties</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a7d6ccba3d30c32fdb3997093f36872a5">getProperties</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a592b754c94045c707e4f5155f00c18f2">getId</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc24e9322a19c30da173000110f26596"></a><!-- doxytag: member="cModule::isVector" ref="abc24e9322a19c30da173000110f26596" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#abc24e9322a19c30da173000110f26596">isVector</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a604e26394d77938a860eeb4452f25606"></a><!-- doxytag: member="cModule::getIndex" ref="a604e26394d77938a860eeb4452f25606" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a604e26394d77938a860eeb4452f25606">getIndex</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a0a24114f974cfae3444806bd951fc948">getVectorSize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad08955e71fd144469a04f0ea26c22766"></a><!-- doxytag: member="cModule::size" ref="ad08955e71fd144469a04f0ea26c22766" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#ad08955e71fd144469a04f0ea26c22766">size</a> () const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Submodule access.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpf76ee92a4e167f5d1c9a2ef8333a8ec7"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#af61ae8cc41f24a28760a4970dc70cd84">hasSubmodules</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a4c8b47a44c467739610b96d1a2fa979e">findSubmodule</a> (const char *submodname, int idx=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a99f25de7d151adbe802c9b8811ee8e5b">getSubmodule</a> (const char *submodname, int idx=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">_OPPDEPRECATED <a class="el" href="classcModule.html">cModule</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#ae77393ee1923a33e6fe59e6373964f19">getModuleByRelativePath</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#aa2b5815855954afa5056ea8df9a98001">getModuleByPath</a> (const char *path)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Gates.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa8595431f45b279b5d2e91a9cde65db9"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#ac81230070167bdc3db38300ea101f1ab">gate</a> (const char *gatename, int index=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a8a8361fffa84de74b8bf6b549c70543b">gate</a> (const char *gatename, int index=-1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#ad9aedd5fd1dbcfe37baed7e4526c8c8d">gateHalf</a> (const char *gatename, <a class="el" href="classcGate.html#ac548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a> type, int index=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a1a67e61c277bb1d92b0ac3a5c38acfd5">gateHalf</a> (const char *gatename, <a class="el" href="classcGate.html#ac548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a> type, int index=-1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a6ced7b6cd78db73cb1506a5ec15dc562">hasGate</a> (const char *gatename, int index=-1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#aa1c2b8a89896d26041a0cdb1bdd11336">findGate</a> (const char *gatename, int index=-1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a106e3be27a4f665deb922d125bf6936a">gate</a> (int id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a604d651ab2c45c51c11712ac1e86c9ce">gate</a> (int id) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a3beb4e7ef94e2b8cff4a5b90fcb7c743">deleteGate</a> (const char *gatename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; const char * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a97e1b240b3f4c566436180a6471a850b">getGateNames</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcGate.html#ac548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#afdbf2cebc7f52d6518c6f67819d1ec76">gateType</a> (const char *gatename) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a4f373def6f1b151fea20a4b8e72de9f6">isGateVector</a> (const char *gatename) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#ac63b0b9c805c5f335d274195f2fdb28c">gateSize</a> (const char *gatename) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a4d11f590eb1770be0e418da02c68e785">gateBaseId</a> (const char *gatename) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#abd0b3bd68688e456141f855b16a8f836">checkInternalConnections</a> () const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Utilities.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp643104dda96b3e9c759225bc35893f18"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#ad59a57aa7f6b19ff0061cbd87917cb74">getAncestorPar</a> (const char *parname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a818055c32ea09190dcf60200ef06b279"></a><!-- doxytag: member="cModule::getCanvas" ref="a818055c32ea09190dcf60200ef06b279" args="()" -->
virtual <a class="el" href="classcCanvas.html">cCanvas</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a818055c32ea09190dcf60200ef06b279">getCanvas</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public methods for invoking initialize()/finish(), redefined from cComponent.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp7b616818a35f8ff4eb45beba638654dc"></a><a class="el" href="classcComponent.html#a0532af98c1157359b60adcb09f3fefca" title="Single-stage initialization hook.">initialize()</a>, <a class="el" href="classcComponent.html#a2d9bf75f1f04462929e85e10f5f4a24d" title="Multi-stage initialization hook, should be redefined to return the number of initialization...">numInitStages()</a>, and <a class="el" href="classcComponent.html#a85912f961df471a9795d4e8454d9f6b0" title="Finish hook.">finish()</a> are themselves also declared in <a class="el" href="classcComponent.html" title="Common base for module and channel classes: cModule and cChannel.">cComponent</a>, and can be redefined in simple modules by the user to perform initialization and finalization (result recording, etc) tasks. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2479e23e50fd2286730892ef59cc784e"></a><!-- doxytag: member="cModule::callInitialize" ref="a2479e23e50fd2286730892ef59cc784e" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a2479e23e50fd2286730892ef59cc784e">callInitialize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#afa97027522d4296a3436a6bb5cd2fa6e">callInitialize</a> (int stage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a200cedd49110c4b22018dd7ce669b073"></a><!-- doxytag: member="cModule::callFinish" ref="a200cedd49110c4b22018dd7ce669b073" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a200cedd49110c4b22018dd7ce669b073">callFinish</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dynamic module creation.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpf8c762865423b693ae6595c247a364c4"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9c2684239e372abffb4a86ed56a2e17"></a><!-- doxytag: member="cModule::scheduleStart" ref="ad9c2684239e372abffb4a86ed56a2e17" args="(simtime_t t)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#ad9c2684239e372abffb4a86ed56a2e17">scheduleStart</a> (simtime_t t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#aa40e04f3a15395bfad553227c0a51866">deleteModule</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#af9e5fae012b14606d5e58cab261c91af">changeParentTo</a> (<a class="el" href="classcModule.html">cModule</a> *mod)</td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad65e9293fb55c44ed30eef8b1f27df95"></a><!-- doxytag: member="cModule::cGate" ref="ad65e9293fb55c44ed30eef8b1f27df95" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#ad65e9293fb55c44ed30eef8b1f27df95">cGate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c6add72105ce0170138d90021da4d97"></a><!-- doxytag: member="cModule::cSimulation" ref="a3c6add72105ce0170138d90021da4d97" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a3c6add72105ce0170138d90021da4d97">cSimulation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac019ff97fbe4ac5f1ed4f9e2953a8573"></a><!-- doxytag: member="cModule::cModuleType" ref="ac019ff97fbe4ac5f1ed4f9e2953a8573" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#ac019ff97fbe4ac5f1ed4f9e2953a8573">cModuleType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34161f0247581027e5e313d34f76fdbf"></a><!-- doxytag: member="cModule::cChannelType" ref="a34161f0247581027e5e313d34f76fdbf" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a34161f0247581027e5e313d34f76fdbf">cChannelType</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class represents modules in the simulation. </p>
<p><a class="el" href="classcModule.html" title="This class represents modules in the simulation.">cModule</a> can be used directly for compound modules. Simple module classes need to be subclassed from <a class="el" href="classcSimpleModule.html" title="Base class for all simple module classes.">cSimpleModule</a>, a class that adds more functionality to <a class="el" href="classcModule.html" title="This class represents modules in the simulation.">cModule</a>.</p>
<p><a class="el" href="classcModule.html" title="This class represents modules in the simulation.">cModule</a> provides gates, parameters, RNG mapping, display strings, and a set of virtual methods.</p>
<p>For navigating the module tree, see: <a class="el" href="classcModule.html#a6e487556d9301e41654d25c767d58148" title="Returns the module containing this module.">getParentModule()</a>, <a class="el" href="classcModule.html#a99f25de7d151adbe802c9b8811ee8e5b" title="Finds a direct submodule with the given name and index, and returns its pointer.">getSubmodule()</a>, <a class="el" href="classcModule_1_1SubmoduleIterator.html" title="Iterates through submodules of a compound module.">cModule::SubmoduleIterator</a>, <a class="el" href="classcModule.html#ae77393ee1923a33e6fe59e6373964f19" title="Finds a module in this module&#39;s subtree, given with its relative path.">getModuleByRelativePath()</a>, <a class="el" href="classcSimulation.html#ad74570b2e108672859083a667a353e47" title="Finds a module by its path.">cSimulation::getModuleByPath()</a>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa91df47dc373480450b61c62fbad934c"></a><!-- doxytag: member="cModule::cModule" ref="aa91df47dc373480450b61c62fbad934c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cModule::cModule </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>Note that module objects should not be created directly, only via their <a class="el" href="classcModuleType.html" title="Abstract class for creating a module of a specific type.">cModuleType</a> objects. <a class="el" href="classcModuleType.html#a60287ca91b5283cf33bc03b7d45fc2cb" title="Creates a module which is not element of a module vector.">cModuleType::create()</a> will do all housekeeping tasks associated with module creation (assigning an ID to the module, inserting it into the global <code>simulation</code> object (see <a class="el" href="classcSimulation.html" title="Simulation manager class.">cSimulation</a>), etc.). </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7e62ef5ed283503f29923fea5f2db310"></a><!-- doxytag: member="cModule::addGate" ref="a7e62ef5ed283503f29923fea5f2db310" args="(const char *gatename, cGate::Type type, bool isvector=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html">cGate</a>* cModule::addGate </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html#ac548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isvector</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a gate or gate vector to the module. </p>
<p>Gate vectors are created with zero size. When the creation of a (non-vector) gate of type cGate::INOUT is requested, actually two gate objects will be created, "gatename$i" and "gatename$o". The specified gatename must not contain a "$i" or "$o" suffix itself.</p>
<p>CAUTION: The return value is only valid when a non-vector INPUT or OUTPUT gate was requested. NULL gets returned for INOUT gates and gate vectors. </p>

</div>
</div>
<a class="anchor" id="a086c439380f400dc6254b5b2d5f1d408"></a><!-- doxytag: member="cModule::buildInside" ref="a086c439380f400dc6254b5b2d5f1d408" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int cModule::buildInside </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In compound modules, this method should be called to create submodules and internal connections after module creation. </p>
<p>This method delegates to doBuildInside(), switching the context to this module for the duration of the call (see simulation.setContextModule()).</p>
<dl class="see"><dt><b>See also:</b></dt><dd>doBuildInside() </dd></dl>

</div>
</div>
<a class="anchor" id="afa97027522d4296a3436a6bb5cd2fa6e"></a><!-- doxytag: member="cModule::callInitialize" ref="afa97027522d4296a3436a6bb5cd2fa6e" args="(int stage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cModule::callInitialize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interface for calling <a class="el" href="classcComponent.html#a0532af98c1157359b60adcb09f3fefca" title="Single-stage initialization hook.">initialize()</a> from outside. </p>
<p>It does a single stage of initialization, and returns <code>true</code> if more stages are required. </p>

<p>Implements <a class="el" href="classcComponent.html#a375336cd9e73e0067e27ef8e9b47276b">cComponent</a>.</p>

</div>
</div>
<a class="anchor" id="af9e5fae012b14606d5e58cab261c91af"></a><!-- doxytag: member="cModule::changeParentTo" ref="af9e5fae012b14606d5e58cab261c91af" args="(cModule *mod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::changeParentTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td>
          <td class="paramname"> <em>mod</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the module under a new parent module. </p>
<p>This functionality may be useful for some (rare) mobility scenarios.</p>
<p>This function could bypass several rules which are enforced when you build the model using NED, so you must observe the following:</p>
<ol type="1">
<li>you cannot insert the module under one of its own submodules. This is checked by this function.</li>
<li>gates of the module cannot be connected when you move it. If you moved a module which is connected to its parent module or to other submodules, you'd create connections that do not obey the module hierarchy, and this is not permitted. This rule is also enforced by the implementation of this function.</li>
<li>it is recommended that the module name be made unique among the submodules of its new parent.</li>
<li>be aware that if the module is part of a module vector, its <a class="el" href="classcModule.html#abc24e9322a19c30da173000110f26596" title="Returns true if this module is in a module vector.">isVector()</a>, <a class="el" href="classcModule.html#a604e26394d77938a860eeb4452f25606" title="Returns the index of the module if it is in a module vector, otherwise 0.">getIndex()</a> and <a class="el" href="classcModule.html#ad08955e71fd144469a04f0ea26c22766" title="Alias for getVectorSize().">size()</a> functions will continue to deliver the same info -- although other elements of the vector will not necessarily be present under the same parent module. </li>
</ol>

</div>
</div>
<a class="anchor" id="abd0b3bd68688e456141f855b16a8f836"></a><!-- doxytag: member="cModule::checkInternalConnections" ref="abd0b3bd68688e456141f855b16a8f836" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cModule::checkInternalConnections </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For compound modules, it checks if all gates are connected inside the module (it returns <code>true</code> if they are OK); for simple modules, it returns <code>true</code>. </p>
<p>This function is called during network setup. </p>

</div>
</div>
<a class="anchor" id="a3beb4e7ef94e2b8cff4a5b90fcb7c743"></a><!-- doxytag: member="cModule::deleteGate" ref="a3beb4e7ef94e2b8cff4a5b90fcb7c743" args="(const char *gatename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::deleteGate </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes a gate, gate pair, or gate vector. </p>
<p>Note: individual gates in a gate vector and one side of an inout gate (i.e. "foo$i") cannot be deleted. IDs of deleted gates will not be reused later. </p>

</div>
</div>
<a class="anchor" id="aa40e04f3a15395bfad553227c0a51866"></a><!-- doxytag: member="cModule::deleteModule" ref="aa40e04f3a15395bfad553227c0a51866" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::deleteModule </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the module and recursively all its submodules. </p>
<p>This method has to be used if a simple module wants to delete itself (<code>delete this</code> is not allowed.) </p>

<p>Reimplemented in <a class="el" href="classcSimpleModule.html#aed071be3b66c9a695b51bfebd19c5aa5">cSimpleModule</a>.</p>

</div>
</div>
<a class="anchor" id="a4bbe79e47eae7740fa696afaf0f5f031"></a><!-- doxytag: member="cModule::finalizeParameters" ref="a4bbe79e47eae7740fa696afaf0f5f031" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::finalizeParameters </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Redefined from <a class="el" href="classcComponent.html" title="Common base for module and channel classes: cModule and cChannel.">cComponent</a>. </p>
<p>This method must be called as part of the module creation process, after moduleType-&gt;create() and before mod-&gt;<a class="el" href="classcModule.html#a086c439380f400dc6254b5b2d5f1d408" title="In compound modules, this method should be called to create submodules and internal...">buildInside()</a>. It finalizes parameter values (e.g. reads the missing ones from omnetpp.ini), and adds gates and gate vectors (whose size may depend on parameter values) to the module.</p>
<p>So the sequence of setting up a module is: 1. modType-&gt;create() 2. set parameter values 3. mod-&gt;<a class="el" href="classcModule.html#a4bbe79e47eae7740fa696afaf0f5f031" title="Redefined from cComponent.">finalizeParameters()</a> -- this creates gates too 4. connect gates (possibly adding new gates via gate++ operations) 5. mod-&gt;<a class="el" href="classcModule.html#a086c439380f400dc6254b5b2d5f1d408" title="In compound modules, this method should be called to create submodules and internal...">buildInside()</a></p>
<p>The above sequence also explains why <a class="el" href="classcModule.html#a4bbe79e47eae7740fa696afaf0f5f031" title="Redefined from cComponent.">finalizeParameters()</a> cannot by merged into either create() or <a class="el" href="classcModule.html#a086c439380f400dc6254b5b2d5f1d408" title="In compound modules, this method should be called to create submodules and internal...">buildInside()</a>. </p>

<p>Reimplemented from <a class="el" href="classcComponent.html#a48d55859565b5f34616adeac268040e6">cComponent</a>.</p>

</div>
</div>
<a class="anchor" id="aa1c2b8a89896d26041a0cdb1bdd11336"></a><!-- doxytag: member="cModule::findGate" ref="aa1c2b8a89896d26041a0cdb1bdd11336" args="(const char *gatename, int index=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int cModule::findGate </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the ID of the gate specified by name and index. </p>
<p>Inout gates cannot be specified (since they are actually two gate objects, not one), only with a "$i" or "$o" suffix. Returns -1 if the gate does not exist. The presence of the index parameter decides whether a vector or a scalar gate will be looked for. </p>

</div>
</div>
<a class="anchor" id="a4c8b47a44c467739610b96d1a2fa979e"></a><!-- doxytag: member="cModule::findSubmodule" ref="a4c8b47a44c467739610b96d1a2fa979e" args="(const char *submodname, int idx=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cModule::findSubmodule </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>submodname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a direct submodule with the given name and index, and returns its module ID. </p>
<p>If the submodule was not found, returns -1. Index must be specified exactly if the module is member of a module vector. </p>

</div>
</div>
<a class="anchor" id="a091296dfd37373944cb1532b5c11dd87"></a><!-- doxytag: member="cModule::forEachChild" ref="a091296dfd37373944cb1532b5c11dd87" args="(cVisitor *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::forEachChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcVisitor.html">cVisitor</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls v-&gt;visit(this) for each contained object. </p>
<p>See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarchy.">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classcComponent.html#a942c1c9d273567b34947659151f52d76">cComponent</a>.</p>

<p>Reimplemented in <a class="el" href="classcSimpleModule.html#ae6c2cca1385f7e0cea5c5a100e4cfb69">cSimpleModule</a>.</p>

</div>
</div>
<a class="anchor" id="a604d651ab2c45c51c11712ac1e86c9ce"></a><!-- doxytag: member="cModule::gate" ref="a604d651ab2c45c51c11712ac1e86c9ce" args="(int id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcGate.html">cGate</a>* cModule::gate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a gate by its ID. </p>
<p>It throws an error for invalid (or stale) IDs.</p>
<p>Note: as of OMNeT++ 4.0, gate IDs are no longer small integers and are not suitable for enumerating all gates of a module. Use <a class="el" href="classcModule_1_1GateIterator.html" title="Iterates through the gates of a module.">GateIterator</a> for that purpose. </p>

<p>References <a class="el" href="cmodule_8h_source.html#l00651">gate()</a>.</p>

<p>Referenced by <a class="el" href="cmodule_8h_source.html#l00651">gate()</a>.</p>

</div>
</div>
<a class="anchor" id="a106e3be27a4f665deb922d125bf6936a"></a><!-- doxytag: member="cModule::gate" ref="a106e3be27a4f665deb922d125bf6936a" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html">cGate</a>* cModule::gate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a gate by its ID. </p>
<p>It throws an error for invalid (or stale) IDs.</p>
<p>Note: as of OMNeT++ 4.0, gate IDs are no longer small integers and are not suitable for enumerating all gates of a module. Use <a class="el" href="classcModule_1_1GateIterator.html" title="Iterates through the gates of a module.">GateIterator</a> for that purpose. </p>

</div>
</div>
<a class="anchor" id="a8a8361fffa84de74b8bf6b549c70543b"></a><!-- doxytag: member="cModule::gate" ref="a8a8361fffa84de74b8bf6b549c70543b" args="(const char *gatename, int index=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcGate.html">cGate</a>* cModule::gate </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Looks up a gate by its name and index. </p>
<p>Gate names with the "$i" or "$o" suffix are also accepted. Throws an error if the gate does not exist. The presence of the index parameter decides whether a vector or a scalar gate will be looked for. </p>

</div>
</div>
<a class="anchor" id="ac81230070167bdc3db38300ea101f1ab"></a><!-- doxytag: member="cModule::gate" ref="ac81230070167bdc3db38300ea101f1ab" args="(const char *gatename, int index=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html">cGate</a>* cModule::gate </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Looks up a gate by its name and index. </p>
<p>Gate names with the "$i" or "$o" suffix are also accepted. Throws an error if the gate does not exist. The presence of the index parameter decides whether a vector or a scalar gate will be looked for. </p>

</div>
</div>
<a class="anchor" id="a4d11f590eb1770be0e418da02c68e785"></a><!-- doxytag: member="cModule::gateBaseId" ref="a4d11f590eb1770be0e418da02c68e785" args="(const char *gatename) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int cModule::gateBaseId </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For vector gates, it returns the ID of gate 0 in the vector, even if the gate size is currently zero. </p>
<p>All gates in the vector can be accessed by ID = gateBaseId + index. For scalar gates, it returns the ID of the gate. If there is no such gate or gate vector, an error gets thrown.</p>
<p>Note: Gate IDs are guaranteed to be stable, i.e. they do not change if the gate vector gets resized, or other gates get added/removed. </p>

</div>
</div>
<a class="anchor" id="a1a67e61c277bb1d92b0ac3a5c38acfd5"></a><!-- doxytag: member="cModule::gateHalf" ref="a1a67e61c277bb1d92b0ac3a5c38acfd5" args="(const char *gatename, cGate::Type type, int index=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcGate.html">cGate</a>* cModule::gateHalf </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html#ac548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the "$i" or "$o" part of an inout gate, depending on the type parameter. </p>
<p>That is, gateHalf("port", cGate::OUTPUT, 3) would return gate "port$o[3]". Throws an error if the gate does not exist. The presence of the index parameter decides whether a vector or a scalar gate will be looked for. </p>

</div>
</div>
<a class="anchor" id="ad9aedd5fd1dbcfe37baed7e4526c8c8d"></a><!-- doxytag: member="cModule::gateHalf" ref="ad9aedd5fd1dbcfe37baed7e4526c8c8d" args="(const char *gatename, cGate::Type type, int index=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html">cGate</a>* cModule::gateHalf </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html#ac548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the "$i" or "$o" part of an inout gate, depending on the type parameter. </p>
<p>That is, gateHalf("port", cGate::OUTPUT, 3) would return gate "port$o[3]". Throws an error if the gate does not exist. The presence of the index parameter decides whether a vector or a scalar gate will be looked for. </p>

</div>
</div>
<a class="anchor" id="ac63b0b9c805c5f335d274195f2fdb28c"></a><!-- doxytag: member="cModule::gateSize" ref="ac63b0b9c805c5f335d274195f2fdb28c" args="(const char *gatename) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int cModule::gateSize </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of the gate vector with the given name. </p>
<p>It returns 1 for non-vector gates, and 0 if the gate does not exist or the vector has size 0. (Zero-size vectors are represented by a single gate whose <a class="el" href="classcModule.html#ad08955e71fd144469a04f0ea26c22766" title="Alias for getVectorSize().">size()</a> returns 0.) Gate names with the "$i" or "$o" suffix are also accepted. Throws an error if there is no such gate or gate vector.</p>
<p>Note: The gate vector size can also be obtained by calling the <a class="el" href="classcGate.html#a37b65df3aa9d178949882e0e7f03362f" title="Alias for getVectorSize().">cGate::size()</a> method of any gate object. </p>

</div>
</div>
<a class="anchor" id="afdbf2cebc7f52d6518c6f67819d1ec76"></a><!-- doxytag: member="cModule::gateType" ref="afdbf2cebc7f52d6518c6f67819d1ec76" args="(const char *gatename) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html#ac548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a> cModule::gateType </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the type of the gate (or gate vector) with the given name. </p>
<p>Gate names with the "$i" or "$o" suffix are also accepted. Throws an error if there is no such gate or gate vector. </p>

</div>
</div>
<a class="anchor" id="ad59a57aa7f6b19ff0061cbd87917cb74"></a><!-- doxytag: member="cModule::getAncestorPar" ref="ad59a57aa7f6b19ff0061cbd87917cb74" args="(const char *parname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcPar.html">cPar</a>&amp; cModule::getAncestorPar </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>parname</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches for the parameter in the parent modules, up to the system module. </p>
<p>If the parameter is not found, throws <a class="el" href="classcRuntimeError.html" title="Thrown when the simulation kernel or other components detect a runtime error.">cRuntimeError</a>. </p>

</div>
</div>
<a class="anchor" id="a8adab0f2496267094680580de65fe1a0"></a><!-- doxytag: member="cModule::getFullName" ref="a8adab0f2496267094680580de65fe1a0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* cModule::getFullName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the full name of the module, which is <a class="el" href="classcNamedObject.html#a5b06a5fdb473bb997c939ba55435c041" title="Returns pointer to the object&#39;s name, a string stored in the object.">getName()</a> plus the index in square brackets (e.g. </p>
<p>"module[4]"). Redefined to add the index. </p>

<p>Reimplemented from <a class="el" href="classcObject.html#ab99d95f3760383d74095668b2939c08f">cObject</a>.</p>

</div>
</div>
<a class="anchor" id="a6aa348e7021a44dd3ce9170569ee210a"></a><!-- doxytag: member="cModule::getFullPath" ref="a6aa348e7021a44dd3ce9170569ee210a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cModule::getFullPath </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the full path name of the module. </p>
<p>Example: <code>"net.node[12].gen"</code>. The original <a class="el" href="classcModule.html#a6aa348e7021a44dd3ce9170569ee210a" title="Returns the full path name of the module.">getFullPath()</a> was redefined in order to hide the global <a class="el" href="classcSimulation.html" title="Simulation manager class.">cSimulation</a> instance from the path name. </p>

<p>Reimplemented from <a class="el" href="classcObject.html#a26c918d8176ea1ce3bc6b87cc7e45464">cObject</a>.</p>

</div>
</div>
<a class="anchor" id="a97e1b240b3f4c566436180a6471a850b"></a><!-- doxytag: member="cModule::getGateNames" ref="a97e1b240b3f4c566436180a6471a850b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;const char *&gt; cModule::getGateNames </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the names of the module's gates. </p>
<p>For gate vectors and inout gates, only the base name is returned (without gate index, "[]" or the "$i"/"$o" suffix). Zero-size gate vectors will also be included.</p>
<p>The strings in the returned array do not need to be deallocated and must not be modified.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcModule.html#afdbf2cebc7f52d6518c6f67819d1ec76" title="Returns the type of the gate (or gate vector) with the given name.">gateType()</a>, <a class="el" href="classcModule.html#a4f373def6f1b151fea20a4b8e72de9f6" title="Returns whether the given gate is a gate vector.">isGateVector()</a>, <a class="el" href="classcModule.html#ac63b0b9c805c5f335d274195f2fdb28c" title="Returns the size of the gate vector with the given name.">gateSize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a592b754c94045c707e4f5155f00c18f2"></a><!-- doxytag: member="cModule::getId" ref="a592b754c94045c707e4f5155f00c18f2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cModule::getId </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the module ID. </p>
<p>It is actually the index of the module in the module vector within the <a class="el" href="classcSimulation.html" title="Simulation manager class.">cSimulation</a> simulation object. Module IDs are guaranteed to be unique during a simulation run (that is, IDs of deleted modules are not given out to newly created modules).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcSimulation.html#a4a52271d194b889ea9013c84a6501435" title="Looks up a module by ID.">cSimulation::getModule()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa2b5815855954afa5056ea8df9a98001"></a><!-- doxytag: member="cModule::getModuleByPath" ref="aa2b5815855954afa5056ea8df9a98001" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcModule.html">cModule</a>* cModule::getModuleByPath </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a module in the module tree, given by its absolute or relative path. </p>
<p>The path is a string of module names separated by dots; the special module name ^ (caret) stands for the parent module. If the path starts with a dot or caret, it is understood as relative to this module, otherwise it is taken to mean an absolute path. For absolute paths, inclusion of the toplevel module's name in the path is optional. Returns NULL if the module was not found.</p>
<p>Examples: ".sink" means the sink submodule; ".queue[2].srv" means the srv submodule of the queue[2] submodule; "^.host2" or ".^.host2" means the host2 sibling module; "src" or "Net.src" means the top src module (provided the network is called Net); "." means this module.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcSimulation.html#ad74570b2e108672859083a667a353e47" title="Finds a module by its path.">cSimulation::getModuleByPath()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae77393ee1923a33e6fe59e6373964f19"></a><!-- doxytag: member="cModule::getModuleByRelativePath" ref="ae77393ee1923a33e6fe59e6373964f19" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_OPPDEPRECATED <a class="el" href="classcModule.html">cModule</a>* cModule::getModuleByRelativePath </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a module in this module's subtree, given with its relative path. </p>
<p>The path is a string of module names separated by dots. Returns NULL if the module was not found.</p>
<p>Deprecated: please use the more powerful <a class="el" href="classcModule.html#aa2b5815855954afa5056ea8df9a98001" title="Finds a module in the module tree, given by its absolute or relative path.">getModuleByPath()</a> instead. </p>

</div>
</div>
<a class="anchor" id="a26cef93c2761379ac06ae4b2d66ade27"></a><!-- doxytag: member="cModule::getOrCreateFirstUnconnectedGate" ref="a26cef93c2761379ac06ae4b2d66ade27" args="(const char *gatename, char suffix, bool inside, bool expand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html">cGate</a>* cModule::getOrCreateFirstUnconnectedGate </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>expand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function for implementing NED's "gate++" syntax. </p>
<p>Returns the next unconnected gate from an input or output gate vector, or input/output half of an inout vector. When gatename names an inout gate vector, the suffix parameter should be set to 'i' or 'o' to select "gatename$i" or "gatename$o"; otherwise suffix should be zero. The inside parameter selects whether to use isConnectedInside() or isConnectedOutside() to test if the gate is connected. The expand parameter tells whether the gate vector should be expanded if all its gates are used up. </p>

</div>
</div>
<a class="anchor" id="a8995ef1fc6ed92f6b833cf9c9ad1b88f"></a><!-- doxytag: member="cModule::getOrCreateFirstUnconnectedGatePair" ref="a8995ef1fc6ed92f6b833cf9c9ad1b88f" args="(const char *gatename, bool inside, bool expand, cGate *&amp;gatein, cGate *&amp;gateout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::getOrCreateFirstUnconnectedGatePair </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html">cGate</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>gatein</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html">cGate</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>gateout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to implement NED's "gate++" syntax. </p>
<p>This variant accepts inout gates only, and the result is returned in the gatein and gateout parameters. The meaning of the inside and expand parameters is the same as with <a class="el" href="classcModule.html#a26cef93c2761379ac06ae4b2d66ade27" title="Helper function for implementing NED&#39;s &quot;gate++&quot; syntax.">getOrCreateFirstUnconnectedGate()</a>. </p>

</div>
</div>
<a class="anchor" id="a6e487556d9301e41654d25c767d58148"></a><!-- doxytag: member="cModule::getParentModule" ref="a6e487556d9301e41654d25c767d58148" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcModule.html">cModule</a>* cModule::getParentModule </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the module containing this module. </p>
<p>For the system module, it returns NULL. </p>

<p>Implements <a class="el" href="classcComponent.html#a54ae9602442ca021ce8f660cd0b9969a">cComponent</a>.</p>

</div>
</div>
<a class="anchor" id="a7d6ccba3d30c32fdb3997093f36872a5"></a><!-- doxytag: member="cModule::getProperties" ref="a7d6ccba3d30c32fdb3997093f36872a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcProperties.html">cProperties</a>* cModule::getProperties </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the properties for this module. </p>
<p>Properties cannot be changed at runtime. Redefined from <a class="el" href="classcComponent.html" title="Common base for module and channel classes: cModule and cChannel.">cComponent</a>. </p>

<p>Implements <a class="el" href="classcComponent.html#a474370c3157dbd6eb9203f8543ae40b1">cComponent</a>.</p>

</div>
</div>
<a class="anchor" id="a99f25de7d151adbe802c9b8811ee8e5b"></a><!-- doxytag: member="cModule::getSubmodule" ref="a99f25de7d151adbe802c9b8811ee8e5b" args="(const char *submodname, int idx=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcModule.html">cModule</a>* cModule::getSubmodule </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>submodname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a direct submodule with the given name and index, and returns its pointer. </p>
<p>If the submodule was not found, returns NULL. Index must be specified exactly if the module is member of a module vector. </p>

</div>
</div>
<a class="anchor" id="a0a24114f974cfae3444806bd951fc948"></a><!-- doxytag: member="cModule::getVectorSize" ref="a0a24114f974cfae3444806bd951fc948" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cModule::getVectorSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of the module vector the module is in. </p>
<p>For non-vector modules it returns 1. </p>

</div>
</div>
<a class="anchor" id="a6ced7b6cd78db73cb1506a5ec15dc562"></a><!-- doxytag: member="cModule::hasGate" ref="a6ced7b6cd78db73cb1506a5ec15dc562" args="(const char *gatename, int index=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cModule::hasGate </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a gate exists. </p>
<p>When invoked without index, it returns whether gate "gatename" or "gatename[]" exists (no matter if the gate vector size is currently zero). When invoked with an index, it returns whether the concrete "gatename[index]" gate exists (gatename being a vector gate). Gate names with the "$i" or "$o" suffix are also accepted. </p>

</div>
</div>
<a class="anchor" id="af61ae8cc41f24a28760a4970dc70cd84"></a><!-- doxytag: member="cModule::hasSubmodules" ref="af61ae8cc41f24a28760a4970dc70cd84" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cModule::hasSubmodules </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the module has submodules, and false otherwise. </p>
<p>To enumerate the submodules use <a class="el" href="classcModule_1_1SubmoduleIterator.html" title="Iterates through submodules of a compound module.">SubmoduleIterator</a>. </p>

</div>
</div>
<a class="anchor" id="a4f373def6f1b151fea20a4b8e72de9f6"></a><!-- doxytag: member="cModule::isGateVector" ref="a4f373def6f1b151fea20a4b8e72de9f6" args="(const char *gatename) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cModule::isGateVector </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the given gate is a gate vector. </p>
<p>Gate names with the "$i" or "$o" suffix are also accepted. Throws an error if there is no such gate or gate vector. </p>

</div>
</div>
<a class="anchor" id="a5cd9789d5e4e5c7ee172cb5f251e3951"></a><!-- doxytag: member="cModule::isPlaceholder" ref="a5cd9789d5e4e5c7ee172cb5f251e3951" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cModule::isPlaceholder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this module is a placeholder module, i.e. </p>
<p>represents a remote module in a parallel simulation run. </p>

</div>
</div>
<a class="anchor" id="a71ee3edc64c50bd9efa5b8d43d155d99"></a><!-- doxytag: member="cModule::isSimple" ref="a71ee3edc64c50bd9efa5b8d43d155d99" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cModule::isSimple </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience function. </p>
<p>Returns true this is a simple module (i.e. subclassed from <a class="el" href="classcSimpleModule.html" title="Base class for all simple module classes.">cSimpleModule</a>), false otherwise. </p>

</div>
</div>
<a class="anchor" id="aaa4fcf1c668078ab20be7f56ced5c5d6"></a><!-- doxytag: member="cModule::setGateSize" ref="aaa4fcf1c668078ab20be7f56ced5c5d6" args="(const char *gatename, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::setGateSize </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets gate vector size. </p>
<p>The specified gatename must not contain a "$i" or "$o" suffix: it is not possible to set different vector size for the "$i" or "$o" parts of an inout gate. Changing gate vector size is guaranteed NOT to change any gate IDs. </p>

</div>
</div>
<a class="anchor" id="a146a9b2d1c67a5c8bb1b54700fca465d"></a><!-- doxytag: member="cModule::setName" ref="a146a9b2d1c67a5c8bb1b54700fca465d" args="(const char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::setName </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets object's name. </p>
<p>Redefined to update the stored fullName string. </p>

<p>Reimplemented from <a class="el" href="classcNamedObject.html#afdad5d1296c7c90d494dacfa42d9b5c4">cNamedObject</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cmodule_8h_source.html">cmodule.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Dec 2 11:16:29 2014 for OMNeT++ Simulation Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

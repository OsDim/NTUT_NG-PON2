<!doctype html public "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title>OMNeT++ - Manual</title>
  <meta name="copyright" content="OpenSim Ltd.">
  <meta name="author" content="Andras Varga">
  <meta http-equiv="Content-Language" content="en-us">
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<style type="text/css">
  body,th,td,p,ul,ol,li,h1,h2,h3,h4 { font-family: arial,sans-serif; color: #000000}
  body,td,p,ul,ol,li { font-size:11pt; }
  th,td { font-size:10pt; }
  body { margin-left: 30px; margin-right: 30px; }

  h1 { color: #1A41A8; margin-top: 50px; margin-bottom: 20px; }
  h2 { color: #1A41A8; margin-top: 40px; margin-bottom: 20px; }
  h3 { color: #1A41A8; margin-top: 30px; margin-bottom: 20px; }

  hr.pgbr { color: #f5f5f5; margin-top: 40px; margin-bottom: 10px; }
  p.subheading { color: #1A41A8; margin-top: 30px; font-weight: bold; }
  pre { margin: 4px 8px 4px 2px; padding: 8px 10px; background:#fffff4; border: 1px solid #dddddd; }
  pre.ned { background:#f5fff5; }
  pre.msg { background:#f5fff5; }
  pre.cpp { background:#f5f5f5; }
  pre.inifile { background:#fffff0; }
  pre.filelisting { background:#f0f0f0; }
  pre.commandline { background:#fffff0; }
  table { background:#fffff4; margin-left:8pt; border-collapse:collapse; border: 2px solid; }
  td,th { text-align:left; vertical-align:top; border:1px solid; padding:3pt; border-color:#000000; }
  a { text-decoration: none; }
  a:visited { text-decoration: none; }
  # a:hover { text-decoration: underline; }
</style>

<body>


  <br>
  <img src='omnetpp.png' border='0'>
  <p style="color: #1A41A8; font-weight: bold; font-size: 32px; margin-top: 15px; margin-bottom: 5px">User Manual</p>
  <p style="color: #1A41A8; font-weight: bold; font-size: 18px; margin-top: 5px; margin-bottom: 10px">OMNeT++ version 4.6</p>
  <p style="color: #1A41A8; font-weight: bold; font-size: 12px; margin-top: 5px; margin-bottom: 40px"><a href="http://omnetpp.org">http://omnetpp.org</a></p>
  <hr>


<h1>Chapters</h1>
<p>
<b><a href="#toc_1" class="toc">1 Introduction</a></b><br>
<b><a href="#toc_2" class="toc">2 Overview</a></b><br>
<b><a href="#toc_3" class="toc">3 The NED Language</a></b><br>
<b><a href="#toc_4" class="toc">4 Simple Modules</a></b><br>
<b><a href="#toc_5" class="toc">5 Messages and Packets</a></b><br>
<b><a href="#toc_6" class="toc">6 Message Definitions</a></b><br>
<b><a href="#toc_7" class="toc">7 The Simulation Library</a></b><br>
<b><a href="#toc_8" class="toc">8 Building Simulation Programs</a></b><br>
<b><a href="#toc_9" class="toc">9 Configuring Simulations</a></b><br>
<b><a href="#toc_10" class="toc">10 Running Simulations</a></b><br>
<b><a href="#toc_11" class="toc">11 Network Graphics And Animation</a></b><br>
<b><a href="#toc_12" class="toc">12 Result Recording and Analysis</a></b><br>
<b><a href="#toc_13" class="toc">13 Eventlog</a></b><br>
<b><a href="#toc_14" class="toc">14 Documenting NED and Messages</a></b><br>
<b><a href="#toc_15" class="toc">15 Testing</a></b><br>
<b><a href="#toc_16" class="toc">16 Parallel Distributed Simulation</a></b><br>
<b><a href="#toc_17" class="toc">17 Plug-in Extensions</a></b><br>
<b><a href="#toc_18" class="toc">18 Embedding the Simulation Kernel</a></b><br>
<b><a href="#toc_19" class="toc">19 Appendix&#58; NED Reference</a></b><br>
<b><a href="#toc_20" class="toc">20 Appendix&#58; NED Language Grammar</a></b><br>
<b><a href="#toc_21" class="toc">21 Appendix&#58; NED XML Binding</a></b><br>
<b><a href="#toc_22" class="toc">22 Appendix&#58; NED Functions</a></b><br>
<b><a href="#toc_23" class="toc">23 Appendix&#58; Message Definitions Grammar</a></b><br>
<b><a href="#toc_24" class="toc">24 Appendix&#58; Display String Tags</a></b><br>
<b><a href="#toc_25" class="toc">25 Appendix&#58; Configuration Options</a></b><br>
<b><a href="#toc_26" class="toc">26 Appendix&#58; Result File Formats</a></b><br>
<b><a href="#toc_27" class="toc">27 Appendix&#58; Eventlog File Format</a></b><br>
</p><h1>Table of Contents</h1>
<p>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_1"/><a href="#sec100" class="toc">1 Introduction</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_1.1"/><a href="#sec101" class="toc">1.1 What Is OMNeT++?</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_1.2"/><a href="#sec102" class="toc">1.2 Organization of This Manual</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_2"/><a href="#sec103" class="toc">2 Overview</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1"/><a href="#sec104" class="toc">2.1 Modeling Concepts</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.1"/><a href="#sec105" class="toc">2.1.1 Hierarchical Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.2"/><a href="#sec106" class="toc">2.1.2 Module Types</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.3"/><a href="#sec107" class="toc">2.1.3 Messages, Gates, Links</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.4"/><a href="#sec108" class="toc">2.1.4 Modeling of Packet Transmissions</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.5"/><a href="#sec109" class="toc">2.1.5 Parameters</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.1.6"/><a href="#sec110" class="toc">2.1.6 Topology Description Method</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.2"/><a href="#sec111" class="toc">2.2 Programming the Algorithms</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.3"/><a href="#sec112" class="toc">2.3 Using OMNeT++</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.3.1"/><a href="#sec113" class="toc">2.3.1 Building and Running Simulations</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_2.3.2"/><a href="#sec114" class="toc">2.3.2 What Is in the Distribution</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_3"/><a href="#sec115" class="toc">3 The NED Language</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.1"/><a href="#sec116" class="toc">3.1 NED Overview</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2"/><a href="#sec117" class="toc">3.2 NED Quickstart</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2.1"/><a href="#sec118" class="toc">3.2.1 The Network</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2.2"/><a href="#sec119" class="toc">3.2.2 Introducing a Channel</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2.3"/><a href="#sec120" class="toc">3.2.3 The App, Routing, and Queue Simple Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2.4"/><a href="#sec121" class="toc">3.2.4 The Node Compound Module</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.2.5"/><a href="#sec122" class="toc">3.2.5 Putting It Together</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.3"/><a href="#sec123" class="toc">3.3 Simple Modules</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.4"/><a href="#sec124" class="toc">3.4 Compound Modules</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.5"/><a href="#sec125" class="toc">3.5 Channels</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.6"/><a href="#sec126" class="toc">3.6 Parameters</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.7"/><a href="#sec127" class="toc">3.7 Gates</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.8"/><a href="#sec128" class="toc">3.8 Submodules</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.9"/><a href="#sec129" class="toc">3.9 Connections</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.10"/><a href="#sec130" class="toc">3.10 Multiple Connections</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.10.1"/><a href="#sec131" class="toc">3.10.1 Connection Patterns</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.11"/><a href="#sec132" class="toc">3.11 Parametric Submodule and Connection Types</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.11.1"/><a href="#sec133" class="toc">3.11.1 Parametric Submodule Types</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.11.2"/><a href="#sec134" class="toc">3.11.2 Parametric Connection Types</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.12"/><a href="#sec135" class="toc">3.12 Metadata Annotations (Properties)</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.13"/><a href="#sec136" class="toc">3.13 Inheritance</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_3.14"/><a href="#sec137" class="toc">3.14 Packages</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_4"/><a href="#sec138" class="toc">4 Simple Modules</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1"/><a href="#sec139" class="toc">4.1 Simulation Concepts</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1.1"/><a href="#sec140" class="toc">4.1.1 Discrete Event Simulation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1.2"/><a href="#sec141" class="toc">4.1.2 The Event Loop</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1.3"/><a href="#sec142" class="toc">4.1.3 Events and Event Execution Order in OMNeT++</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1.4"/><a href="#sec143" class="toc">4.1.4 Simulation Time</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.1.5"/><a href="#sec144" class="toc">4.1.5 FES Implementation</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.2"/><a href="#sec145" class="toc">4.2 Components, Simple Modules, Channels</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.3"/><a href="#sec146" class="toc">4.3 Defining Simple Module Types</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.3.1"/><a href="#sec147" class="toc">4.3.1 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.3.2"/><a href="#sec148" class="toc">4.3.2 Constructor</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.3.3"/><a href="#sec149" class="toc">4.3.3 Initialization and Finalization</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.4"/><a href="#sec150" class="toc">4.4 Adding Functionality to cSimpleModule</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.4.1"/><a href="#sec151" class="toc">4.4.1 handleMessage()</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.4.2"/><a href="#sec152" class="toc">4.4.2 activity()</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.4.3"/><a href="#sec153" class="toc">4.4.3 How to Avoid Global Variables</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.4.4"/><a href="#sec154" class="toc">4.4.4 Reusing Module Code via Subclassing</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5"/><a href="#sec155" class="toc">4.5 Accessing Module Parameters</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5.1"/><a href="#sec156" class="toc">4.5.1 Volatile and Non-Volatile Parameters</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5.2"/><a href="#sec157" class="toc">4.5.2 Changing a Parameter's Value</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5.3"/><a href="#sec158" class="toc">4.5.3 Further cPar Methods</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5.4"/><a href="#sec159" class="toc">4.5.4 Emulating Parameter Arrays</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.5.5"/><a href="#sec160" class="toc">4.5.5 handleParameterChange()</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.6"/><a href="#sec161" class="toc">4.6 Accessing Gates and Connections</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.6.1"/><a href="#sec162" class="toc">4.6.1 Gate Objects</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.6.2"/><a href="#sec163" class="toc">4.6.2 Connections</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.6.3"/><a href="#sec164" class="toc">4.6.3 The Connection's Channel</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7"/><a href="#sec165" class="toc">4.7 Sending and Receiving Messages</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.1"/><a href="#sec166" class="toc">4.7.1 Self-Messages</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.2"/><a href="#sec167" class="toc">4.7.2 Sending Messages</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.3"/><a href="#sec168" class="toc">4.7.3 Broadcasts and Retransmissions</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.4"/><a href="#sec169" class="toc">4.7.4 Delayed Sending</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.5"/><a href="#sec170" class="toc">4.7.5 Direct Message Sending</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.6"/><a href="#sec171" class="toc">4.7.6 Packet Transmissions</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.7.7"/><a href="#sec172" class="toc">4.7.7 Receiving Messages with activity()</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.8"/><a href="#sec173" class="toc">4.8 Channels</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.8.1"/><a href="#sec174" class="toc">4.8.1 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.8.2"/><a href="#sec175" class="toc">4.8.2 The Channel API</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.8.3"/><a href="#sec176" class="toc">4.8.3 Channel Examples</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.9"/><a href="#sec177" class="toc">4.9 Stopping the Simulation</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.9.1"/><a href="#sec178" class="toc">4.9.1 Normal Termination</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.9.2"/><a href="#sec179" class="toc">4.9.2 Raising Errors</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.10"/><a href="#sec180" class="toc">4.10 Finite State Machines</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.11"/><a href="#sec181" class="toc">4.11 Navigating the Module Hierarchy</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.12"/><a href="#sec182" class="toc">4.12 Direct Method Calls Between Modules</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13"/><a href="#sec183" class="toc">4.13 Dynamic Module Creation</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.1"/><a href="#sec184" class="toc">4.13.1 When Do You Need Dynamic Module Creation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.2"/><a href="#sec185" class="toc">4.13.2 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.3"/><a href="#sec186" class="toc">4.13.3 Creating Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.4"/><a href="#sec187" class="toc">4.13.4 Deleting Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.5"/><a href="#sec188" class="toc">4.13.5 Module Deletion and finish()</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.6"/><a href="#sec189" class="toc">4.13.6 Creating Connections</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.13.7"/><a href="#sec190" class="toc">4.13.7 Removing Connections</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.14"/><a href="#sec191" class="toc">4.14 Signals</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.14.1"/><a href="#sec192" class="toc">4.14.1 Design Considerations and Rationale</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.14.2"/><a href="#sec193" class="toc">4.14.2 The Signals Mechanism</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.14.3"/><a href="#sec194" class="toc">4.14.3 Listening to Model Changes</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15"/><a href="#sec195" class="toc">4.15 Signal-Based Statistics Recording</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.1"/><a href="#sec196" class="toc">4.15.1 Motivation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.2"/><a href="#sec197" class="toc">4.15.2 Declaring Statistics</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.3"/><a href="#sec198" class="toc">4.15.3 Statistics Recording for Dynamically Registered Signals</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.4"/><a href="#sec199" class="toc">4.15.4 Adding Result Filters and Recorders Programmatically</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.5"/><a href="#sec200" class="toc">4.15.5 Emitting Signals</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_4.15.6"/><a href="#sec201" class="toc">4.15.6 Writing Result Filters and Recorders</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_5"/><a href="#sec202" class="toc">5 Messages and Packets</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.1"/><a href="#sec203" class="toc">5.1 Overview</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2"/><a href="#sec204" class="toc">5.2 The cMessage Class</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.1"/><a href="#sec205" class="toc">5.2.1 Basic Usage</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.2"/><a href="#sec206" class="toc">5.2.2 Duplicating Messages</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.3"/><a href="#sec207" class="toc">5.2.3 Message IDs</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.4"/><a href="#sec208" class="toc">5.2.4 Control Info</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.5"/><a href="#sec209" class="toc">5.2.5 Information About the Last Arrival</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.2.6"/><a href="#sec210" class="toc">5.2.6 Display String</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.3"/><a href="#sec211" class="toc">5.3 Self-Messages</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.3.1"/><a href="#sec212" class="toc">5.3.1 Using a Message as Self-Message</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.3.2"/><a href="#sec213" class="toc">5.3.2 Context Pointer</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4"/><a href="#sec214" class="toc">5.4 The cPacket Class</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.1"/><a href="#sec215" class="toc">5.4.1 Basic Usage</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.2"/><a href="#sec216" class="toc">5.4.2 Identifying the Protocol</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.3"/><a href="#sec217" class="toc">5.4.3 Information About the Last Transmission</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.4"/><a href="#sec218" class="toc">5.4.4 Encapsulating Packets</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.5"/><a href="#sec219" class="toc">5.4.5 Reference Counting</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.4.6"/><a href="#sec220" class="toc">5.4.6 Encapsulating Several Packets</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.5"/><a href="#sec221" class="toc">5.5 Attaching Parameters and Objects</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.5.1"/><a href="#sec222" class="toc">5.5.1 Attaching Objects</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_5.5.2"/><a href="#sec223" class="toc">5.5.2 Attaching Parameters</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_6"/><a href="#sec224" class="toc">6 Message Definitions</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.1"/><a href="#sec225" class="toc">6.1 Introduction</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.1.1"/><a href="#sec226" class="toc">6.1.1 The First Message Class</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2"/><a href="#sec227" class="toc">6.2 Messages and Packets</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.1"/><a href="#sec228" class="toc">6.2.1 Defining Messages and Packets</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.2"/><a href="#sec229" class="toc">6.2.2 Field Data Types</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.3"/><a href="#sec230" class="toc">6.2.3 Initial Values</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.4"/><a href="#sec231" class="toc">6.2.4 Enums</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.5"/><a href="#sec232" class="toc">6.2.5 Fixed-Size Arrays</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.6"/><a href="#sec233" class="toc">6.2.6 Variable-Size Arrays</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.7"/><a href="#sec234" class="toc">6.2.7 Classes and Structs as Fields</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.8"/><a href="#sec235" class="toc">6.2.8 Pointer Fields</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.9"/><a href="#sec236" class="toc">6.2.9 Inheritance</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.2.10"/><a href="#sec237" class="toc">6.2.10 Assignment of Inherited Fields</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.3"/><a href="#sec238" class="toc">6.3 Classes</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.4"/><a href="#sec239" class="toc">6.4 Structs</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.5"/><a href="#sec240" class="toc">6.5 Literal C++ Blocks</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.6"/><a href="#sec241" class="toc">6.6 Using C++ Types</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.6.1"/><a href="#sec242" class="toc">6.6.1 Announcing Types to the Message Compiler</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.6.2"/><a href="#sec243" class="toc">6.6.2 Making the C++ Declarations Available</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.6.3"/><a href="#sec244" class="toc">6.6.3 Putting it Together</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.7"/><a href="#sec245" class="toc">6.7 Customizing the Generated Class</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.7.1"/><a href="#sec246" class="toc">6.7.1 Customizing Method Names</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.7.2"/><a href="#sec247" class="toc">6.7.2 Customizing the Class via Inheritance</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.7.3"/><a href="#sec248" class="toc">6.7.3 Abstract Fields</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.8"/><a href="#sec249" class="toc">6.8 Using Standard Container Classes for Fields</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.8.1"/><a href="#sec250" class="toc">6.8.1 Typedefs</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.8.2"/><a href="#sec251" class="toc">6.8.2 Abstract Fields</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.9"/><a href="#sec252" class="toc">6.9 Namespaces</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.9.1"/><a href="#sec253" class="toc">6.9.1 Declaring a Namespace</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.9.2"/><a href="#sec254" class="toc">6.9.2 C++ Blocks and Namespace</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.9.3"/><a href="#sec255" class="toc">6.9.3 Type Announcements and Namespace</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.10"/><a href="#sec256" class="toc">6.10 Descriptor Classes</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_6.11"/><a href="#sec257" class="toc">6.11 Summary</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_7"/><a href="#sec258" class="toc">7 The Simulation Library</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1"/><a href="#sec259" class="toc">7.1 Class Library Conventions</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.1"/><a href="#sec260" class="toc">7.1.1 Base Class</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.2"/><a href="#sec261" class="toc">7.1.2 Setting and Getting Attributes</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.3"/><a href="#sec262" class="toc">7.1.3 getClassName()</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.4"/><a href="#sec263" class="toc">7.1.4 Object Names</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.5"/><a href="#sec264" class="toc">7.1.5 Object Full Name and Full Path</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.6"/><a href="#sec265" class="toc">7.1.6 Copying and Duplicating Objects</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.7"/><a href="#sec266" class="toc">7.1.7 Iterators</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.1.8"/><a href="#sec267" class="toc">7.1.8 Error Handling</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.2"/><a href="#sec268" class="toc">7.2 Logging from Modules</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.3"/><a href="#sec269" class="toc">7.3 Simulation Time Conversion</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4"/><a href="#sec270" class="toc">7.4 Generating Random Numbers</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4.1"/><a href="#sec271" class="toc">7.4.1 Random Number Generators</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4.2"/><a href="#sec272" class="toc">7.4.2 Random Number Streams, RNG Mapping</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4.3"/><a href="#sec273" class="toc">7.4.3 Accessing The RNGs</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4.4"/><a href="#sec274" class="toc">7.4.4 Random Variates</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.4.5"/><a href="#sec275" class="toc">7.4.5 Random Numbers from Histograms</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.5"/><a href="#sec276" class="toc">7.5 Container Classes</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.5.1"/><a href="#sec277" class="toc">7.5.1 Queue class: cQueue</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.5.2"/><a href="#sec278" class="toc">7.5.2 Expandable Array: cArray</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.6"/><a href="#sec279" class="toc">7.6 Routing Support: cTopology</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.6.1"/><a href="#sec280" class="toc">7.6.1 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.6.2"/><a href="#sec281" class="toc">7.6.2 Basic Usage</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.6.3"/><a href="#sec282" class="toc">7.6.3 Shortest Paths</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.7"/><a href="#sec283" class="toc">7.7 Pattern Matching</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.7.1"/><a href="#sec284" class="toc">7.7.1 cPatternMatcher</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.7.2"/><a href="#sec285" class="toc">7.7.2 cMatchExpression</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.8"/><a href="#sec286" class="toc">7.8 Statistics and Distribution Estimation</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.8.1"/><a href="#sec287" class="toc">7.8.1 cStatistic and Descendants</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.8.2"/><a href="#sec288" class="toc">7.8.2 Distribution Estimation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.8.3"/><a href="#sec289" class="toc">7.8.3 The k-split Algorithm</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.8.4"/><a href="#sec290" class="toc">7.8.4 Transient Detection and Result Accuracy</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.9"/><a href="#sec291" class="toc">7.9 Recording Simulation Results</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.9.1"/><a href="#sec292" class="toc">7.9.1 Output Vectors: cOutVector</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.9.2"/><a href="#sec293" class="toc">7.9.2 Output Scalars</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10"/><a href="#sec294" class="toc">7.10 Watches and Snapshots</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.1"/><a href="#sec295" class="toc">7.10.1 Basic Watches</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.2"/><a href="#sec296" class="toc">7.10.2 Read-write Watches</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.3"/><a href="#sec297" class="toc">7.10.3 Structured Watches</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.4"/><a href="#sec298" class="toc">7.10.4 STL Watches</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.5"/><a href="#sec299" class="toc">7.10.5 Snapshots</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.10.6"/><a href="#sec300" class="toc">7.10.6 Getting Coroutine Stack Usage</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.11"/><a href="#sec301" class="toc">7.11 Defining New NED Functions</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.11.1"/><a href="#sec302" class="toc">7.11.1 Define_NED_Function()</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.11.2"/><a href="#sec303" class="toc">7.11.2 Define_NED_Math_Function()</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.12"/><a href="#sec304" class="toc">7.12 Deriving New Classes</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.12.1"/><a href="#sec305" class="toc">7.12.1 cOwnedObject or Not?</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.12.2"/><a href="#sec306" class="toc">7.12.2 cOwnedObject Virtual Methods</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.12.3"/><a href="#sec307" class="toc">7.12.3 Class Registration</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.12.4"/><a href="#sec308" class="toc">7.12.4 Details</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.13"/><a href="#sec309" class="toc">7.13 Object Ownership Management</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.13.1"/><a href="#sec310" class="toc">7.13.1 The Ownership Tree</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_7.13.2"/><a href="#sec311" class="toc">7.13.2 Managing Ownership</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_8"/><a href="#sec312" class="toc">8 Building Simulation Programs</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.1"/><a href="#sec313" class="toc">8.1 Overview</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2"/><a href="#sec314" class="toc">8.2 Using gcc</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.1"/><a href="#sec315" class="toc">8.2.1 The opp_makemake Tool</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.2"/><a href="#sec316" class="toc">8.2.2 Basic Use</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.3"/><a href="#sec317" class="toc">8.2.3 Debug and Release Builds</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.4"/><a href="#sec318" class="toc">8.2.4 Debugging the Makefile</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.5"/><a href="#sec319" class="toc">8.2.5 Using External C/C++ Libraries</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.6"/><a href="#sec320" class="toc">8.2.6 Building Directory Trees</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.7"/><a href="#sec321" class="toc">8.2.7 Automatic Include Dirs</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.8"/><a href="#sec322" class="toc">8.2.8 Dependency Handling</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.9"/><a href="#sec323" class="toc">8.2.9 Out-of-Directory Build</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.10"/><a href="#sec324" class="toc">8.2.10 Building Shared and Static Libraries</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.11"/><a href="#sec325" class="toc">8.2.11 Recursive Builds</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.12"/><a href="#sec326" class="toc">8.2.12 Customizing the Makefile</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.13"/><a href="#sec327" class="toc">8.2.13 Projects with Multiple Source Trees</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_8.2.14"/><a href="#sec328" class="toc">8.2.14 A Multi-Directory Example</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_9"/><a href="#sec329" class="toc">9 Configuring Simulations</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.1"/><a href="#sec330" class="toc">9.1 The Configuration File</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.1.1"/><a href="#sec331" class="toc">9.1.1 An Example</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.1.2"/><a href="#sec332" class="toc">9.1.2 File Syntax</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.1.3"/><a href="#sec333" class="toc">9.1.3 File Inclusion</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2"/><a href="#sec334" class="toc">9.2 Sections</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.1"/><a href="#sec335" class="toc">9.2.1 The [General] Section</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.2"/><a href="#sec336" class="toc">9.2.2 Named Configurations</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.2.3"/><a href="#sec337" class="toc">9.2.3 Section Inheritance</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.3"/><a href="#sec338" class="toc">9.3 Assigning Module Parameters</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.3.1"/><a href="#sec339" class="toc">9.3.1 Using Wildcard Patterns</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.3.2"/><a href="#sec340" class="toc">9.3.2 Using the Default Values</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.4"/><a href="#sec341" class="toc">9.4 Parameter Studies</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.4.1"/><a href="#sec342" class="toc">9.4.1 Iterations</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.4.2"/><a href="#sec343" class="toc">9.4.2 Named Iteration Variables</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.4.3"/><a href="#sec344" class="toc">9.4.3 Parallel Iteration</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.4.4"/><a href="#sec345" class="toc">9.4.4 Predefined Variables, Run ID</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.4.5"/><a href="#sec346" class="toc">9.4.5 Constraint Expression</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.4.6"/><a href="#sec347" class="toc">9.4.6 Repeating Runs with Different Seeds</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.4.7"/><a href="#sec348" class="toc">9.4.7 Experiment-Measurement-Replication</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.5"/><a href="#sec349" class="toc">9.5 Configuring the Random Number Generators</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.5.1"/><a href="#sec350" class="toc">9.5.1 Number of RNGs</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.5.2"/><a href="#sec351" class="toc">9.5.2 RNG Choice</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.5.3"/><a href="#sec352" class="toc">9.5.3 RNG Mapping</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.5.4"/><a href="#sec353" class="toc">9.5.4 Automatic Seed Selection</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_9.5.5"/><a href="#sec354" class="toc">9.5.5 Manual Seed Configuration</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_10"/><a href="#sec355" class="toc">10 Running Simulations</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.1"/><a href="#sec356" class="toc">10.1 Introduction</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.1.1"/><a href="#sec357" class="toc">10.1.1 Running a Simulation Executable</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.1.2"/><a href="#sec358" class="toc">10.1.2 Running a Shared Library</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.1.3"/><a href="#sec359" class="toc">10.1.3 Controlling the Run</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.2"/><a href="#sec360" class="toc">10.2 Cmdenv: the Command-Line Interface</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.2.1"/><a href="#sec361" class="toc">10.2.1 Example Run</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.2.2"/><a href="#sec362" class="toc">10.2.2 Command-Line Options</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.2.3"/><a href="#sec363" class="toc">10.2.3 Cmdenv Ini File Options</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.2.4"/><a href="#sec364" class="toc">10.2.4 Interpreting Cmdenv Output</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.3"/><a href="#sec365" class="toc">10.3 Tkenv: the Graphical User Interface</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.3.1"/><a href="#sec366" class="toc">10.3.1 Command-Line and Configuration Options</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4"/><a href="#sec367" class="toc">10.4 Batch Execution</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4.1"/><a href="#sec368" class="toc">10.4.1 Using Cmdenv</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4.2"/><a href="#sec369" class="toc">10.4.2 Using Shell Scripts</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.4.3"/><a href="#sec370" class="toc">10.4.3 Using opp_runall</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.5"/><a href="#sec371" class="toc">10.5 Akaroa Support: Multiple Replications in Parallel</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.5.1"/><a href="#sec372" class="toc">10.5.1 Introduction</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.5.2"/><a href="#sec373" class="toc">10.5.2 What Is Akaroa</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.5.3"/><a href="#sec374" class="toc">10.5.3 Using Akaroa with OMNEST</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.6"/><a href="#sec375" class="toc">10.6 Troubleshooting</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.6.1"/><a href="#sec376" class="toc">10.6.1 Unrecognized Configuration Option</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.6.2"/><a href="#sec377" class="toc">10.6.2 Stack Problems</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.6.3"/><a href="#sec378" class="toc">10.6.3 Memory Leaks and Crashes</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_10.6.4"/><a href="#sec379" class="toc">10.6.4 Simulation Executes Slowly</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_11"/><a href="#sec380" class="toc">11 Network Graphics And Animation</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.1"/><a href="#sec381" class="toc">11.1 Display Strings</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.1.1"/><a href="#sec382" class="toc">11.1.1 Display String Syntax</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.1.2"/><a href="#sec383" class="toc">11.1.2 Display String Placement</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.1.3"/><a href="#sec384" class="toc">11.1.3 Display String Inheritance</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.1.4"/><a href="#sec385" class="toc">11.1.4 Display String Tags Used in Submodule Context</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.1.5"/><a href="#sec386" class="toc">11.1.5 Display String Tags Used in Module Background Context</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.1.6"/><a href="#sec387" class="toc">11.1.6 Connection Display Strings</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.1.7"/><a href="#sec388" class="toc">11.1.7 Message Display Strings</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.2"/><a href="#sec389" class="toc">11.2 Parameter Substitution</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.3"/><a href="#sec390" class="toc">11.3 Colors</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.3.1"/><a href="#sec391" class="toc">11.3.1 Color Names</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.3.2"/><a href="#sec392" class="toc">11.3.2 Icon Colorization</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.4"/><a href="#sec393" class="toc">11.4 Icons</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.4.1"/><a href="#sec394" class="toc">11.4.1 The Image Path</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.4.2"/><a href="#sec395" class="toc">11.4.2 Categorized Icons</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.4.3"/><a href="#sec396" class="toc">11.4.3 Icon Size</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.5"/><a href="#sec397" class="toc">11.5 Layouting</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.6"/><a href="#sec398" class="toc">11.6 Enhancing Animation</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.6.1"/><a href="#sec399" class="toc">11.6.1 Changing Display Strings at Runtime</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_11.6.2"/><a href="#sec400" class="toc">11.6.2 Bubbles</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_12"/><a href="#sec401" class="toc">12 Result Recording and Analysis</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.1"/><a href="#sec402" class="toc">12.1 Result Recording</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.1.1"/><a href="#sec403" class="toc">12.1.1 Using Signals and Declared Statistics</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.1.2"/><a href="#sec404" class="toc">12.1.2 Direct Result Recording</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2"/><a href="#sec405" class="toc">12.2 Configuring Result Collection</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.1"/><a href="#sec406" class="toc">12.2.1 Configuring Signal-Based Statistics Recording</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.2"/><a href="#sec407" class="toc">12.2.2 Warm-up Period</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.3"/><a href="#sec408" class="toc">12.2.3 Result File Names</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.4"/><a href="#sec409" class="toc">12.2.4 Configuring Scalar Results</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.5"/><a href="#sec410" class="toc">12.2.5 Configuring Output Vectors</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.6"/><a href="#sec411" class="toc">12.2.6 Saving Parameters as Scalars</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.2.7"/><a href="#sec412" class="toc">12.2.7 Recording Precision</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.3"/><a href="#sec413" class="toc">12.3 Overview of the Result File Formats</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.3.1"/><a href="#sec414" class="toc">12.3.1 Output Vector Files</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.3.2"/><a href="#sec415" class="toc">12.3.2 Scalar Result Files</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.4"/><a href="#sec416" class="toc">12.4 The Analysis Tool in the Simulation IDE</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.5"/><a href="#sec417" class="toc">12.5 Scave Tool</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.5.1"/><a href="#sec418" class="toc">12.5.1 The <i>filter</i> Command</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.5.2"/><a href="#sec419" class="toc">12.5.2 The <i>index</i> Command</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.5.3"/><a href="#sec420" class="toc">12.5.3 The <i>summary</i> Command</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6"/><a href="#sec421" class="toc">12.6 Alternative Statistical Analysis and Plotting Tools</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6.1"/><a href="#sec422" class="toc">12.6.1 GNU R</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6.2"/><a href="#sec423" class="toc">12.6.2 NumPy, SciPy and MatPlotLib</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6.3"/><a href="#sec424" class="toc">12.6.3 MATLAB or Octave</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6.4"/><a href="#sec425" class="toc">12.6.4 Gnuplot</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6.5"/><a href="#sec426" class="toc">12.6.5 ROOT</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6.6"/><a href="#sec427" class="toc">12.6.6 Grace</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_12.6.7"/><a href="#sec428" class="toc">12.6.7 Spreadsheet Programs</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_13"/><a href="#sec429" class="toc">13 Eventlog</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.1"/><a href="#sec430" class="toc">13.1 Introduction</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.2"/><a href="#sec431" class="toc">13.2 Configuration</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.2.1"/><a href="#sec432" class="toc">13.2.1 File Name</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.2.2"/><a href="#sec433" class="toc">13.2.2 Recording Intervals</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.2.3"/><a href="#sec434" class="toc">13.2.3 Recording Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.2.4"/><a href="#sec435" class="toc">13.2.4 Recording Message Data</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.3"/><a href="#sec436" class="toc">13.3 Eventlog Tool</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.3.1"/><a href="#sec437" class="toc">13.3.1 Filter</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_13.3.2"/><a href="#sec438" class="toc">13.3.2 Echo</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_14"/><a href="#sec439" class="toc">14 Documenting NED and Messages</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.1"/><a href="#sec440" class="toc">14.1 Overview</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.2"/><a href="#sec441" class="toc">14.2 Documentation Comments</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.2.1"/><a href="#sec442" class="toc">14.2.1 Private Comments</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.2.2"/><a href="#sec443" class="toc">14.2.2 More on Comment Placement</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.3"/><a href="#sec444" class="toc">14.3 Referring to Other NED and Message Types</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.3.1"/><a href="#sec445" class="toc">14.3.1 Automatic Linking</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.3.2"/><a href="#sec446" class="toc">14.3.2 Tilde Linking</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.4"/><a href="#sec447" class="toc">14.4 Text Layout and Formatting</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.4.1"/><a href="#sec448" class="toc">14.4.1 Paragraphs and Lists</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.4.2"/><a href="#sec449" class="toc">14.4.2 Special Tags</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.4.3"/><a href="#sec450" class="toc">14.4.3 Text Formatting Using HTML</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.4.4"/><a href="#sec451" class="toc">14.4.4 Escaping HTML Tags</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.5"/><a href="#sec452" class="toc">14.5 Customizing and Adding Pages</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.5.1"/><a href="#sec453" class="toc">14.5.1 Adding a Custom Title Page</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.5.2"/><a href="#sec454" class="toc">14.5.2 Adding Extra Pages</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.5.3"/><a href="#sec455" class="toc">14.5.3 Incorporating Externally Created Pages</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_14.6"/><a href="#sec456" class="toc">14.6 File inclusion</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_15"/><a href="#sec457" class="toc">15 Testing</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.1"/><a href="#sec458" class="toc">15.1 Overview</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.1.1"/><a href="#sec459" class="toc">15.1.1 Verification, validation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.1.2"/><a href="#sec460" class="toc">15.1.2 Unit testing, regression testing</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2"/><a href="#sec461" class="toc">15.2 The opp_test Tool</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.1"/><a href="#sec462" class="toc">15.2.1 Introduction</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.2"/><a href="#sec463" class="toc">15.2.2 Terminology</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.3"/><a href="#sec464" class="toc">15.2.3 Test file syntax</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.4"/><a href="#sec465" class="toc">15.2.4 Test description</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.5"/><a href="#sec466" class="toc">15.2.5 Test code generation</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.6"/><a href="#sec467" class="toc">15.2.6 PASS criteria</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.7"/><a href="#sec468" class="toc">15.2.7 Extra processing steps</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.8"/><a href="#sec469" class="toc">15.2.8 Unresolved</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.9"/><a href="#sec470" class="toc">15.2.9 opp_test synopsys</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.2.10"/><a href="#sec471" class="toc">15.2.10 Writing the control script</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.3"/><a href="#sec472" class="toc">15.3 Implementing various types of tests</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.3.1"/><a href="#sec473" class="toc">15.3.1 Smoke tests</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.3.2"/><a href="#sec474" class="toc">15.3.2 Fingerprint tests</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.3.3"/><a href="#sec475" class="toc">15.3.3 Unit tests</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.3.4"/><a href="#sec476" class="toc">15.3.4 Module tests</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_15.3.5"/><a href="#sec477" class="toc">15.3.5 Statistical tests</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_16"/><a href="#sec478" class="toc">16 Parallel Distributed Simulation</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.1"/><a href="#sec479" class="toc">16.1 Introduction to Parallel Discrete Event Simulation</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.2"/><a href="#sec480" class="toc">16.2 Assessing Available Parallelism in a Simulation Model</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3"/><a href="#sec481" class="toc">16.3 Parallel Distributed Simulation Support in OMNeT++</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3.1"/><a href="#sec482" class="toc">16.3.1 Overview</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3.2"/><a href="#sec483" class="toc">16.3.2 Parallel Simulation Example</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3.3"/><a href="#sec484" class="toc">16.3.3 Placeholder Modules, Proxy Gates</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3.4"/><a href="#sec485" class="toc">16.3.4 Configuration</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_16.3.5"/><a href="#sec486" class="toc">16.3.5 Design of PDES Support in OMNeT++</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_17"/><a href="#sec487" class="toc">17 Plug-in Extensions</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.1"/><a href="#sec488" class="toc">17.1 Overview</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.2"/><a href="#sec489" class="toc">17.2 Plug-in Descriptions</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.2.1"/><a href="#sec490" class="toc">17.2.1 Defining a New Random Number Generator</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.2.2"/><a href="#sec491" class="toc">17.2.2 Defining a New Scheduler</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.2.3"/><a href="#sec492" class="toc">17.2.3 Defining a New Configuration Provider</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.2.4"/><a href="#sec493" class="toc">17.2.4 Defining a New Output Scalar Manager</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.2.5"/><a href="#sec494" class="toc">17.2.5 Defining a New Output Vector Manager</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.2.6"/><a href="#sec495" class="toc">17.2.6 Defining a New Snapshot Manager</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.3"/><a href="#sec496" class="toc">17.3 Accessing the Configuration</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.3.1"/><a href="#sec497" class="toc">17.3.1 Defining New Configuration Options</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.3.2"/><a href="#sec498" class="toc">17.3.2 Reading Values from the Configuration</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_17.4"/><a href="#sec499" class="toc">17.4 Implementing a New User Interface</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_18"/><a href="#sec500" class="toc">18 Embedding the Simulation Kernel</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.1"/><a href="#sec501" class="toc">18.1 Architecture</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2"/><a href="#sec502" class="toc">18.2 Embedding the OMNeT++ Simulation Kernel</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.1"/><a href="#sec503" class="toc">18.2.1 The main() Function</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.2"/><a href="#sec504" class="toc">18.2.2 The simulate() Function</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.3"/><a href="#sec505" class="toc">18.2.3 Providing an Environment Object</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.4"/><a href="#sec506" class="toc">18.2.4 Providing a Configuration Object</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.5"/><a href="#sec507" class="toc">18.2.5 Loading NED Files</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.6"/><a href="#sec508" class="toc">18.2.6 How to Eliminate NED Files</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.7"/><a href="#sec509" class="toc">18.2.7 Assigning Module Parameters</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.8"/><a href="#sec510" class="toc">18.2.8 Extracting Statistics from the Model</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.9"/><a href="#sec511" class="toc">18.2.9 The Simulation Loop</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.10"/><a href="#sec512" class="toc">18.2.10 Multiple, Coexisting Simulations</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.11"/><a href="#sec513" class="toc">18.2.11 Installing a Custom Scheduler</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_18.2.12"/><a href="#sec514" class="toc">18.2.12 Multi-Threaded Programs</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_19"/><a href="#sec515" class="toc">19 Appendix&#58; NED Reference</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1"/><a href="#sec516" class="toc">19.1 Syntax</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.1"/><a href="#sec517" class="toc">19.1.1 NED File Name Extension</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.2"/><a href="#sec518" class="toc">19.1.2 NED File Encoding</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.3"/><a href="#sec519" class="toc">19.1.3 Reserved Words</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.4"/><a href="#sec520" class="toc">19.1.4 Identifiers</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.5"/><a href="#sec521" class="toc">19.1.5 Case Sensitivity</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.6"/><a href="#sec522" class="toc">19.1.6 Literals</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.7"/><a href="#sec523" class="toc">19.1.7 Comments</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.1.8"/><a href="#sec524" class="toc">19.1.8 Grammar</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.2"/><a href="#sec525" class="toc">19.2 Built-in Definitions</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.3"/><a href="#sec526" class="toc">19.3 Packages</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.3.1"/><a href="#sec527" class="toc">19.3.1 Package Declaration</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.3.2"/><a href="#sec528" class="toc">19.3.2 Directory Structure, package.ned</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4"/><a href="#sec529" class="toc">19.4 Components</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.1"/><a href="#sec530" class="toc">19.4.1 Simple Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.2"/><a href="#sec531" class="toc">19.4.2 Compound Modules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.3"/><a href="#sec532" class="toc">19.4.3 Networks</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.4"/><a href="#sec533" class="toc">19.4.4 Channels</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.5"/><a href="#sec534" class="toc">19.4.5 Module Interfaces</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.6"/><a href="#sec535" class="toc">19.4.6 Channel Interfaces</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.7"/><a href="#sec536" class="toc">19.4.7 Resolving the C++ Implementation Class</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.8"/><a href="#sec537" class="toc">19.4.8 Properties</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.9"/><a href="#sec538" class="toc">19.4.9 Parameters</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.10"/><a href="#sec539" class="toc">19.4.10 Pattern Assignments</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.11"/><a href="#sec540" class="toc">19.4.11 Gates</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.12"/><a href="#sec541" class="toc">19.4.12 Submodules</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.13"/><a href="#sec542" class="toc">19.4.13 Connections</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.14"/><a href="#sec543" class="toc">19.4.14 Conditional and Loop Connections, Connection Groups</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.15"/><a href="#sec544" class="toc">19.4.15 Inner Types</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.16"/><a href="#sec545" class="toc">19.4.16 Name Uniqueness</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.17"/><a href="#sec546" class="toc">19.4.17 Parameter Assignment Order</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.18"/><a href="#sec547" class="toc">19.4.18 Type Name Resolution</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.19"/><a href="#sec548" class="toc">19.4.19 Resolution of Parametric Types</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.20"/><a href="#sec549" class="toc">19.4.20 Implementing an Interface</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.21"/><a href="#sec550" class="toc">19.4.21 Inheritance</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.4.22"/><a href="#sec551" class="toc">19.4.22 Network Build Order</A><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5"/><a href="#sec552" class="toc">19.5 Expressions</A></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.1"/><a href="#sec553" class="toc">19.5.1 Operators</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.2"/><a href="#sec554" class="toc">19.5.2 Referencing Parameters and Loop Variables</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.3"/><a href="#sec555" class="toc">19.5.3 The <b><tt>index</tt></b> Operator</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.4"/><a href="#sec556" class="toc">19.5.4 The <b><tt>sizeof()</tt></b> Operator</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.5"/><a href="#sec557" class="toc">19.5.5 Functions</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_19.5.6"/><a href="#sec558" class="toc">19.5.6 Units of Measurement</A><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_20"/><a href="#sec559" class="toc">20 Appendix&#58; NED Language Grammar</A></b></font><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_21"/><a href="#sec560" class="toc">21 Appendix&#58; NED XML Binding</A></b></font><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_22"/><a href="#sec561" class="toc">22 Appendix&#58; NED Functions</A></b></font><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_23"/><a href="#sec562" class="toc">23 Appendix&#58; Message Definitions Grammar</A></b></font><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_24"/><a href="#sec563" class="toc">24 Appendix&#58; Display String Tags</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_24.1"/><a href="#sec564" class="toc">24.1 Module and Connection Display String Tags</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_24.2"/><a href="#sec565" class="toc">24.2 Message Display String Tags</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_25"/><a href="#sec566" class="toc">25 Appendix&#58; Configuration Options</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_25.1"/><a href="#sec567" class="toc">25.1 Configuration Options</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_25.2"/><a href="#sec568" class="toc">25.2 Predefined Configuration Variables</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_26"/><a href="#sec569" class="toc">26 Appendix&#58; Result File Formats</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.1"/><a href="#sec570" class="toc">26.1 Version</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.2"/><a href="#sec571" class="toc">26.2 Run Declaration</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.3"/><a href="#sec572" class="toc">26.3 Attributes</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.4"/><a href="#sec573" class="toc">26.4 Module Parameters</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.5"/><a href="#sec574" class="toc">26.5 Scalar Data</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.6"/><a href="#sec575" class="toc">26.6 Vector Declaration</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.7"/><a href="#sec576" class="toc">26.7 Vector Data</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.8"/><a href="#sec577" class="toc">26.8 Index Header</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.9"/><a href="#sec578" class="toc">26.9 Index Data</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.10"/><a href="#sec579" class="toc">26.10 Statistics Object</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.11"/><a href="#sec580" class="toc">26.11 Field</A></b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_26.12"/><a href="#sec581" class="toc">26.12 Histogram Bin</A></b><br>
<br><font size=+1><b>&nbsp;&nbsp;<a name="toc_27"/><a href="#sec582" class="toc">27 Appendix&#58; Eventlog File Format</A></b></font><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;<a name="toc_27.1"/><a href="#sec583" class="toc">27.1 Supported Entry Types and Their Attributes</A></b><br>
</p><hr class='pgbr'><h1><a name="sec100"/>1 Introduction</h1>
<a name="cha:introduction"></a>

<p>
<h2><a name="sec101"/>1.1 What Is OMNeT++?</h2>

<p>OMNeT++ is an object-oriented modular discrete event network simulation
framework. It has a generic architecture, so it can be (and has been)
used in various problem domains:

<p><ul>
  <li>modeling of wired and wireless communication networks
  <li>protocol modeling
  <li>modeling of queueing networks
  <li>modeling of multiprocessors and other distributed hardware systems
  <li>validating of hardware architectures
  <li>evaluating performance aspects of complex software systems
  <li>in general, modeling and simulation of
        any system where the discrete event approach is suitable, and
        can be conveniently mapped into entities communicating by exchanging
        messages.
</ul>

<p>OMNeT++ itself is not a simulator of anything concrete, but rather
provides infrastructure and tools for <i>writing</i> simulations. One of
the fundamental ingredients of this infrastructure is a component
architecture for simulation models. Models are assembled from reusable
components termed <i>modules</i>. Well-written modules are truly reusable,
and can be combined in various ways like LEGO blocks.

<p>Modules can be connected with each other via gates (other systems would
call them ports), and combined to form compound modules. The depth of
module nesting is not limited. Modules communicate through message passing,
where messages may carry arbitrary data structures. Modules can pass
messages along predefined paths via gates and connections, or directly to
their destination; the latter is useful for wireless simulations, for
example. Modules may have parameters that can be used to customize module
behavior and/or to parameterize the model's topology.
Modules at the lowest level of the module hierarchy are called
simple modules, and they encapsulate model behavior. Simple modules
are programmed in C++, and make use of the simulation library.

<p>OMNeT++ simulations can be run under various user interfaces.
Graphical, animating user interfaces are highly useful for
demonstration and debugging purposes, and command-line user
interfaces are best for batch execution.

<p>The simulator as well as user interfaces and tools are highly portable.
They are tested on the most common operating systems (Linux, Mac OS/X,
Windows), and they can be compiled out of the box or after trivial
modifications on most Unix-like operating systems.

<p>OMNeT++ also supports parallel distributed simulation. OMNeT++ can
use several mechanisms for communication between partitions of
a parallel distributed simulation, for example MPI or named pipes.
The parallel simulation algorithm can easily be extended, or new
ones can be plugged in. Models do not need any special instrumentation
to be run in parallel -- it is just a matter of configuration.
OMNeT++ can even be used for classroom presentation of parallel
simulation algorithms, because simulations can be run in parallel
even under the GUI that provides detailed feedback on what is going on.

<p>OMNEST is the commercially supported version of OMNeT++.
OMNeT++ is free only for academic and non-profit use;
for commercial purposes, one needs to obtain OMNEST licenses
from Simulcraft Inc.

<p>

<h2><a name="sec102"/>1.2 Organization of This Manual</h2>

<p>The manual is organized as follows:

<p><ul>
  <li>The Chapters <a href="#sec100">[1]</a> and <a href="#sec103">[2]</a>
    contain introductory material
  <li>The second group of chapters,
    <a href="#sec115">[3]</a>,
    <a href="#sec138">[4]</a> and
    <a href="#sec258">[7]</a>
    are the programming guide. They present the NED language<!--ned!language-->,
    describe the simulation concepts and their implementation in OMNeT++, explain
    how to write simple<!--module!simple--> modules, and describe the class library.
  <li>The chapters <a href="#sec380">[11]</a> and <a href="#sec439">[14]</a>
    explain how to customize
    the network graphics and how to write NED source code comments
    from which documentation can be generated.
  <li>Chapters <a href="#sec312">[8]</a>,
    <a href="#sec329">[9]</a>, <a href="#sec355">[10]</a> and
    <a href="#sec401">[12]</a> deal with practical issues
    like building and running simulations and analyzing results, and
    describe the tools OMNeT++ provides to support these tasks.
  <li>Chapter <a href="#sec478">[16]</a> is devoted to the support
    of distributed execution.
  <li>Chapters <a href="#sec487">[17]</a> and <a href="#sec500">[18]</a>
    explain the architecture and internals of OMNeT++, as well as
    ways to extend it and embed it into larger applications.
  <li>The appendices provide a reference on the NED language,
    configuration options, file formats, and other details.
</ul>

<p>





<hr class='pgbr'><h1><a name="sec103"/>2 Overview</h1>
<a name="cha:overview"></a>

<p>
<h2><a name="sec104"/>2.1 Modeling Concepts</h2>

<p>An OMNeT++ model consists of modules that communicate with message passing.
The active modules are termed <i>simple modules</i>; they are written in C++,
using the simulation class library. Simple modules can be grouped into
<i>compound modules</i> and so forth; the number of hierarchy levels is
unlimited. The whole model, called network in OMNeT++, is itself a compound module.
Messages can be sent either via connections that span
modules or directly to other modules. The concept of simple and
compound modules is similar to DEVS atomic and coupled models.

<p>In Fig. <a href="#fig:ch-overview:modules">below</a>, boxes represent simple modules
(gray background) and compound modules.
Arrows connecting small boxes represent connections and gates.

<p>
<br>
<img src="over-modules.png">
<center><i>Figure: Simple and compound modules</i></center>
<a name="fig:ch-overview:modules"></a>

<p>

<p>Modules communicate with messages that may contain arbitrary
data, in addition to usual attributes such as a timestamp.
Simple modules typically send messages via gates, but it is also
possible to send them directly to their destination modules. Gates are the
input and output interfaces of modules: messages are sent through
output gates and arrive through input gates. An input gate and output gate
can be linked by a connection. Connections are created within a single
level of module hierarchy; within a compound module, corresponding gates of
two submodules, or a gate of one submodule and a gate of the compound
module can be connected. Connections spanning hierarchy levels are
not permitted, as they would hinder model reuse. Because of the hierarchical
structure of the model, messages typically travel through a chain of
connections, starting and arriving in simple modules. Compound modules act like
"cardboard boxes" in the model, transparently relaying messages between
their inner realm and the outside world. Parameters such as propagation delay,
data rate and bit error rate, can be assigned to connections. One can also
define connection types with specific properties (termed channels) and
reuse them in several places. Modules can have parameters. Parameters are
used mainly to pass configuration data to simple modules, and to help
define model topology. Parameters can take string, numeric, or boolean
values. Because parameters are represented as objects in the program,
parameters -- in addition to holding constants -- may transparently act as
sources of random numbers, with the actual distributions provided with the
model configuration. They may interactively prompt the user for the value,
and they might also hold expressions referencing other parameters. Compound
modules may pass parameters or expressions of parameters to their
submodules.

<p>
OMNeT++ provides efficient tools for the user to describe the
structure of the actual system. Some of the main features are the following:
<ul>
<li>hierarchically nested modules
<li>modules are instances of module types
<li>modules communicate with messages through channels
<li>flexible module parameters
<li>topology description language
</ul>

<p><h3><a name="sec105"/>2.1.1 Hierarchical Modules</h3>

<p>
An OMNeT++ model consists of hierarchically nested
modules<!--module!hierarchy--> that communicate by passing
messages to each other.
OMNeT++ models are often referred to as <i>networks</i>. The top
level module is the <i>system module</i>.  The system module
contains <i>submodules</i> that can also contain submodules
themselves (Fig. <a href="#fig:ch-overview:modules">below</a>). The depth of module
nesting is unlimited, allowing the user to reflect the logical
structure of the actual system in the model structure.

<p>Model structure is described in OMNeT++'s NED language.

<p>Modules that contain submodules are termed <i>compound
  modules</i><!--module!compound-->, as opposed to <i>simple
  modules</i><!--module!simple--> at the lowest level of the
module hierarchy. Simple modules contain the algorithms of the model.
The user implements the simple modules in C++, using the OMNeT++
simulation class library.

<p>
<h3><a name="sec106"/>2.1.2 Module Types</h3>
<!--module!types-->

<p>Both simple and compound modules are instances of <i>module
  types</i>. In describing the model, the user defines module types;
instances of these module types serve as components for more complex
module types. Finally, the user creates the system module as an
instance of a previously defined module type; all modules of the
network are instantiated as submodules and sub-submodules of the
system module.

<p>When a module type is used as a building block, it makes no difference
whether it is a simple or compound module. This allows
the user to split a simple module into several
simple modules embedded into a compound<!--module!compound--> module,
or vice versa, to aggregate the functionality of a compound module into a
single simple module, without affecting existing users of the module
type.

<p>Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create <i>component libraries</i><!--module!libraries-->. This feature
will be discussed later, in chapter <a href="#sec355">[10]</a>.

<p>

<p><h3><a name="sec107"/>2.1.3 Messages, Gates, Links</h3>

<p>Modules communicate by exchanging
<i>messages</i><!--message!exchanging-->. In an actual simulation,
messages can represent frames or packets in a computer network, jobs
or customers in a queuing network or other types of mobile entities.
Messages can contain arbitrarily complex data structures. Simple
modules can send messages either directly to their destination or
along a predefined path, through gates and connections.

<p>
The &#8220;local simulation time&#8221; of a module advances when the module
receives a message. The message can arrive from another module
or from the same module (<i>self-messages</i> are used to implement
timers).

<p>
<i>Gates</i><!--gate--> are the input and output interfaces of
modules; messages are sent out through output gates and arrive through
input gates.

<p>Each <i>connection</i><!--connection--> (also called
<i>link</i><!--link-->) is created within a single level of the
module hierarchy: within a compound module, one can connect the
corresponding gates of two submodules, or a gate of one submodule and
a gate of the compound module (Fig.
<a href="#fig:ch-overview:modules">below</a>).

<p>Because of the hierarchical structure of the model, messages typically
travel through a series of connections, starting and arriving in simple
modules. Compound modules act like &#8220;cardboard boxes&#8221; in the model,
transparently relaying messages between their inner realm and the
outside world.

<p>
<h3><a name="sec108"/>2.1.4 Modeling of Packet Transmissions</h3>

<p>To facilitate the modeling of communication networks, connections
can be used to model physical links. Connections support
the following parameters: <i>data rate</i>, <i>propagation delay</i>,
<i>bit error rate</i> and <i>packet error rate</i>, and may be
disabled. These parameters and the underlying algorithms are encapsulated
into <i>channel</i> objects. The user can parameterize the channel
types provided by OMNeT++, and also create new ones.

<p>When data rates are in use, a packet object is by default delivered to the
target module at the simulation time that corresponds to the end of the
packet reception. Since this behavior is not suitable for the modeling of
some protocols (e.g. half-duplex Ethernet), OMNeT++ provides the possibility
for the target module to specify that it wants the packet object to be
delivered to it when the packet reception starts.

<p>
<h3><a name="sec109"/>2.1.5 Parameters</h3>
<!--module!parameters-->
<!--parameters|seemodule parameters-->

<p>Modules can have parameters. Parameters can be assigned  in either
the NED files or the configuration file <tt>omnetpp.ini</tt>.

<p>Parameters can be used to customize simple module behavior,
and to parameterize the model topology.

<p>Parameters can take string, numeric or boolean values, or can
contain XML data trees. Numeric values include expressions using
other parameters and calling C functions, random variables from
different distributions, and values input interactively by the user.

<p>Numeric-valued parameters can be used to construct topologies in a
flexible way. Within a compound module, parameters can define the
number of submodules, number of gates, and the way the internal
connections are made.

<p>
<h3><a name="sec110"/>2.1.6 Topology Description Method</h3>
<!--topology!description-->

<p>The user defines the structure of the model in NED language descriptions
(Network Description). The NED language will be discussed in detail
in chapter <a href="#sec115">[3]</a>.

<p>
<h2><a name="sec111"/>2.2 Programming the Algorithms</h2>

<p>The simple<!--module!simple--> modules of a model contain algorithms
as C++ functions.
The full flexibility and power of the programming language can
be used, supported by the OMNeT++ simulation class library.
The simulation programmer can choose between event-driven and process-style
description, and freely use object-oriented concepts
(inheritance, polymorphism etc) and design patterns to extend the
functionality of the simulator.

<p>Simulation objects (messages, modules, queues etc.) are represented
by C++ classes. They have been designed to work together efficiently,
creating a powerful simulation programming framework.
The following classes are part of the simulation class library:

<p><ul>
  <li>module, gate, parameter, channel
  <li>message, packet
  <li>container classes (e.g. queue, array)
  <li>data collection classes
  <li>statistic and distribution estimation classes (histograms, <i>P<sup>2</sup></i>
  algorithm for calculating quantiles etc.)
  <li>transient detection and result accuracy detection classes
</ul>

<p>The classes are also specially instrumented, allowing one
to traverse objects of a running simulation and display information
about them such as name, class name, state variables or contents.
This feature makes it possible to create a simulation GUI where
all internals of the simulation are visible.

<p>


<p><h2><a name="sec112"/>2.3 Using OMNeT++</h2>

<p>
<h3><a name="sec113"/>2.3.1 Building and Running Simulations</h3>
<!--simulation!building-->
<!--simulation!running-->

<p>This section provides insights into working with OMNeT++ in practice.
Issues such as model files and compiling and running simulations are
discussed.

<p>An OMNeT++ model consists of the following parts:
<ul>
  <li>NED language topology description(s)<!--ned!files--> (<tt>.ned</tt> files)
    that describe the module structure with parameters, gates, etc.
    NED files can be written using any text editor, but the OMNeT++ IDE
    provides excellent support for two-way graphical and text editing.
  <li>Message definitions (<tt>.msg</tt> files). You can define various message
    types and add data fields to them. OMNeT++ will translate message definitions
    into full-fledged C++ classes.
  <li>Simple module sources. They are C++ files, with <tt>.h</tt>/<tt>.cc</tt> suffix.
</ul>

<p>The simulation system provides the following components:
<ul>
  <li>Simulation kernel<!--simulation!kernel-->. This contains the
    code that manages the simulation and the simulation class library.
    It is written in C++, compiled into a shared or static library.
  <li>User interfaces<!--simulation!user interface-->.
    <!--user interface--> OMNeT++ user interfaces
    are used in simulation execution, to facilitate debugging,
    demonstration, or batch execution of simulations. They are
    written in C++, compiled into libraries.
</ul>

<p>
Simulation programs are built from the above components. First,
<tt>.msg</tt> files are translated into C++ code using the <tt>opp_msgc</tt>.
program. Then all C++ sources are compiled and linked with the simulation
kernel and a user interface library to form a simulation executable or
shared library. NED files<!--ned!files--> are loaded dynamically in their original
text forms when the simulation program starts.

<p>
<p class="subheading">Running the Simulation and Analyzing the Results</p>

<p>The simulation may be compiled as a standalone program executable;
thus it can be run on other machines without OMNeT++
being present, or it can be created as a shared library. In this case the
OMNeT++ shared libraries must be present on that system.
When the program is started, it first reads all NED files<!--ned!files-->
containing your model topology, then it reads a configuration
file<!--simulation!configuration file--> (usually called
<tt>omnetpp.ini</tt><!--omnetpp.ini-->). This file contains settings that
control how the simulation is executed, values for model parameters, etc.
The configuration file can also prescribe several simulation runs; in
the simplest case, they will be executed by the simulation program one
after another.

<p>The output of the simulation is written into result files: output vector
files<!--output!vector file-->, output scalar files<!--output!scalar file-->,
and possibly the user's own output files.
OMNeT++ contains an Integrated Development Environment (IDE) that provides
rich environment for analyzing these files. Output files are line-oriented
text files which makes it possible to process them with a variety of tools
and programming languages as well, including Matlab, GNU R, Perl, Python,
and spreadsheet programs.

<p>
<p class="subheading">User Interfaces</p>
<!--simulation!user interface-->

<p>The primary purpose of user interfaces is to make the internals
of the model visible to the user, to control simulation execution,
and possibly allow the user to intervene by changing variables/objects
inside the model. This is very important in the development/debugging
phase of the simulation project. Equally important, a hands-on
experience allows the user to get a feel of the model's
behavior. The graphical user interface can also be used to
demonstrate a model's operation.

<p>
The same simulation model can be executed with various user
interfaces, with no change in the model files themselves.
The user would typically test and debug the simulation with a powerful
graphical user interface, and finally run it with a simple,
fast user interface that supports batch execution.

<p>
<p class="subheading">Component Libraries</p>
<!--module!libraries-->

<p>Module types can be stored in files separate from the place
of their actual use, enabling the user to group existing
module types and create component libraries.

<p>
<p class="subheading">Universal Standalone Simulation Programs</p>

<p>
A simulation executable can store several independent models
that use the same set of simple modules. The user can specify
in the configuration file which model is to be run. This
allows one to build one large executable that contains several
simulation models, and distribute it as a standalone simulation
tool. The flexibility of the topology description language also
supports this approach.

<p>
<h3><a name="sec114"/>2.3.2 What Is in the Distribution</h3>

<p>If you installed the source distribution, the OMNeT++ directory on your system
should contain the following subdirectories. (If you installed a precompiled
distribution, some of the directories may be missing, or there might be
additional directories, e.g. containing software bundled with OMNeT++.)

<p>The simulation system itself:

<p><pre class="verbatim">
  <b>omnetpp/</b>         OMNeT++ root directory
    <b>bin/</b>           OMNeT++ executables
    <b>include/</b>       header files for simulation models
    <b>lib/</b>           library files
    <b>images/</b>        icons and backgrounds for network graphics
    <b>doc/</b>           manuals, readme files, license, APIs, etc.
      <b>ide-customization-guide/</b> how to write new wizards for the IDE
      <b>ide-developersguide/</b> writing extensions for the IDE
      <b>manual/</b>      manual in HTML
      <b>migration/</b>   how to migrate your models from 3.x to 4.0 version
      <b>ned2/</b>        DTD definition of the XML syntax for NED files
      <b>tictoc-tutorial/</b>  introduction into using OMNeT++
      <b>api/</b>         API reference in HTML
      <b>nedxml-api/</b>  API reference for the NEDXML library
      <b>parsim-api/</b>  API reference for the parallel simulation library
    <b>migrate/</b>       tools to help model migration from 3.x to 4.0 version
    <b>src/</b>           OMNeT++ sources
      <b>sim/</b>         simulation kernel
        <b>parsim/</b>    files for distributed execution
        <b>netbuilder/</b>files for dynamically reading NED files
      <b>envir/</b>       common code for user interfaces
      <b>cmdenv/</b>      command-line user interface
      <b>tkenv/</b>       Tcl/Tk-based user interface
      <b>nedxml/</b>      NEDXML library, nedtool, opp_msgc
      <b>scave/</b>       result analysis library
      <b>eventlog/</b>    eventlog processing library
      <b>layout/</b>      graph layouter for network graphics
      <b>common/</b>      common library
      <b>utils/</b>       opp_makemake, opp_test, etc.
    <b>test/</b>          regression test suite
      <b>core/</b>        tests for the simulation library
      <b>anim/</b>        tests for graphics and animation
      <b>dist/</b>        tests for the built-in distributions
      <b>makemake/</b>    tests for opp_makemake
      ...
</pre>

<p>The Eclipse-based Simulation IDE is in the <tt>ide</tt> directory.

<p><pre class="verbatim">
    <b>ide/</b>           Simulation IDE
      <b>features/</b>    Eclipse feature definitions
      <b>plugins/</b>     IDE plugins (extensions to the IDE can be dropped here)
      ...
</pre>

<p>The Windows version of OMNeT++ contains a redistribution of the MinGW
gcc compiler, together with a copy of MSYS that provides Unix tools
commonly used in Makefiles. The MSYS directory also contains various
3rd party open-source libraries needed to compile and run OMNeT++.

<p><pre class="verbatim">
    <b>tools/</b>       Platform specific tools and compilers (e.g. MinGW/MSYS on Windows)
</pre>

<p>Sample simulations are in the <tt>samples</tt> directory.

<p><pre class="verbatim">
    <b>samples/</b>     directories for sample simulations
      <b>aloha/</b>     models the Aloha protocol
      <b>cqn/</b>       Closed Queueing Network
      ...
</pre>

<p>The <tt>contrib</tt> directory contains material from the OMNeT++ community.

<p><pre class="verbatim">
    <b>contrib/</b>     directory for contributed material
      <b>akaroa/</b>    Patch to compile akaroa on newer gcc systems
      <b>jsimplemodule/</b>  Write simple modules in Java
      <b>topologyexport/</b>  Export the topology of a model in runtime
      ...
</pre>

<p>

<hr class='pgbr'><h1><a name="sec115"/>3 The NED Language</h1>
<a name="cha:the-ned-language"></a>

<p>
<h2><a name="sec116"/>3.1 NED Overview</h2>

<p>The user describes the structure of a simulation model in the NED language. NED
stands for Network Description. NED lets the user declare simple modules, and
connect and assemble them into compound modules. The user can label some compound
modules as <i>networks</i>; that is, self-contained simulation models. Channels are
another component type, whose instances can also be used in compound modules.

<p>The NED language has several features which let it scale well to large projects:

<p><dl>

<p><li><b>Hierarchical.</b>  The traditional way to deal with complexity is by
introducing hierarchies. In OMNeT++, any module which would be too complex as
a single entity can be broken down into smaller modules, and used as a
compound module.

<p><li><b>Component-Based.</b>  Simple modules and compound modules are inherently
reusable, which not only reduces code copying, but more importantly, allows
component libraries (like the INET Framework, MiXiM, Castalia, etc.) to
exist.

<p><li><b>Interfaces.</b>  Module and channel interfaces can be used as a
placeholder where normally a module or channel type would be used, and the
concrete module or channel type is determined at network setup time by a
parameter. Concrete module types have to &#8220;implement&#8221; the interface they
can substitute. For example, given a compound module type named
<tt>MobileHost</tt> contains a <tt>mobility</tt> submodule of the type
<tt>IMobility</tt> (where <tt>IMobility</tt> is a module interface), the actual
type of <tt>mobility</tt> may be chosen from the module types that implemented
<tt>IMobility</tt> (<tt>RandomWalkMobility</tt>, <tt>TurtleMobility</tt>, etc.)

<p><li><b>Inheritance.</b>  Modules and channels can be subclassed. Derived modules
and channels may add new parameters, gates, and (in the case of compound
modules) new submodules and connections. They may set existing parameters
to a specific value, and also set the gate size of a gate vector. This
makes it possible, for example, to take a <tt>GenericTCPClientApp</tt> module
and derive an <tt>FTPClientApp</tt> from it by setting certain parameters to a fixed
value; or to derive a <tt>WebClientHost</tt> compound module from a
<tt>BaseHost</tt> compound module by adding a <tt>WebClientApp</tt> submodule and
connecting it to the inherited <tt>TCP</tt> submodule.

<p><li><b>Packages.</b>  The NED language features a Java-like package structure,
to reduce the risk of name clashes between different models. <tt>NEDPATH</tt>
(similar to Java's <tt>CLASSPATH</tt>) has also been introduced to make it easier
to specify dependencies among simulation models.

<p><li><b>Inner types.</b>  Channel types and module types used locally by a
compound module can be defined within the compound module, in order to
reduce namespace pollution.

<p><li><b>Metadata annotations.</b>  It is possible to annotate module or channel
types, parameters, gates and submodules by adding properties. Metadata are
not used by the simulation kernel directly, but they can carry extra
information for various tools, the runtime environment, or even for other
modules in the model. For example, a module's graphical representation
(icon, etc)  or the prompt string and measurement unit (milliwatt, etc) of a
parameter are already specified as metadata annotations.

<p></dl>

<p><ul class="note"><b>NOTE</b><br>
    The NED language has changed significantly in the 4.0 version.
    Inheritance, interfaces, packages, inner types, metadata annotations, inout
    gates were all added in the 4.0 release, together with many other features.
    Since the basic syntax has changed as well, old NED files need to be
    converted to the new syntax. There are automated tools for this purpose, so
    manual editing is only needed to take advantage of new NED features.
</ul>

<p>The NED language has an equivalent tree representation which can be
serialized to XML; that is, NED files can be converted to XML and back
without loss of data, including comments. This lowers the barrier for
programmatic manipulation of NED files; for example extracting information,
refactoring and transforming NED, generating NED from information stored in
other systems like SQL databases, and so on.

<p><ul class="note"><b>NOTE</b><br>
    This chapter is going to explain the NED language gradually, via examples.
    If you are looking for a more formal and concise treatment, see
    Appendix <a href="#sec559">[20]</a>.
</ul>

<p>
<h2><a name="sec117"/>3.2 NED Quickstart</h2>
<a name="sec:ch-ned-lang:warmup"></a>

<p>In this section we introduce the NED language via a complete and
reasonably real-life example: a communication network.

<p>Our hypothetical network consists of nodes. On each node there is an
application running which generates packets at random intervals.
The nodes are routers themselves as well. We assume that the application
uses datagram-based communication, so that we can leave out the
transport layer from the model.

<p>
<h3><a name="sec118"/>3.2.1 The Network</h3>
<a name="sec:ch-ned-lang:warmup:network"></a>

<p>First we'll define the network, then in the next sections we'll continue
to define the network nodes.

<p>Let the network topology be as in Figure <a href="#fig:ned-routing-topology">below</a>.

<p>
  <br>
  <img src="ned-routing-network.png">
  <center><i>Figure: The network</i></center>
  <a name="fig:ned-routing-topology"></a>

<p>
The corresponding NED description would look like this:

<pre class="ned">
//
// A network
//
network Network
{
    submodules:
        node1: Node;
        node2: Node;
        node3: Node;
        ...
    connections:
        node1.port++ &lt;--&gt; {datarate=100Mbps;} &lt;--&gt; node2.port++;
        node2.port++ &lt;--&gt; {datarate=100Mbps;} &lt;--&gt; node4.port++;
        node4.port++ &lt;--&gt; {datarate=100Mbps;} &lt;--&gt; node6.port++;
        ...
}
</pre>
<p>
The above code defines a network type named <tt>Network</tt>. Note that the NED
language uses the familiar curly brace syntax, and &#8220;<tt>//</tt>&#8221; to denote
comments.

<p><ul class="note"><b>NOTE</b><br>
    Comments in NED not only make the source code more readable, but in the
    OMNeT++ IDE they also are displayed at various places (tooltips, content
    assist, etc), and become part of the documentation extracted from the NED
    files. The NED documentation system, not unlike <i>JavaDoc</i> or
    <i>Doxygen</i>, will be described in Chapter <a href="#sec439">[14]</a>.
</ul>

<p>The network contains several nodes, named <tt>node1</tt>, <tt>node2</tt>, etc.
from the NED module type <tt>Node</tt>. We'll define <tt>Node</tt> in the next
sections.

<p>The second half of the declaration defines how the nodes are to be
connected. The double arrow means bidirectional connection. The connection
points of modules are called gates, and the <tt>port++</tt> notation adds a
new gate to the <tt>port[]</tt> gate vector. Gates and connections will be
covered in more detail in sections <a href="#sec127">[3.7]</a> and
<a href="#sec129">[3.9]</a>. Nodes are connected with a channel that
has a data rate of 100Mbps.

<p><ul class="note"><b>NOTE</b><br>
    In many other systems, the equivalent of OMNeT++ gates are called
    <i>ports</i>. We have retained the term <i>gate</i> to reduce
    collisions with other uses of the otherwise overloaded word
    <i>port</i>: router port, TCP port, I/O port, etc.
</ul>

<p>The above code would be placed into a file named <tt>Net6.ned</tt>. It is
a convention to put every NED definition into its own file and to name the
file accordingly, but it is not mandatory to do so.

<p>One can define any number of networks in the NED files, and for every
simulation the user has to specify which network to set up.
The usual way of specifying the network is to put the <b><tt>network</tt></b>
option into the configuration (by default the <tt>omnetpp.ini</tt> file):

<pre class="inifile">
[General]
network = Network
</pre>
<p>

<p><h3><a name="sec119"/>3.2.2 Introducing a Channel</h3>

<p>It is cumbersome to have to repeat the data rate for every connection.
Luckily, NED provides a convenient solution: one can create a new channel
type that encapsulates the data rate setting, and this channel type can
be defined inside the network so that it does not litter the global
namespace.

<p>The improved network will look like this:

<pre class="ned">
//
// A Network
//
network Network
{
    types:
        channel C extends ned.DatarateChannel {
            datarate = 100Mbps;
        }
    submodules:
        node1: Node;
        node2: Node;
        node3: Node;
        ...
    connections:
        node1.port++ &lt;--&gt; C &lt;--&gt; node2.port++;
        node2.port++ &lt;--&gt; C &lt;--&gt; node4.port++;
        node4.port++ &lt;--&gt; C &lt;--&gt; node6.port++;
        ...
}
</pre>
<p>
Later sections will cover the concepts used (inner types, channels, the
<tt>DatarateChannel</tt> built-in type, inheritance) in detail.

<p>
<h3><a name="sec120"/>3.2.3 The App, Routing, and Queue Simple Modules</h3>

<p>Simple modules are the basic building blocks for other (compound) modules,
denoted by the <b><tt>simple</tt></b> keyword.
All active behavior in the model is encapsulated in <b><tt>simple</tt></b> modules.
Behavior is defined with a C++ class; NED files only declare the externally
visible interface of the module (gates, parameters).

<p>In our example, we could define <tt>Node</tt> as a simple module. However,
its functionality is quite complex (traffic generation, routing, etc),
so it is better to implement it with several smaller simple module types
which we are going to assemble into a compound module. We'll have
one simple module for traffic generation (<tt>App</tt>), one for routing
(<tt>Routing</tt>), and one for queueing up packets to be sent out (<tt>Queue</tt>).
For brevity, we omit the bodies of the latter two in the code below.

<pre class="ned">
simple App
{
    parameters:
        int destAddress;
        ...
        @display("i=block/browser");
    gates:
        input in;
        output out;
}

simple Routing
{
    ...
}

simple Queue
{
    ...
}
</pre>
<p>
By convention, the above simple module declarations go into the
<tt>App.ned</tt>, <tt>Routing.ned</tt> and <tt>Queue.ned</tt> files.

<p><ul class="note"><b>NOTE</b><br>
    Note that module type names (<tt>App</tt>, <tt>Routing</tt>, <tt>Queue</tt>)
    begin with a capital letter, and parameter and gate names begin with
    lowercase -- this is the recommended naming convention. Capitalization
    matters because the language is case sensitive.
</ul>

<p>Let us look at the first simple module type declaration. <tt>App</tt> has a
parameter called <tt>destAddress</tt> (others have been omitted for now),
and two gates named <tt>out</tt> and <tt>in</tt> for sending and receiving
application packets.

<p>The argument of <b><tt>@display()</tt></b> is called a <i>display string</i>,
and it defines the rendering of the module in graphical environments;
<tt>"i=..."</tt> defines the default icon.

<p>Generally, <tt>@</tt>-words like <tt>@display</tt> are called <i>properties</i>
in NED, and they are used to annotate various objects
with metadata. Properties can be attached to files, modules, parameters, gates,
connections, and other objects, and parameter values have a very flexible
syntax.

<p>
<h3><a name="sec121"/>3.2.4 The Node Compound Module</h3>

<p>Now we can assemble <tt>App</tt>, <tt>Routing</tt> and <tt>Queue</tt> into the
compound module <tt>Node</tt>. A compound module can be thought of as
a &#8220;cardboard box&#8221; that groups other modules into a larger unit,
which can further be used as a building block for other modules;
networks are also a kind of compound module.

<p>
  <br>
  <img src="ned-routing-node.png">
  <center><i>Figure: The Node compound module</i></center>
  <a name="fig:ned-routing-node"></a>

<p>
<pre class="ned">
module Node
{
    parameters:
        int address;
        @display("i=misc/node_vs,gold");
    gates:
        inout port[];
    submodules:
        app: App;
        routing: Routing;
        queue[sizeof(port)]: Queue;
    connections:
        routing.localOut --&gt; app.in;
        routing.localIn &lt;-- app.out;
        for i=0..sizeof(port)-1 {
            routing.out[i] --&gt; queue[i].in;
            routing.in[i] &lt;-- queue[i].out;
            queue[i].line &lt;--&gt; port[i];
        }
}
</pre>

<p>Compound modules, like simple modules, may have parameters and gates.
Our <tt>Node</tt> module contains an <tt>address</tt> parameter, plus a
<i>gate vector</i> of unspecified size, named <tt>port</tt>.
The actual gate vector size will be determined implicitly by the number
of neighbours when we create a network from nodes of this type.
The type of <tt>port[]</tt> is <tt>inout</tt>, which allows bidirectional
connections.

<p>The modules that make up the compound module are listed under
<b><tt>submodules</tt></b>. Our <tt>Node</tt> compound module type has an <tt>app</tt> and
a <tt>routing</tt> <i>submodule</i>, plus a <tt>queue[]</tt> <i>submodule
vector</i> that contains one <tt>Queue</tt> module for each port, as specified by
<tt>[sizeof(port)]</tt>. (It is legal to refer to <tt>[sizeof(port)]</tt> because
the network is built in top-down order, and the node is already created and
connected at network level when its submodule structure is built out.)

<p>In the <b><tt>connections</tt></b> section, the submodules are connected to each
other and to the parent module. Single arrows are used to connect input and
output gates, and double arrows connect inout gates, and a <b><tt>for</tt></b> loop
is utilized to connect the <tt>routing</tt> module to each <tt>queue</tt> module, and
to connect the outgoing/incoming link (<tt>line</tt> gate) of each queue to the
corresponding port of the enclosing module.

<p>
<h3><a name="sec122"/>3.2.5 Putting It Together</h3>

<p>We have created the NED definitions for this example, but how are they used by OMNeT++? When
the simulation program is started, it loads the NED files. The program
should already contain the C++ classes that implement the needed simple
modules, <tt>App</tt>, <tt>Routing</tt> and <tt>Queue</tt>; their C++ code is either
part of the executable or is loaded from a shared library. The simulation
program also loads the configuration (<tt>omnetpp.ini</tt>), and determines
from it that the simulation model to be run is the <tt>Network</tt> network.
Then the network is instantiated for simulation.

<p>The simulation model is built in a top-down preorder fashion. This means
that starting from an empty system module, all submodules are created,
their parameters and gate vector sizes are assigned, and they are fully connected
before the submodule internals are built.

<p><br><br>
<center>
* * *
</center>
<br><br>

<p>In the following sections we'll go through the elements of the NED
language and look at them in more detail.

<p>

<p><h2><a name="sec123"/>3.3 Simple Modules</h2>
<a name="sec:ch-ned-lang:simple-modules"></a>

<p>Simple modules are the active components in the model.
Simple modules are defined with the <b><tt>simple</tt></b> keyword.

<p>An example simple module:

<pre class="ned">
simple Queue
{
    parameters:
        int capacity;
        @display("i=block/queue");
    gates:
        input in;
        output out;
}
</pre>
<p>
Both the <b><tt>parameters</tt></b> and <b><tt>gates</tt></b> sections are optional, that is,
they can be left out if there is no parameter or gate. In addition, the
<b><tt>parameters</tt></b> keyword itself is optional too; it can be left out
even if there are parameters or properties.

<p>Note that the NED definition doesn't contain any code to define the
operation of the module: that part is expressed in C++. By default, OMNeT++
looks for C++ classes of the same name as the NED type (so here, <tt>Queue</tt>).

<p>One can explicitly specify the C++ class with the <b><tt>@class</tt></b> property.
Classes with namespace qualifiers are also accepted, as shown in the following
example that uses the <tt>mylib::Queue</tt> class:

<pre class="ned">
simple Queue
{
    parameters:
        int capacity;
        @class(mylib::Queue);
        @display("i=block/queue");
    gates:
        input in;
        output out;
}
</pre>
<p>
If you have several modules that are all in a common namespace, then a
better alternative to <b><tt>@class</tt></b> is the <b><tt>@namespace</tt></b> property. The
C++ namespace given with <b><tt>@namespace</tt></b> will be prepended to the normal
class name. In the following example, the C++ classes will be
<tt>mylib::App</tt>, <tt>mylib::Router</tt> and <tt>mylib::Queue</tt>:

<pre class="ned">
@namespace(mylib);

simple App {
   ...
}

simple Router {
   ...
}

simple Queue {
   ...
}
</pre>
<p>
As you've seen, <b><tt>@namespace</tt></b> can be specified at the file level. Moreover,
when placed in a file called <tt>package.ned</tt>, the namespace will apply to
all files in the same directory and all directories below.

<p>The implementation C++ classes need to be subclassed from the
<tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> library class; chapter <a href="#sec138">[4]</a> of
this manual describes in detail how to write them.

<p>Simple modules can be extended (or specialized) via subclassing. The
motivation for subclassing can be to set some open parameters or gate sizes
to a fixed value (see <a href="#sec126">[3.6]</a> and
<a href="#sec127">[3.7]</a>), or to replace the C++ class with a different
one. Now, by default, the derived NED module type will <i>inherit</i> the
C++ class from its base, so it is important to remember that you need to
write out <b><tt>@class</tt></b> if you want it to use the new class.

<p>The following example shows how to specialize a module by setting a parameter
to a fixed value (and leaving the C++ class unchanged):

<pre class="ned">
simple Queue
{
   int capacity;
   ...
}

simple BoundedQueue extends Queue
{
   capacity = 10;
}
</pre>
<p>
In the next example, the author wrote a <tt>PriorityQueue</tt> C++ class, and
wants to have a corresponding NED type, derived from <tt>Queue</tt>. However,
it does not work as expected:

<pre class="ned">
simple PriorityQueue extends Queue // wrong! still uses the Queue C++ class
{
}
</pre>
<p>
The correct solution is to add a <b><tt>@class</tt></b> property to override the
inherited C++ class:

<pre class="ned">
simple PriorityQueue extends Queue
{
   @class(PriorityQueue);
}
</pre>
<p>
Inheritance in general will be discussed in section <a href="#sec136">[3.13]</a>.

<p>

<p><h2><a name="sec124"/>3.4 Compound Modules</h2>
<a name="sec:ch-ned-lang:compound-modules"></a>

<p>A compound module groups other modules into a larger unit. A compound
module may have gates and parameters like a simple module, but no active
behavior is associated with it.<br><ul><font size=-1>[Although the C++ class
for a compound module can be overridden with the <b><tt>@class</tt></b> property,
this is a feature that should probably never be used. Encapsulate the code
into a simple module, and add it as a submodule.]</font></ul>

<p><ul class="note"><b>NOTE</b><br>
    When there is a temptation to add code to a compound module,
    then encapsulate the code into a simple module, and add it as
    a submodule.
</ul>

<p>A compound module declaration may contain several sections,
all of them optional:

<pre class="ned">
module Host
{
   types:
       ...
   parameters:
       ...
   gates:
       ...
   submodules:
       ...
   connections:
       ...
}
</pre>
<p>
Modules contained in a compound module are called submodules, and they are
listed in the <tt>submodules</tt> section. One can create arrays of submodules
(i.e. submodule vectors), and the submodule type may come from a parameter.

<p>Connections are listed under the <tt>connections</tt> section of the
declaration. One can create connections using simple programming constructs
(loop, conditional). Connection behaviour can be defined by associating a
channel with the connection; the channel type may also come from a
parameter.

<p>Module and channel types only used locally can be defined in the
<tt>types</tt> section as inner types, so that they do not pollute the
namespace.

<p>Compound modules may be extended via subclassing. Inheritance may add new
submodules and new connections as well, not only parameters and gates.
Also, one may refer to inherited submodules, to inherited types etc. What
is not possible is to "de-inherit" or modify submodules or connections.

<p>In the following example, we show how to assemble common protocols
into a "stub" for wireless hosts, and add user agents via
subclassing.<br><ul><font size=-1>[Module types, gate names, etc. used in the example
are fictional, not based on an actual OMNeT++-based model framework]</font></ul>

<pre class="ned">
module WirelessHostBase
{
   gates:
       input radioIn;
   submodules:
       tcp: TCP;
       ip: IP;
       wlan: Ieee80211;
   connections:
       tcp.ipOut --&gt; ip.tcpIn;
       tcp.ipIn &lt;-- ip.tcpOut;
       ip.nicOut++ --&gt; wlan.ipIn;
       ip.nicIn++ &lt;-- wlan.ipOut;
       wlan.radioIn &lt;-- radioIn;
}

module WirelessHost extends WirelessHostBase
{
   submodules:
       webAgent: WebAgent;
   connections:
       webAgent.tcpOut --&gt; tcp.appIn++;
       webAgent.tcpIn &lt;-- tcp.appOut++;
}
</pre>
<p>
The <tt>WirelessHost</tt> compound module can further be extended,
for example with an Ethernet port:

<pre class="ned">
module DesktopHost extends WirelessHost
{
   gates:
       inout ethg;
   submodules:
       eth: EthernetNic;
   connections:
       ip.nicOut++ --&gt; eth.ipIn;
       ip.nicIn++ &lt;-- eth.ipOut;
       eth.phy &lt;--&gt; ethg;
}
</pre>
<p>

<p>
<h2><a name="sec125"/>3.5 Channels</h2>
<a name="sec:ch-ned-lang:channels"></a>

<p>Channels encapsulate parameters and behaviour associated with connections.
Channels are like simple modules, in the sense that there are C++ classes
behind them. The rules for finding the C++ class for a NED channel type is
the same as with simple modules: the default class name is the NED type
name unless there is a <b><tt>@class</tt></b> property (<b><tt>@namespace</tt></b> is also
recognized), and the C++ class is inherited when the channel is subclassed.

<p>Thus, the following channel type would expect a <tt>CustomChannel</tt> C++ class
to be present:

<pre class="ned">
channel CustomChannel  // requires a CustomChannel C++ class
{
}
</pre>
<p>
The practical difference compared to modules is that you rarely need to write you own
channel C++ class because there are predefined channel types that you can
subclass from, inheriting their C++ code. The predefined types are:
<tt>ned.IdealChannel</tt>, <tt>ned.DelayChannel</tt> and <tt>ned.DatarateChannel</tt>.
(&#8220;<tt>ned</tt>&#8221; is the package name; you can get rid of it if you import the types
with the <tt>import ned.*</tt> or similar directive. Packages and imports
are described in section <a href="#sec137">[3.14]</a>.)

<p><tt>IdealChannel</tt> has no parameters, and lets through all messages without
delay or any side effect. A connection without a channel object
and a connection with an <tt>IdealChannel</tt> behave in the same way.
Still, <tt>IdealChannel</tt> has its uses, for example when a channel object
is required so that it can carry a new property or parameter that is
going to be read by other parts of the simulation model.

<p><tt>DelayChannel</tt> has two parameters:

<p><ul>
    <li> <tt>delay</tt> is a <tt>double</tt> parameter which represents the
          propagation delay of the message. Values need to be specified
          together with a time unit (<tt>s</tt>, <tt>ms</tt>, <tt>us</tt>, etc.)
    <li> <tt>disabled</tt> is a boolean parameter that defaults to <tt>false</tt>;
          when set to <tt>true</tt>, the channel object will drop all messages.
</ul>

<p><tt>DatarateChannel</tt> has a few additional parameters compared to <tt>DelayChannel</tt>:

<p><ul>
    <li> <tt>datarate</tt> is a <tt>double</tt> parameter that represents the
          data rate of the channel. Values need to be specified
          in bits per second or its multiples as unit (<tt>bps</tt>,
          <tt>kbps</tt>, <tt>Mbps</tt>, <tt>Gbps</tt>, etc.) Zero is treated
          specially and results in zero transmission duration, i.e.
          it stands for infinite bandwidth. Zero is also the default.
          Data rate is used for calculating the transmission duration of
          packets.
    <li> <tt>ber</tt> and <tt>per</tt> stand for Bit Error Rate and Packet Error Rate,
          and allow basic error modelling. They expect a <tt>double</tt>
          in the <i>[0,1]</i> range. When the channel decides (based on random
          numbers) that an error occurred during transmission of a packet,
          it sets an error flag in the packet object. The receiver
          module is expected to check the flag, and discard the packet
          as corrupted if it is set. The default <tt>ber</tt> and <tt>per</tt>
          are zero.
</ul>

<p><ul class="note"><b>NOTE</b><br>
    There is no channel parameter that specifies whether the channel
    delivers the message object to the destination module at the end or
    at the start of the reception; that is decided by the C++ code
    of the target simple module. See the <tt>setDeliverOnReceptionStart()</tt>
    method of <tt><a href="../api/classcGate.html">cGate</a></tt>.
</ul>

<p>The following example shows how to create a new channel type by
specializing <tt>DatarateChannel</tt>:

<pre class="ned">
channel Ethernet100 extends ned.DatarateChannel
{
    datarate = 100Mbps;
    delay = 100us;
    ber = 1e-10;
}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
    The three built-in channel types are also used for connections where
    the channel type is not explicitly specified.
</ul>

<p>You may add parameters and properties to channels via subclassing, and
may modify existing ones. In the following example, we introduce distance-based
calculation of the propagation delay:

<pre class="ned">
channel DatarateChannel2 extends ned.DatarateChannel
{
    double distance @unit(m);
    delay = this.distance / 200000km * 1s;
}
</pre>
<p>
Parameters are primarily useful as input to the underlying C++ class, but
even if you reuse the underlying C++ class of built-in channel types, they
may be read and used by other parts of the model. For example, adding a
<tt>cost</tt> parameter (or <b><tt>@cost</tt></b> property) may be observed by the
routing algorithm and used for routing decisions. The following example
shows a <tt>cost</tt> parameter, and annotation using a property
(<b><tt>@backbone</tt></b>).

<pre class="ned">
channel Backbone extends ned.DatarateChannel
{
    @backbone;
    double cost = default(1);
}
</pre>
<p>

<p>
<h2><a name="sec126"/>3.6 Parameters</h2>
<a name="sec:ch-ned-lang:parameters"></a>

<p>Parameters are variables that belong to a module. Parameters can be
used in building the topology (number of nodes, etc), and to supply
input to C++ code that implements simple modules and channels.

<p>Parameters can be of type <b><tt>double</tt></b>, <b><tt>int</tt></b>,
<b><tt>bool</tt></b>, <b><tt>string</tt></b> and <b><tt>xml</tt></b>; they can also
be declared <b><tt>volatile</tt></b>. For the numeric types, a unit of
measurement can also be specified (<b><tt>@unit</tt></b> property), to increase
type safety.

<p>Parameters can get their value from NED files or from the configuration
(<tt>omnetpp.ini</tt>). A default value can also be given (<tt>default(</tt>...<tt>)</tt>),
which is used if the parameter is not assigned otherwise.

<p>The following example shows a simple module that has five parameters, three
of which have default values:

<pre class="ned">
simple App
{
    parameters:
        string protocol;       // protocol to use: "UDP" / "IP" / "ICMP" / ...
        int destAddress;       // destination address
        volatile double sendInterval @unit(s) = default(exponential(1s));
                               // time between generating packets
        volatile int packetLength @unit(byte) = default(100B);
                               // length of one packet
        volatile int timeToLive = default(32);
                               // maximum number of network hops to survive
    gates:
        input in;
        output out;
}
</pre>
<p>

<p><p class="subheading">Assigning a Value</p>

<p>Parameters may get their values in several ways: from NED code, from the
configuration (<tt>omnetpp.ini</tt>), or even, interactively from the
user. NED lets you assign parameters at several places: in subclasses via
inheritance; in submodule and connection definitions where the NED type is
instantiated; and in networks and compound modules that directly or
indirectly contain the corresponding submodule or connection.

<p>For instance, one could specialize the above <tt>App</tt> module type via
inheritance with the following definition:

<pre class="ned">
simple PingApp extends App
{
    parameters:
        protocol = "ICMP/ECHO"
        sendInterval = default(1s);
        packetLength = default(64byte);
}
</pre>
<p>
This definition sets the <tt>protocol</tt> parameter to a fixed value
(<tt>"ICMP/ECHO"</tt>), and changes the default values of the
<tt>sendInterval</tt> and <tt>packetLength</tt> parameters. <tt>protocol</tt> is now
locked down in <tt>PingApp</tt>, its value cannot be modified via further subclassing
or other ways. <tt>sendInterval</tt> and <tt>packetLength</tt> are still unassigned
here, only their default values have been overwritten.

<p>Now, let us see the definition of a <tt>Host</tt> compound module that uses
<tt>PingApp</tt> as submodule:

<pre class="ned">
module Host
{
    submodules:
        ping : PingApp {
            packetLength = 128B; // always ping with 128-byte packets
        }
        ...
}
</pre>
<p>
This definition sets the <tt>packetLength</tt> parameter to a fixed value. It
is now hardcoded that <tt>Host</tt>s send 128-byte ping packets; this
setting cannot be changed from NED or the configuration.

<p>It is not only possible to set a parameter from the compound module that
contains the submodule, but also from modules higher up in the module tree.
If you had a network that employed several <tt>Host</tt> modules, it could be
defined like this:

<pre class="ned">
network Network
{
    submodules:
        host[100]: Host {
            ping.timeToLive = default(3);
            ping.destAddress = default(0);
        }
        ...
}
</pre>
<p>
Parameter assignment can also be placed into the <tt>parameters</tt> block of
the parent compound module, which provides additional flexibility. The
following definition sets up the hosts so that half of them pings host #50,
and the other half pings host #0:

<pre class="ned">
network Network
{
    parameters:
        host[*].ping.timeToLive = default(3);
        host[0..49].ping.destAddress = default(50);
        host[50..].ping.destAddress = default(0);

    submodules:
        host[100]: Host;
        ...
}
</pre>
<p>
Note the use of asterisk to match any index, and `<tt>..</tt>' to match index ranges.

<p>If you had a number of individual hosts instead of a submodule vector,
the network definition could look like this:

<pre class="ned">
network Network
{
    parameters:
        host*.ping.timeToLive = default(3);
        host{0..49}.ping.destAddress = default(50);
        host{50..}.ping.destAddress = default(0);

    submodules:
        host0: Host;
        host1: Host;
        host2: Host;
        ...
        host99: Host;
}
</pre>
<p>
An asterisk matches any substring not containing a dot, and a `<tt>..</tt>'
within a pair of curly braces matches a natural number embedded in a
string.

<p>In most assigments we have seen above, the left hand side of the equal sign
contained a dot and often a wildcard as well (asterisk or numeric range);
we call these assignments <i>pattern assignments</i> or <i>deep
assignments</i>.

<p>There is one more wildcard that can be used in pattern assignments, and
this is the double asterisk; it matches any sequence of characters
including dots, so it can match multiple path elements. An example:

<pre class="ned">
network Network
{
    parameters:
        **.timeToLive = default(3);
        **.destAddress = default(0);
    submodules:
        host0: Host;
        host1: Host;
        ...
}
</pre>
<p>
Note that some assignments in the above examples changed default values,
while others set parameters to fixed values. Parameters that received no
fixed value in the NED files can be assigned from the configuration
(<tt>omnetpp.ini</tt>).

<p><ul class="important"><b>IMPORTANT</b><br>
    A non-default value assigned from NED cannot be overwritten later in
    NED or from ini files; it becomes &#8220;hardcoded&#8221; as far as ini files
    and NED usage are concerned. In contrast, default values are possible
    to overwrite.
</ul>

<p>A parameter can be assigned in the configuration using a similar syntax as
NED pattern assignments (actually, it would be more historically accurate
to say it the other way round, that NED pattern assignments use a similar
syntax to ini files):

<p>
<pre class="inifile">
Network.host[*].ping.sendInterval = 500ms  # for the host[100] example
Network.host*.ping.sendInterval = 500ms    # for the host0,host1,... example
**.sendInterval = 500ms
</pre>

<p>One often uses the double asterisk to save typing. You can write

<pre class="inifile">
**.ping.sendInterval = 500ms
</pre>
<p>
Or if you are sure that you don't accidentally assign some other
<tt>sendInterval</tt> parameter, you can just write

<pre class="inifile">
**.sendInterval = 500ms
</pre>
<p>
Parameter assignments in the configuration are described in section
<a href="#sec338">[9.3]</a>.

<p>One can also write expressions, including stochastic expressions, in
NED files and in ini files as well. For example, here's how you can
add jitter to the sending of ping packets:

<pre class="inifile">
**.sendInterval = 1s + normal(0s, 0.001s)  # or just: normal(1s, 0.001s)
</pre>
<p>
If there is no assignment for a parameter in NED or in the ini file, the
default value (given with <tt>=default(...)</tt> in NED) will be applied
implicitly. If there is no default value, the user will be asked, provided
the simulation program is allowed to do that; otherwise there will be an
error. (Interactive mode is typically disabled for batch executions where
it would do more harm than good.)

<p>It is also possible to explicitly apply the default (this can sometimes
be useful):

<pre class="inifile">
**.sendInterval = default
</pre>
<p>
Finally, one can explicitly ask the simulator to prompt the user interactively
for the value (again, provided that interactivity is enabled; otherwise
this will result in an error):

<pre class="inifile">
**.sendInterval = ask
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
    How do you decide whether to assign a parameter from NED or from an ini
    file? The advantage of ini files is that they allow a cleaner separation of the <i>model</i>
    and <i>experiments</i>. NED files (together with C++ code) are considered
    to be part of the model, and to be more or less constant. Ini files, on
    the other hand, are for experimenting with the model by running it
    several times with different parameters. Thus, parameters that are expected
    to change (or make sense to be changed) during experimentation should be
    put into ini files.
</ul>

<p>
<p class="subheading">Expressions</p>

<p>Parameter values may be given with expressions. NED language expressions
have a C-like syntax, with some variations on operator names: binary and
logical XOR are <tt>#</tt> and <tt>##</tt>, while <tt>^</tt> has been reassigned
to <i>power-of</i> instead. The <tt>+</tt> operator does string
concatenation as well as numeric addition. Expressions can use various
numeric, string, stochastic and other functions (<tt>fabs()</tt>, <tt>toUpper()</tt>,
<tt>uniform()</tt>, <tt>erlang_k()</tt>, etc.).

<p><ul class="note"><b>NOTE</b><br>
    The list of NED functions can be found in Appendix <a href="#sec561">[22]</a>.
    The user can also extend NED with new functions.
</ul>

<p>
Expressions may refer to module parameters, gate vector and module vector sizes
(using the <b><tt>sizeof</tt></b> operator) and the index of the current module
in a submodule vector (<b><tt>index</tt></b>).

<p>
Expressions may refer to parameters of the compound module being defined,
of the current module (with the <tt>this.</tt> prefix), and to parameters
of already defined submodules, with the syntax <tt>submodule.parametername</tt>
(or <tt>submodule[index].parametername</tt>).

<p>


<p><p class="subheading">volatile</p>

<p>The <b><tt>volatile</tt></b> modifier causes the parameter's value expression to
be evaluated every time the parameter is read. This has significance if the
expression is not constant, for example it involves numbers drawn from a
random number generator. In contrast, non-volatile parameters are evaluated
only once. (This practically means that they are evaluated and replaced
with the resulting constant at the start of the simulation.)

<p>To better understand <b><tt>volatile</tt></b>, let's suppose we have a
<tt>Queue</tt> simple module that has a <tt>volatile double</tt> parameter
named <tt>serviceTime</tt>.

<pre class="ned">
simple Queue
{
    parameters:
        volatile double serviceTime;
}
</pre>
<p>
Because of the <b><tt>volatile</tt></b> modifier, the queue module's C++
implementation is expected to re-read the <tt>serviceTime</tt> parameter
whenever a value is needed; that is, for every job serviced. Thus, if
<tt>serviceTime</tt> is assigned an expression like <tt>uniform(0.5s, 1.5s)</tt>,
every job will have a different, random service time. To highlight this
effect, here's how you can have a time-varying parameter by exploiting
the <tt>simTime()</tt> NED function that returns the current simulation time:

<pre class="inifile">
**.serviceTime = simTime()&lt;1000s ? 1s : 2s  # queue that slows down after 1000s
</pre>
<p>
In practice, a volatile parameters are typically used as a configurable
source of random numbers for modules.

<p><ul class="note"><b>NOTE</b><br>
    This does not mean that a non-volatile parameter could not be assigned a
    random value like <tt>uniform(0.5s, 1.5s)</tt>. It can, but that would
    have a totally different effect: the simulation would use a constant
    service time, say <tt>1.2975367s</tt>, chosen randomly at the beginning
    of the simulation.
</ul>

<p><p class="subheading">Units</p>

<p>One can declare a parameter to have an associated unit of measurement,
by adding the <b><tt>@unit</tt></b> property. An example:

<pre class="ned">
simple App
{
    parameters:
        volatile double sendInterval @unit(s) = default(exponential(350ms));
        volatile int packetLength @unit(byte) = default(4KiB);
    ...
}
</pre>
<p>
The <tt>@unit(s)</tt> and <tt>@unit(byte)</tt> declarations specify the measurement unit
for the parameter. Values assigned to parameters must have the same or
compatible unit, i.e. <tt>@unit(s)</tt> accepts milliseconds, nanoseconds,
minutes, hours, etc., and <tt>@unit(byte)</tt> accepts kilobytes, megabytes,
etc. as well.

<p><ul class="note"><b>NOTE</b><br>
    The list of units accepted by OMNeT++ is listed in the Appendix, see
    <a href="#sec558">[19.5.6]</a>. Unknown units (<tt>bogomips</tt>, etc.)
    can also be used, but there are no conversions for them,
    i.e. decimal prefixes will not be recognized.
</ul>

<p>The OMNeT++ runtime does a full and rigorous unit check on
parameters to ensure &#8220;unit safety&#8221; of models. Constants should
always include the measurement unit.

<p>The <b><tt>@unit</tt></b> property of a parameter cannot be added or overridden
in subclasses or in submodule declarations.

<p>
<p class="subheading">XML Parameters</p>

<p>Sometimes modules need complex data structures as input, which is something
that cannot be done well with module parameters. One solution is to place
the input data into a custom configuration file, pass the file name to the
module in a string parameter, and let the module read and parse the file.

<p>It is somewhat easier if the configuration uses XML syntax, because OMNeT++
contains built-in support for XML files. Using an XML parser (LibXML2 or
Expat), OMNeT++ reads and DTD-validates the file (if the XML document
contains a DOCTYPE), caches the file (so that references to it from several
modules will result in the file being loaded only once), allows selection
of parts of the document using an XPath-subset notation, and presents the
contents in a DOM-like object tree.

<p>This capability can be accessed via the NED parameter type <b><tt>xml</tt></b>,
and the <b><tt>xmldoc()</tt></b> function. You can point <b><tt>xml</tt></b>-type
module parameters to a specific XML file (or to an element inside an XML
file) via the <b><tt>xmldoc()</tt></b> function. You can assign <b><tt>xml</tt></b>
parameters both from NED and from <tt>omnetpp.ini</tt>.

<p>The following example declares an <b><tt>xml</tt></b> parameter, and assigns an
XML file to it. The file name is understood as being relative to the working
directory.

<pre class="ned">
simple TrafGen {
    parameters:
        xml profile;
    gates:
        output out;
}

module Node {
    submodules:
        trafGen1 : TrafGen {
            profile = xmldoc("data.xml");
        }
        ...
}
</pre>
<p>
It is also possible to assign an XML element within a file to the parameter,
which is useful if you want to group the input of several modules into
a single XML file. For example, the following XML file contains two profiles
with the IDs <i>gen1</i> and <i>gen2</i>:

<pre class="filelisting">
&lt;?xml&gt;
&lt;root&gt;
    &lt;profile id="gen1"&gt;
          &lt;param&gt;3&lt;/param&gt;
          &lt;param&gt;5&lt;/param&gt;
    &lt;/profile&gt;
    &lt;profile id="gen2"&gt;
          &lt;param&gt;9&lt;/param&gt;
    &lt;/profile&gt;
&lt;/root&gt;
</pre>
<p>
And you can assign each profile to a corresponding submodule using an XPath-like
expression:

<pre class="ned">
module Node {
    submodules:
        trafGen1 : TrafGen {
            profile = xmldoc("all.xml", "/root/profile[@id='gen1']");
        }
        trafGen2 : TrafGen {
            profile = xmldoc("all.xml", "/root/profile[@id='gen2']");
        }
}
</pre>
<p>
It is also possible to create an XML document from a string constant, using
the <b><tt>xml()</tt></b> function. This is especially useful for creating a
default value for <b><tt>xml</tt></b> parameters. An example:

<pre class="ned">
simple TrafGen {
    parameters:
        xml profile = xml("&lt;root/&gt;"); // empty document as default
        ...
}
</pre>
<p>
The <b><tt>xml()</tt></b> function, like <b><tt>xmldoc()</tt></b>, also supports an
optional second XPath parameter for selecting a subtree.

<p>

<p>
<h2><a name="sec127"/>3.7 Gates</h2>
<a name="sec:ch-ned-lang:gates"></a>

<p>Gates are the connection points of modules.  OMNeT++ has three types of
gates: <i>input</i>, <i>output</i> and <i>inout</i>, the latter being
essentially an input and an output gate glued together.

<p>A gate, whether input or output, can only be connected to one other
gate. (For compound module gates, this means one connection &#8220;outside&#8221; and
one &#8220;inside&#8221;.)  It is possible, though generally not recommended, to
connect the input and output sides of an inout gate separately (see section
<a href="#sec129">[3.9]</a>).

<p>One can create single gates and gate vectors. The size of a gate vector
can be given inside square brackets in the declaration, but it is also possible
to leave it open by just writing a pair of empty brackets (&#8220;<tt>[]</tt>&#8221;).

<p>When the gate vector size is left open, one can still specify it later,
when subclassing the module, or when using the module for a submodule in a
compound module. However, it does not need to be specified because
one can create connections with the <tt><i>gate</i>++</tt> operator that
automatically expands the gate vector.

<p>The gate size can be queried from various NED expressions with the
<tt>sizeof()</tt> operator.

<p>NED normally requires that all gates be connected. To relax this
requirement, you can annotate selected gates with the <b><tt>@loose</tt></b>
property, which turns off the connectivity check for that gate. Also, input
gates that solely exist so that the module can receive messages via
<tt>sendDirect()</tt> (see <a href="#sec170">[4.7.5]</a>) should
be annotated with <b><tt>@directIn</tt></b>. It is also possible to turn off the connectivity
check for all gates within a compound module by specifying the
<b><tt>allowunconnected</tt></b> keyword in the module's connections section.

<p>Let us see some examples.

<p>In the following example, the <tt>Classifier</tt> module has one input for
receiving jobs, which it will send to one of the outputs. The number of
outputs is determined by a module parameter:

<pre class="ned">
simple Classifier {
    parameters:
        int numCategories;
    gates:
        input in;
        output out[numCategories];
}
</pre>
<p>
The following <tt>Sink</tt> module also has its <tt>in[]</tt> gate defined
as a vector, so that it can be connected to several modules:

<pre class="ned">
simple Sink {
    gates:
        input in[];
}
</pre>
<p>
The following lines define a node for building a square grid. Gates around
the edges of the grid are expected to remain unconnected, hence the
<b><tt>@loose</tt></b> annotation:

<pre class="ned">
simple GridNode {
    gates:
        inout neighbour[4] @loose;
}
</pre>
<p>
<tt>WirelessNode</tt> below is expected to receive messages (radio transmissions)
via direct sending, so its <tt>radioIn</tt> gate is marked with <b><tt>@directIn</tt></b>.

<pre class="ned">
simple WirelessNode {
    gates:
        input radioIn @directIn;
}
</pre>
<p>
In the following example, we define <tt>TreeNode</tt> as having gates to connect
any number of children, then subclass it to get a <tt>BinaryTreeNode</tt> to
set the gate size to two:

<pre class="ned">
simple TreeNode {
    gates:
        inout parent;
        inout children[];
}

simple BinaryTreeNode extends TreeNode {
    gates:
        children[2];
}
</pre>
<p>
An example for setting the gate vector size in a submodule, using the same
<tt>TreeNode</tt> module type as above:

<pre class="ned">
module BinaryTree {
    submodules:
        nodes[31]: TreeNode {
            gates:
                children[2];
        }
    connections:
        ...
}
</pre>
<p>

<p>
<h2><a name="sec128"/>3.8 Submodules</h2>
<a name="sec:ch-ned-lang:submodules"></a>

<p>Modules that a compound module is composed of are called its submodules.
A submodule has a name, and it is an instance of a compound or simple
module type. In the NED definition of a submodule, this module type
is usually given statically, but it is also possible to specify the type
with a string expression. (The latter feature, <i>parametric submodule
types</i>, will be discussed in section <a href="#sec133">[3.11.1]</a>.)

<p>NED supports submodule arrays (vectors) and conditional submodules as well.
Submodule vector size, unlike gate vector size, must always be specified
and cannot be left open as with gates.

<p>It is possible to add new submodules to an existing compound module via
subclassing; this has been described in the section
<a href="#sec124">[3.4]</a>.

<p>The basic syntax of submodules is shown below:

<pre class="ned">
module Node
{
    submodules:
        routing: Routing;   // a submodule
        queue[sizeof(port)]: Queue;  // submodule vector
        ...
}
</pre>
<p>
As already seen in previous code examples, a submodule may also have a
curly brace block as body, where one can assign parameters, set the size of
gate vectors, and add/modify properties like the display string
(<b><tt>@display</tt></b>). It is not possible to add new parameters and gates.

<p>Display strings specified here will be merged with the display string
from the type to get the effective display string. The merge algorithm is
described in chapter <a href="#sec380">[11]</a>.

<pre class="ned">
module Node
{
    gates:
        inout port[];
    submodules:
        routing: Routing {
            parameters:   // this keyword is optional
                routingTable = "routingtable.txt"; // assign parameter
            gates:
                in[sizeof(port)];  // set gate vector size
                out[sizeof(port)];
        }
        queue[sizeof(port)]: Queue {
            @display("t=queue id $id"); // modify display string
            id = 1000+index;  // use submodule index to generate different IDs
        }
    connections:
        ...
}
</pre>
<p>
An empty body may be omitted, that is,

<pre class="ned">
      queue: Queue;
</pre>
<p>
is the same as

<pre class="ned">
      queue: Queue {
      }
</pre>
<p>
A submodule or submodule vector can be conditional. The <b><tt>if</tt></b>
keyword and the condition itself goes after the submodule type, like in the
example below:

<pre class="ned">
module Host
{
    parameters:
        bool withTCP = default(true);
    submodules:
        tcp : TCP if withTCP;
        ...
}
</pre>
<p>
The condition is less useful with submodule vectors, as one could also
use a zero vector size.

<p>
<h2><a name="sec129"/>3.9 Connections</h2>
<a name="sec:ch-ned-lang:connections"></a>

<p>Connections are defined in the <b><tt>connections</tt></b> section of compound
modules. Connections cannot span across hierarchy levels; one can connect
two submodule gates, a submodule gate and the "inside" of the parent
(compound) module's gates, or two gates of the parent module (though this
is rarely useful), but it is not possible to connect to any gate outside the
parent module, or inside compound submodules.

<p>Input and output gates are connected with a normal arrow, and inout gates
with a double-headed arrow &#8220;<tt>&lt;--&gt;</tt>&#8221;. To connect the two gates
with a channel, use two arrows and put the channel specification in between.
The same syntax is used to add properties such as <b><tt>@display</tt></b> to the
connection.

<p>Some examples have already been shown in the NED Quickstart section
(<a href="#sec117">[3.2]</a>); let's see some more.

<p>

It has been mentioned that an inout gate is basically an input and an
output gate glued together. These sub-gates can also be addressed (and
connected) individually if needed, as <tt>port$i</tt> and <tt>port$o</tt> (or
for vector gates, as <tt>port$i[$k$]</tt> and <tt>port$o[<i>k</i>]</tt>).

<p>
Gates are specified as <i>modulespec.gatespec</i> (to connect a submodule),
or as <i>gatespec</i> (to connect the compound module). <i>modulespec</i>
is either a submodule name (for scalar submodules), or a submodule name plus
an index in square brackets (for submodule vectors). For scalar gates,
<i>gatespec</i> is the gate name; for gate vectors it is either the gate name
plus an index in square brackets, or <i>gatename</i><tt>++</tt>.

<p>The <i>gatename</i><tt>++</tt> notation causes the first unconnected gate index
to be used. If all gates of the given gate vector are connected, the behavior
is different for submodules and for the enclosing compound module.
For submodules, the gate vector expands by one. For a compound module,
after the last gate is connected, <tt>++</tt> will stop with an error.

<p><ul class="note"><b>NOTE</b><br>
    Why is it not possible to expand a gate vector of the compound
    module? The model structure is built in top-down order, so new gates
    would be left unconnected on the outside, as there is no way in NED to
    "go back" and connect them afterwards.
</ul>

<p>When the <tt>++</tt> operator is used with <tt>$i</tt> or <tt>$o</tt>
(e.g. <tt>g$i++</tt> or <tt>g$o++</tt>, see later), it will actually add
a gate pair (input+output) to maintain equal gate sizes for the two
directions.

<p>

<p><p class="subheading">Channel Specification</p>

<p>Channel specifications (<tt>--&gt;<i>channelspec</i>--&gt;</tt> inside a connection)
are similar to submodules in many respect. Let's see some examples!

<p>The following connections use two user-defined channel types,
<tt>Ethernet100</tt> and <tt>Backbone</tt>. The code shows the syntax
for assigning parameters (<tt>cost</tt> and <tt>length</tt>) and specifying
a display string (and NED properties in general):

<pre class="ned">
a.g++ &lt;--&gt; Ethernet100 &lt;--&gt; b.g++;
a.g++ &lt;--&gt; Backbone {cost=100; length=52km; ber=1e-8;} &lt;--&gt; b.g++;
a.g++ &lt;--&gt; Backbone {@display("ls=green,2");} &lt;--&gt; b.g++;
</pre>
<p>
When using built-in channel types, the type name can be omitted; it
will be inferred from the parameters you assign.

<pre class="ned">
a.g++ &lt;--&gt; {delay=10ms;} &lt;--&gt; b.g++;
a.g++ &lt;--&gt; {delay=10ms; ber=1e-8;} &lt;--&gt; b.g++;
a.g++ &lt;--&gt; {@display("ls=red");} &lt;--&gt; b.g++;
</pre>
<p>
If <tt>datarate</tt>, <tt>ber</tt> or <tt>per</tt> is assigned,
<tt>ned.DatarateChannel</tt> will be chosen. Otherwise, if <tt>delay</tt> or
<tt>disabled</tt> is present, it will be <tt>ned.DelayChannel</tt>; otherwise it
is <tt>ned.IdealChannel</tt>. Naturally, if other parameter names are assigned
in a connection without an explicit channel type, it will be an error (with
<i>&#8220;ned.DelayChannel has no such parameter&#8221;</i> or similar message).

<p>Connection parameters, similarly to submodule parameters, can also
be assigned using pattern assignments, albeit the channel names
to be matched with patterns are a little more complicated and less
convenient to use. A channel can be identified with the name of its
source gate plus the channel name; the channel name is currently always
<tt>channel</tt>. It is illustrated by the following example:

<pre class="ned">
module Queueing
{
    parameters:
        source.out.channel.delay = 10ms;
        queue.out.channel.delay = 20ms;
    submodules:
        source: Source;
        queue: Queue;
        sink: Sink;
    connections:
        source.out --&gt; ned.DelayChannel --&gt; queue.in;
        queue.out --&gt; ned.DelayChannel &lt;--&gt; sink.in;
</pre>
<p>
Using bidirectional connections is a bit trickier, because both
directions must be covered separately:

<pre class="ned">
network Network
{
    parameters:
        hostA.g$o[0].channel.datarate = 100Mbps; // the A -&gt; B connection
        hostB.g$o[0].channel.datarate = 100Mbps; // the B -&gt; A connection
        hostA.g$o[1].channel.datarate = 1Gbps;   // the A -&gt; C connection
        hostC.g$o[0].channel.datarate = 1Gbps;   // the C -&gt; A connection
    submodules:
        hostA: Host;
        hostB: Host;
        hostC: Host;
    connections:
        hostA.g++ &lt;--&gt; ned.DatarateChannel &lt;--&gt; hostB.g++;
        hostA.g++ &lt;--&gt; ned.DatarateChannel &lt;--&gt; hostC.g++;
</pre>
<p>
Also, it is not always easy to figure out which gate indices map to the
connections you want to configure. If connection objects could be given
names to override the default name &#8220;<tt>channel</tt>&#8221;, that would make it
easier to identify connections in patterns. This feature is planned for
future OMNeT++ releases.

<p>
<p class="subheading">Channel Names</p>

<p>The default name given to channel objects is <tt>"channel"</tt>. Since OMNeT++ 4.3
it is possible to specify the name explicitly, and also to override
the default name per channel type. The purpose of custom channel names is to make
addressing easier when channel parameters are assigned from ini files.

<p>The syntax for naming a channel in a connection is similar to submodule syntax:
<i>name: type</i>. Since both <i>name</i> and <i>type</i> are optional,
the colon must be there after <i>name</i> even if <i>type</i> is missing,
in order to remove the ambiguity.

<p>Examples:

<pre class="ned">
r1.pppg++ &lt;--&gt; eth1: EthernetChannel &lt;--&gt; r2.pppg++;
a.out --&gt; foo: {delay=1ms;} --&gt; b.in;
a.out --&gt; bar: --&gt; b.in;
</pre>
<p>
In the absence of an explicit name, the channel name comes from the
<tt>@defaultname</tt> property of the channel type if that exists.

<pre class="ned">
channel Eth10G extends ned.DatarateChannel like IEth {
    @defaultname(eth10G);
}
</pre>
<p>
There's a catch with <tt>@defaultname</tt> though: if the channel type is
specified with a <tt>**.<i>channelname</i>.liketype=</tt> line in an ini file, then
the channel type's <tt>@defaultname</tt> cannot be used as <i>channelname</i>
in that configuration line, because the channel type would only be known as a
result of using that very configuration line. To illustrate the problem,
consider the above <tt>Eth10G</tt> channel, and a compound module containing the
following connection:

<pre class="ned">
r1.pppg++ &lt;--&gt; &lt;&gt; like IEth &lt;--&gt; r2.pppg++;
</pre>
<p>
Then consider the following inifile:

<pre class="inifile">
**.eth10G.typename = "Eth10G"   # Won't match! The eth10G name would come from
                                #   the Eth10G type - catch-22!
**.channel.typename = "Eth10G"  # OK, as lookup assumes the name "channel"
**.eth10G.datarate = 10.01Gbps  # OK, channel already exists with name "eth10G"
</pre>
<p>
The anomaly can be avoided by using an explicit channel name in the connection,
not using <tt>@defaultname</tt>, or by specifying the type via a module parameter
(e.g. writing <tt>&lt;param&gt; like ...</tt> instead of <tt>&lt;&gt; like ...</tt>).

<p>

<p><h2><a name="sec130"/>3.10 Multiple Connections</h2>
<a name="sec:ch-ned-lang:multiple-connections"></a>

<p>Simple programming constructs (loop, conditional) allow creating
multiple connections easily.

<p>
This will be shown in the following examples.

<p><p class="subheading">Chain</p>

<p>One can create a chain<!--chain--> of modules like this:

<pre class="ned">
module Chain
    parameters:
        int count;
    submodules:
        node[count] : Node {
            gates:
                port[2];
        }
    connections allowunconnected:
        for i = 0..count-2 {
            node[i].port[1] &lt;--&gt; node[i+1].port[0];
        }
}
</pre>
<p>

<p><p class="subheading">Binary Tree</p>

<p>One can build a binary tree<!--binary tree--> in the following way:

<pre class="ned">
simple BinaryTreeNode {
    gates:
        inout left;
        inout right;
        inout parent;
}

module BinaryTree {
    parameters:
        int height;
    submodules:
        node[2^height-1]: BinaryTreeNode;
    connections allowunconnected:
        for i=0..2^(height-1)-2 {
            node[i].left &lt;--&gt; node[2*i+1].parent;
            node[i].right &lt;--&gt; node[2*i+2].parent;
        }
}
</pre>
<p>
Note that not every gate of the modules will be connected. By default,
an unconnected gate produces a run-time error message when the
simulation is started, but this error message is turned off here with
the <b><tt>allowunconnected</tt></b> modifier.
Consequently, it is the simple modules' responsibility not to send
on an unconnected gate.

<p>

<p><p class="subheading">Random Graph</p>

<p>Conditional connections can be used to generate random
topologies<!--topology!random-->, for example. The following code
generates a random subgraph of a full graph:

<pre class="ned">
module RandomGraph {
    parameters:
        int count;
        double connectedness; // 0.0&lt;x&lt;1.0
    submodules:
        node[count]: Node {
            gates:
                in[count];
                out[count];
        }
    connections allowunconnected:
        for i=0..count-1, for j=0..count-1 {
            node[i].out[j] --&gt; node[j].in[i]
                if i!=j && uniform(0,1)&lt;connectedness;
        }
}
</pre>
<p>
Note the use of the <b><tt>allowunconnected</tt></b> modifier
here too, to turn off error messages produced by the network setup code
for unconnected gates.

<p>
<h3><a name="sec131"/>3.10.1 Connection Patterns</h3>

<p><!--module!compound!patterns-->
<!--topology!patterns-->

<p>Several approaches can be used when you want to create complex
topologies which have a regular structure; three of them are
described below.

<p>
<p class="subheading">&#8220;Subgraph of a Full Graph&#8221;</p>

<p>
This pattern takes a subset of the connections of a full graph.  A
condition is used to &#8220;carve out&#8221; the necessary interconnection from
the full graph:

<pre class="ned">
for i=0..N-1, for j=0..N-1 {
    node[i].out[...] --&gt; node[j].in[...] if condition(i,j);
}
</pre>
<p>
The RandomGraph compound module (presented earlier) is an example of
this pattern, but the pattern can generate any graph where an
appropriate <i>condition(i,j)</i> can be formulated. For example,
when generating a tree<!--topology!tree--> structure, the condition
would return whether node <i>j</i> is a child of node <i>i</i> or
vice versa.

<p>Though this pattern is very general, its usage can be prohibitive if
the number of nodes <i>N</i> is high and the graph is sparse (it has
much less than <i>N<sup>2</sup></i> connections). The following
two patterns do not suffer from this drawback.

<p>
<p class="subheading">&#8220;Connections of Each Node&#8221;</p>

<p>The pattern loops through all nodes and creates the necessary
connections for each one. It can be generalized like this:

<pre class="ned">
for i=0..Nnodes, for j=0..Nconns(i)-1 {
    node[i].out[j] --&gt; node[rightNodeIndex(i,j)].in[j];
}
</pre>
<p>
The Hypercube<!--topology!hypercube--> compound module (to be
presented later) is a clear example of this approach. BinaryTree can
also be regarded as an example of this pattern where the inner j loop
is unrolled.

<p>The applicability of this pattern depends on how easily the <i>rightNodeIndex(i,j)</i>
function can be formulated.

<p>
<p class="subheading">&#8220;Enumerate All Connections&#8221;</p>

<p>
A third pattern is to list all connections within a loop:

<pre class="ned">
for i=0..Nconnections-1 {
    node[leftNodeIndex(i)].out[...] --&gt; node[rightNodeIndex(i)].in[...];
}
</pre>
<p>
This pattern can be used if <i>leftNodeIndex(i)</i> and <i>rightNodeIndex(i)</i>
mapping functions can be sufficiently formulated.

<p>The <tt>Chain</tt> module is an example of this approach where the mapping
functions are extremely simple: <i>leftNodeIndex(i)=i</i> and <i>rightNodeIndex(i) = i+1</i>.
The pattern can also be used to create a random subset of a full
graph with a fixed number of connections.

<p>In the case of irregular structures where none of the above patterns
can be employed, you can resort to listing all connections, like you
would do it in most existing simulators.

<p>

<p><h2><a name="sec132"/>3.11 Parametric Submodule and Connection Types</h2>

<p><h3><a name="sec133"/>3.11.1 Parametric Submodule Types</h3>
<a name="sec:ch-ned-lang:submodule-like"></a>

<p>A submodule type may be specified with a module parameter of the type
<b><tt>string</tt></b>, or in general, with any string-typed expression.
The syntax uses the <b><tt>like</tt></b> keyword.

<p>Let us begin with an example:

<pre class="ned">
network Net6
{
    parameters:
        string nodeType;
    submodules:
        node[6]: &lt;nodeType&gt; like INode {
            address = index;
        }
    connections:
        ...
}
</pre>
<p>
It creates a submodule vector whose module type will come from the
<tt>nodeType</tt> parameter. For example, if <tt>nodeType</tt> is set to <tt>"SensorNode"</tt>,
then the module vector will consist of sensor nodes, provided such module
type exists and it qualifies. What this means is that the <tt>INode</tt> must be
an existing <i>module interface</i>, which the <tt>SensorNode</tt>
module type must implement (more about this later).

<p>As already mentioned, one can write an expression between the angle
brackets. The expression may use the parameters of the parent module and of
previously defined submodules, and has to yield a string value. For
example, the following code is also valid:

<pre class="ned">
network Net6
{
    parameters:
        string nodeTypePrefix;
        int variant;
    submodules:
        node[6]: &lt;nodeTypePrefix + "Node" + string(variant)&gt; like INode {
           ...
}
</pre>
<p>
The corresponding NED declarations:

<pre class="ned">
moduleinterface INode
{
    parameters:
        int address;
    gates:
        inout port[];
}

module SensorNode like INode
{
    parameters:
        int address;
        ...
    gates:
        inout port[];
        ...
}
</pre>
<p>
The &#8220;<tt>&lt;nodeType&gt; like INode</tt>&#8221; syntax has an issue when used
with submodule vectors: does not allow you to specify different types
for different indices. The following syntax is better suited for
submodule vectors:

<p>The expression between the angle brackets may be left out altogether,
leaving you with a pair of empty angle brackets, <tt>&lt;&gt;</tt>:

<pre class="ned">
module Node
{
    submodules:
        nic: &lt;&gt; like INic;  // type name expression left unspecified
        ...
}
</pre>
<p>
Now the submodule type name is expected to be defined via typename pattern
assignments. Typename pattern assignments look like pattern assignments for
the submodule's parameters, only the parameter name is replaced by the
<b><tt>typename</tt></b> keyword. Typename pattern assignments may also be
written in the configuration file. In a network that uses the above
<tt>Node</tt> NED type, typename pattern assignments would look like this:

<pre class="ned">
network Network
{
    parameters:
        node[*].nic.typename = "Ieee80211g";
    submodules:
        node: Node[100];
}
</pre>
<p>
A default value may also be specified between the angle brackets;
it will be used if there is no typename assignment for the
module:

<pre class="ned">
module Node
{
    submodules:
        nic: &lt;default("Ieee80211b")&gt; like INic;
        ...
}
</pre>
<p>

<p><h3><a name="sec134"/>3.11.2 Parametric Connection Types</h3>
<a name="sec:ch-ned-lang:connection-like"></a>

<p>Parametric connection types work similarly to parametric submodule types,
and the syntax is similar as well. A basic example that uses a parameter of
the parent module:

<pre class="ned">
a.g++ &lt;--&gt; &lt;channelType&gt; like IMyChannel &lt;--&gt; b.g++;
a.g++ &lt;--&gt; &lt;channelType&gt; like IMyChannel {@display("ls=red");} &lt;--&gt; b.g++;
</pre>
<p>
The expression may use loop variables, parameters of the parent module
and also parameters of submodules (e.g. <tt>host[2].channelType</tt>).

<p>The type expression may also be absent, and then the type is expected to be
specified using typename pattern assignments:

<pre class="ned">
a.g++ &lt;--&gt; &lt;&gt; like IMyChannel &lt;--&gt; b.g++;
a.g++ &lt;--&gt; &lt;&gt; like IMyChannel {@display("ls=red");} &lt;--&gt; b.g++;
</pre>
<p>
A default value may also be given:

<pre class="ned">
a.g++ &lt;--&gt; &lt;default("Ethernet100")&gt; like IMyChannel &lt;--&gt; b.g++;
a.g++ &lt;--&gt; &lt;default(channelType)&gt; like IMyChannel &lt;--&gt; b.g++;
</pre>
<p>
The corresponding type pattern assignments:

<pre class="ned">
a.g$o[0].channel.typename = "Ethernet1000";  // A -&gt; B channel
b.g$o[0].channel.typename = "Ethernet1000";  // B -&gt; A channel
</pre>
<p>

<p><h2><a name="sec135"/>3.12 Metadata Annotations (Properties)</h2>
<a name="sec:ch-ned-lang:properties"></a>

<p>NED properties are metadata annotations that can be added to modules, parameters,
gates, connections, NED files, packages, and virtually anything in NED.
<tt>@display</tt>, <tt>@class</tt>, <tt>@namespace</tt>, <tt>@unit</tt>, <tt>@prompt</tt>,
<tt>@loose</tt>, <tt>@directIn</tt> are all properties that have been mentioned in
previous sections, but those examples only scratch the surface of what
properties are used for.

<p>
Using properties, one can attach extra information to NED elements. Some
properties are interpreted by NED, by the simulation kernel; other
properties may be read and used from within the simulation model, or
provide hints for NED editing tools.

<p>Properties are attached to the type, so you cannot have different properties defined
per-instance. All instances of modules, connections,
parameters, etc. created from any particular location in the NED files have
identical properties.

<p>The following example shows the syntax for annotating various NED elements:

<pre class="ned">
@namespace(foo);  // file property

module Example
{
    parameters:
       @node;   // module property
       @display("i=device/pc");   // module property
       int a @unit(s) = default(1); // parameter property
    gates:
       output out @loose @labels(pk);  // gate properties
    submodules:
       src: Source {
           parameters:
              @display("p=150,100");  // submodule property
              count @prompt("Enter count:"); // adding a property to a parameter
           gates:
              out[] @loose;  // adding a property to a gate
       }
       ...
    connections:
       src.out++ --&gt; { @display("ls=green,2"); } --&gt; sink1.in; // connection prop.
       src.out++ --&gt; Channel { @display("ls=green,2"); } --&gt; sink2.in;
}
</pre>
<p>

<p><p class="subheading">Property Indices</p>

<p>Sometimes it is useful to have multiple properties with the same name,
for example for declaring multiple statistics produced by a simple module.
<i>Property indices</i> make this possible.

<p>A property index is an identifier or a number in square brackets after the
property name, such as <tt>eed</tt> and <tt>jitter</tt> in the following example:

<pre class="ned">
simple App {
    @statistic[eed](title="end-to-end delay of received packets";unit=s);
    @statistic[jitter](title="jitter of received packets");
}
</pre>
<p>
This example declares two statistics as <tt>@statistic</tt> properties,
<tt>@statistic[eed]</tt> and <tt>@statistic[jitter]</tt>. Property values within
the parentheses are used to supply additional info, like a more
descriptive name (<tt>title="..."</tt> or a unit (<tt>unit=s</tt>).
Property indices can be conveniently accessed from the C++ API as
well; for example it is possible to ask what indices exist for the
<tt>"statistic"</tt> property, and it will return a list containing
<tt>"eed"</tt> and <tt>"jitter"</tt>).

<p>In the <tt>@statistic</tt> example the index was textual and meaningful,
but neither is actually required. The following dummy example
shows the use of numeric indices which may be ignored altogether
by the code that interprets the properties:

<pre class="ned">
simple Dummy {
    @foo[1](what="apples";amount=2);
    @foo[2](what="oranges";amount=5);
}
</pre>
<p>
Note that without the index, the lines would actually define the
same <tt>@foo</tt> property, and would overwrite each other's values.

<p>Indices also make it possible to override entries via inheritance:

<pre class="ned">
simple DummyExt extends Dummy {
    @foo[2](what="grapefruits"); // 5 grapefruits instead of 5 oranges
}
</pre>
<p>

<p><p class="subheading">Data Model</p>

<p>Properties may contain data, given in parentheses; the data model is quite
flexible. To begin with, properties may contain no value or a single
value:

<pre class="ned">
@node;
@node(); // same as @node
@class(FtpApp2);
</pre>
<p>
Properties may contain lists:

<pre class="ned">
@foo(Sneezy,Sleepy,Dopey,Doc,Happy,Bashful,Grumpy);
</pre>
<p>
They may contain key-value pairs, separated by semicolons:

<pre class="ned">
@foo(x=10.31; y=30.2; unit=km);
</pre>
<p>
In key-value pairs, each value can be a (comma-separated) list:

<pre class="ned">
@foo(coords=47.549,19.034;labels=vehicle,router,critical);
</pre>
<p>
The above examples are special cases of the general data model. According
to the data model, properties contain <i>key-valuelist</i> pairs,
separated by semicolons. Items in <i>valuelist</i> are separated by
commas. Wherever <i>key</i> is missing, values go on the valuelist of the
<i>default key</i>, the empty string.

<p>Value items may contain words, numbers, string constants and some other
characters, but not arbitrary strings.
Whenever the syntax does not permit some value, it should be enclosed in
quotes. This quoting does not affect the value because
the parser automatically drops one layer of quotes; thus, <tt>@class(TCP)</tt>
and <tt>@class("TCP")</tt> are exactly the same. If you want the quotes
to be part of the value, use escaped quotes:
<tt>@foo("\"some string\"")</tt>.

<p>There are also some conventions. One can use properties to tag NED
elements; for example, a <b><tt>@host</tt></b> property could be used to mark all
module types that represent various hosts. This property could be
recognized e.g. by editing tools, by topology discovery code inside the
simulation model, etc.

<p>The convention for such a &#8220;marker&#8221; property is that any extra data in it
(i.e. within parens) is ignored, except a single word <tt>false</tt>, which has
the special meaning of &#8220;turning off&#8221; the property. Thus, any simulation model
or tool that interprets properties should handle all the following forms as
equivalent to <tt>@host</tt>: <tt>@host()</tt>, <tt>@host(true)</tt>,
<tt>@host(anything-but-false)</tt>, <tt>@host(a=1;b=2)</tt>; and
<tt>@host(false)</tt> should be interpreted as the lack of the <tt>@host</tt>
tag.

<p>
<p class="subheading">Overriding and Extending Property Values</p>

<p>When you subclass a NED type, use a module type as submodule or use a channel
type for a connection, you may add new properties to the module or channel,
or to its parameters and gates, and you can also modify existing properties.

<p>When modifying a property, the new property is merged with the old one,
with a few simple rules. New keys simply get added. If a key already
exists in the old property, items in its valuelist overwrite items on
the same position in the old property. A single hyphen ($-$) as
valuelist item serves as &#8220;antivalue&#8221;, it removes the item at the
corresponding position.

<p>Some examples:

<p><table>
<TR> <TD align=left> <i>base</i>   </TD> <TD align=left> <tt>@prop</tt>  </TD></TR>
<TR> <TD align=left> <i>new</i>    </TD> <TD align=left> <tt>@prop(a)</tt>  </TD></TR>
<TR> <TD align=left>
<i>result</i> </TD> <TD align=left> <tt>@prop(a)</tt>
</table>

<p><table>
<TR> <TD align=left> <i>base</i>   </TD> <TD align=left> <tt>@prop(a,b,c)</tt>  </TD></TR>
<TR> <TD align=left> <i>new</i>    </TD> <TD align=left> <tt>@prop(,-)</tt>  </TD></TR>
<TR> <TD align=left>
<i>result</i> </TD> <TD align=left> <tt>@prop(a,,c)</tt>
</table>

<p><table>
<TR> <TD align=left> <i>base</i>   </TD> <TD align=left> <tt>@prop(foo=a,b)</tt>  </TD></TR>
<TR> <TD align=left> <i>new</i>    </TD> <TD align=left> <tt>@prop(foo=A,,c;bar=1,2)</tt>  </TD></TR>
<TR> <TD align=left>
<i>result</i> </TD> <TD align=left> <tt>@prop(foo=A,b,c;bar=1,2)</tt>
</table>

<p><ul class="note"><b>NOTE</b><br>
    The above merge rules are part of NED, but the code that interprets
    properties may have special rules for certain properties. For example,
    the <tt>@unit</tt> property of parameters is not allowed to be overridden,
    and <tt>@display</tt> is merged with special although similar rules
    (see Chapter <a href="#sec380">[11]</a>).
</ul>

<p>

<p>
<h2><a name="sec136"/>3.13 Inheritance</h2>
<a name="sec:ch-ned-lang:inheritance"></a>

<p>Inheritance support in the NED language is only described briefly here,
because several details and examples have been already presented in
previous sections.

<p>In NED, a type may only extend (<b><tt>extends</tt></b> keyword) an element of
the same component type: a simple module may only extend a simple module,
compound module may only extend a compound module, and so on. Single
inheritance is supported for modules and channels, and multiple inheritance
is supported for module interfaces and channel interfaces. A network is a
shorthand for a compound module with the <b><tt>@isNetwork</tt></b> property set, so
the same rules apply to it as to compound modules.

<p>However, a simple or compound module type may implement (<b><tt>like</tt></b>
keyword) several module interfaces; likewise, a channel type may implement
several channel interfaces.

<p><ul class="important"><b>IMPORTANT</b><br>
    When you extend a simple module type both in NED and in C++, you must
    use the <b><tt>@class</tt></b> property to tell NED to use the new C++ class --
    otherwise your new module type inherits the C++ class of the base!
</ul>

<p>Inheritance may:
<ul>
    <li> add new properties, parameters, gates, inner types, submodules,
          connections, as long as names do not conflict with inherited names
    <li> modify inherited properties, and properties of inherited parameters and
          gates
    <li> it may not modify inherited submodules, connections and inner types
</ul>

<p>For details and examples, see the corresponding sections of this chapter
(simple modules <a href="#sec123">[3.3]</a>,
compound modules <a href="#sec124">[3.4]</a>,
channels <a href="#sec125">[3.5]</a>,
parameters <a href="#sec126">[3.6]</a>,
gates <a href="#sec127">[3.7]</a>,
submodules <a href="#sec128">[3.8]</a>,
connections <a href="#sec129">[3.9]</a>,
module interfaces and channel interfaces <a href="#sec133">[3.11.1]</a>).

<p>

<p><h2><a name="sec137"/>3.14 Packages</h2>
<a name="sec:ch-ned-lang:packages"></a>

<p>Having all NED files in a single directory is fine for small simulation projects.
When a project grows, however, it sooner or later becomes
necessary to introduce a directory structure, and sort the NED files into
them. NED natively supports directory trees with NED files, and calls
directories <i>packages</i>. Packages are also useful for reducing
name conflicts, because names can be qualified with the package name.

<p><ul class="note"><b>NOTE</b><br>
    NED packages are based on the Java package concept, with minor
    enhancements. If you are familiar with Java, you'll find little
    surprise in this section.
</ul>

<p><p class="subheading">Overview</p>

<p>When a simulation is run, you must tell the simulation kernel the
directory which is the root of your package tree; let's call it
<i>NED source folder</i>. The simulation kernel will traverse
the whole directory tree, and load all NED files from every directory.
You can have several NED directory trees, and their roots (the NED source
folders) should be given to the simulation kernel in the NEDPATH
variable. NEDPATH can be specified in several ways: as an environment
variable (<tt>NEDPATH</tt>), as a configuration option (<b><tt>ned-path</tt></b>),
or as a command-line option to the simulation runtime (<tt>-n</tt>). NEDPATH is
described in detail in chapter <a href="#sec355">[10]</a>.

<p>Directories in a NED source tree correspond to packages. If you have
NED files in a <tt>&lt;root&gt;/a/b/c</tt> directory (where <tt>&lt;root&gt;</tt>
gets listed in NEDPATH), then the package name is <tt>a.b.c</tt>.
The package name has to be explicitly declared at the top of the NED
files as well, like this:

<pre class="ned">
package a.b.c;
</pre>
<p>
The package name that follows from the directory name and the declared
package must match; it is an error if they don't. (The only exception
is the root <tt>package.ned</tt> file, as described below.)

<p>By convention, package names are all lowercase, and begin with either
the project name (<tt>myproject</tt>), or the reversed domain name plus the
project name (<tt>org.example.myproject</tt>). The latter convention
would cause the directory tree to begin with a few levels of empty
directories, but this can be eliminated with a toplevel <tt>package.ned</tt>.

<p>NED files called <tt>package.ned</tt> have a special role, as they are meant
to represent the whole package. For example, comments in
<tt>package.ned</tt> are treated as documentation of the package. Also, a
<b><tt>@namespace</tt></b> property in a <tt>package.ned</tt> file affects all NED
files in that directory and all directories below.

<p>The toplevel <tt>package.ned</tt> file can be used to designate the root
package, which is useful for eliminating a few levels of empty directories
resulting from the package naming convention. For example, if you have a
project where you want to have all NED types under the <tt>org.example.myproject</tt>
package but don't want to have the directories named <tt>org</tt>, <tt>example</tt> and
<tt>myproject</tt> in the source tree, then you can put a <tt>package.ned</tt>
file in the source root directory with the package declaration
<tt>org.example.myproject</tt>. This will cause a directory <tt>foo</tt> under the
root to be interpreted as package <tt>org.example.myproject.foo</tt>, and NED
files in them must contain that as package declaration. Only the root
<tt>package.ned</tt> can define the package, <tt>package.ned</tt> files
in subdirectories must follow it.

<p>Let's look at the INET Framework as example, which contains hundreds of NED
files in several dozen packages. The directory structure looks like this:

<p><pre class="verbatim">
INET/
    src/
        base/
        transport/
            tcp/
            udp/
            ...
        networklayer/
        linklayer/
        ...
    examples/
        adhoc/
        ethernet/
        ...
</pre>

<p>The <tt>src</tt> and <tt>examples</tt> subdirectories are denoted as NED source
folders, so NEDPATH is the following (provided INET was unpacked in
<tt>/home/joe</tt>):

<pre class="filelisting">
/home/joe/INET/src;/home/joe/INET/examples
</pre>
<p>
Both <tt>src</tt> and <tt>examples</tt> contain <tt>package.ned</tt> files to
define the root package:

<pre class="ned">
// INET/src/package.ned:
package inet;
</pre>
<p>
<pre class="ned">
// INET/examples/package.ned:
package inet.examples;
</pre>

<p>And other NED files follow the package defined in <tt>package.ned</tt>:

<pre class="ned">
// INET/src/transport/tcp/TCP.ned:
package inet.transport.tcp;
</pre>
<p>

<p><p class="subheading">Name Resolution, Imports</p>

<p>We already mentioned that packages can be used to distinguish
similarly named NED types. The name that includes the package name
(<tt>a.b.c.Queue</tt> for a <tt>Queue</tt> module in the <tt>a.b.c</tt>
package) is called <i>fully qualified name</i>; without the package
name (<tt>Queue</tt>) it is called <i>simple name</i>.

<p>Simple names alone are not enough to unambiguously identify a type.
Here is how you can refer to an existing type:

<p><ol>
  <li> By fully qualified name. This is often cumbersome though,
        as names tend to be too long;
  <li> Import the type, then the simple name will be enough;
  <li> If the type is in the same package, then it doesn't need to be
        imported; it can be referred to by simple name
</ol>

<p>Types can be imported with the <b><tt>import</tt></b> keyword by either
fully qualified name, or by a wildcard pattern. In wildcard patterns,
one asterisk ("<tt>*</tt>") stands for "any character sequence not containing
period", and two asterisks ("<tt>**</tt>") mean "any character sequence which may
contain period".

<p>So, any of the following lines can be used to import a type called
<tt>inet.protocols.networklayer.ip.RoutingTable</tt>:

<pre class="ned">
import inet.protocols.networklayer.ip.RoutingTable;
import inet.protocols.networklayer.ip.*;
import inet.protocols.networklayer.ip.Ro*Ta*;
import inet.protocols.*.ip.*;
import inet.**.RoutingTable;
</pre>
<p>
If an import explicitly names a type with its exact fully qualified name,
then that type must exist, otherwise it is an error. Imports containing
wildcards are more permissive, it is allowed for them not to match any
existing NED type (although that might generate a warning.)

<p>Inner types may not be referred to outside their enclosing types, so they
cannot be imported either.

<p>
<p class="subheading">Name Resolution With "like"</p>

<p>The situation is a little different for submodule and connection channel
specifications using the <b><tt>like</tt></b> keyword, when the type name comes
from a string-valued expression (see section
<a href="#sec133">[3.11.1]</a> about submodule and channel types as
parameters). Imports are not much use here: at the time of writing the NED
file it is not yet known what NED types will be suitable for being "plugged
in" there, so they cannot be imported in advance.

<p>There is no problem with fully qualified names, but simple names need
to be resolved differently. What NED does is this: it determines which
interface the module or channel type must implement (i.e. <tt>... like INode</tt>),
and then collects the types that have the given simple name AND implement
the given interface. There must be exactly one such type, which is then used.
If there is none or there are more than one, it will be reported as an error.

<p>Let us see the following example:

<pre class="ned">
module MobileHost
{
    parameters:
        string mobilityType;
    submodules:
        mobility: &lt;mobilityType&gt; like IMobility;
        ...
}
</pre>
<p>
and suppose that the following modules implement the <tt>IMobility</tt> module
interface: <tt>inet.mobility.RandomWalk</tt>, <tt>inet.adhoc.RandomWalk</tt>,
<tt>inet.mobility.MassMobility</tt>. Also suppose that there is a type
called <tt>inet.examples.adhoc.MassMobility</tt> but it does not implement the
interface.

<p>So if <tt>mobilityType="MassMobility"</tt>, then
<tt>inet.mobility.MassMobility</tt> will be selected; the other
<tt>MassMobility</tt> doesn't interfere. However, if
<tt>mobilityType="RandomWalk"</tt>, then it is an error because there are two
matching <tt>RandomWalk</tt> types. Both <tt>RandomWalk</tt>'s can still be used,
but one must explicitly choose one of them by providing a package name:
<tt>mobilityType="inet.adhoc.RandomWalk"</tt>.

<p>
<p class="subheading">The Default Package</p>

<p>It is not mandatory to make use of packages: if all NED files are in a
single directory listed on the NEDPATH, then package declarations (and
imports) can be omitted. Those files are said to be in the <i>default
package</i>.

<p>



<p>
<hr class='pgbr'><h1><a name="sec138"/>4 Simple Modules</h1>
<a name="cha:simple-modules"></a>
<!--module!simple-->

<p>
<i>Simple modules</i> are the active components in the model.
Simple modules are programmed in C++, using the OMNeT++ class
library. The following sections contain a short introduction
to discrete event simulation in general, explain how its concepts are
implemented in OMNeT++, and give an overview and practical advice
on how to design and code simple modules.

<p>

<p><h2><a name="sec139"/>4.1 Simulation Concepts</h2>
<a name="sec:simple-modules:simulation-concepts"></a>

<p>This section contains a very brief introduction into how discrete
event simulation (DES) works, in order to introduce terms we'll use
when explaining OMNeT++ concepts<!--simulation!concepts--> and
implementation.

<p>
<h3><a name="sec140"/>4.1.1 Discrete Event Simulation</h3>
<a name="sec:simple-modules:discrete-event-simulation"></a>

<p>A <i>discrete event system</i> is a system where state changes
(events<!--events-->) happen at discrete instances in time, and events take zero time
to happen. It is assumed that nothing (i.e. nothing interesting)
happens between two consecutive events, that is, no state change takes
place in the system between the events. This is in contrast to
<i>continuous</i> systems where state changes are continuous.
Systems that can be viewed as discrete event systems can be modeled
using discrete event simulation<!--discrete event simulation-->, DES.

<p>For example, computer networks are usually viewed as discrete
event systems. Some of the events are:

<p><ul>
  <li>start of a packet transmission
  <li>end of a packet transmission
  <li>expiry of a retransmission timeout
</ul>

<p>This implies that between two events such as <i>start of a packet
transmission</i> and <i>end of a packet transmission</i>, nothing
interesting happens. That is, the packet's state remains <i>being
transmitted</i>. Note that the definition of &#8220;interesting&#8221; events and states always
depends on the intent and purposes of the modeler.
If we were interested in the transmission of individual bits, we would
have included something like <i>start of bit transmission</i> and
<i>end of bit transmission</i> among our events.

<p>
The time when events occur is often called <i>event timestamp</i>;
<!--event timestamp--> with OMNeT++ we use the term
<i>arrival time</i><!--arrival time--> (because in the class
library, the word &#8220;timestamp&#8221; is reserved for a user-settable
attribute in the event class). Time within the model is often called
<i>simulation time</i><!--simulation time-->, <i>model time</i>
<!--model!time--> or <i>virtual time</i><!--virtual time-->
as opposed to real time<!--real time--> or CPU time<!--CPU time-->
which refer to how long the simulation program has been running and
how much CPU time it has consumed.

<p>

<p><h3><a name="sec141"/>4.1.2 The Event Loop</h3>
<a name="sec:simple-modules:event-loop"></a>

<p>Discrete event simulation maintains the set of future
events<!--future events--> in a data structure often called
FES<!--FES--> (Future Event Set) or FEL<!--FEL--> (Future Event List).
Such simulators usually work according to the following pseudocode:

<p><pre class="verbatim">
<i>initialize -- this includes building the model and</i>
              <i>inserting initial events to FES</i>

<i>while (FES not empty and simulation not yet complete)</i>
<i>{</i>
    <i>retrieve first event from FES</i>
    <i>t:= timestamp of this event</i>
    <b><i>process event</i></b>
    <i>(processing may insert new events in FES or delete existing ones)</i>
<i>}</i>
<i>finish simulation (write statistical results, etc.)</i>
</pre>

<p>
The initialization step usually builds the data structures
representing the simulation model, calls any user-defined
initialization code, and inserts initial events<!--initial events-->
into the FES<!--FES--> to ensure that the simulation can start. Initialization
strategies can differ considerably from one simulator to another.

<p>
The subsequent loop consumes events from the FES<!--FES--> and processes
them. Events are processed in strict timestamp order
to maintain causality, that is, to ensure that no current event may have
an effect on earlier events.

<p>Processing an event involves calls to user-supplied code. For example,
using the computer network simulation example, processing a &#8220;timeout
expired&#8221; event may consist of re-sending a copy of the network
packet, updating the retry count, scheduling another &#8220;timeout&#8221;
event, and so on. The user code may also remove events from the FES<!--FES-->,
for example when canceling timeouts.

<p>The simulation stops when there are no events left (this rarely happens
in practice), or when it isn't necessary for the simulation
to run further because the model time or the CPU time has reached
a given limit, or because the statistics have reached the desired
accuracy. At this time, before the program exits, the user
will typically want to record statistics into output files.

<p>
<h3><a name="sec142"/>4.1.3 Events and Event Execution Order in OMNeT++</h3>
<a name="sec:simple-modules:events-in-opp"></a>

<p>OMNeT++ uses messages<!--message--> to represent
events<!--events-->. Each event is represented by an instance of the
<tt><a href="../api/classcMessage.html">cMessage</a></tt> class or one its subclasses; there is no separate
event class. Messages are sent from one module to another -- this
means that the place where the &#8220;event will occur&#8221; is the
<i>message's destination module</i>, and the model time when the
event occurs is the <i>arrival time</i><!--arrival time--> of the
message. Events like &#8220;timeout expired&#8221; are implemented by the
module sending a message to itself.

<p>Events are consumed from the FES<!--FES--> in arrival time order, to
maintain causality. More precisely, given two messages, the following
rules apply:
<ol>
<li>the message with the <b>earlier arrival time</b> is executed
    first.  If arrival times are equal,
<li>the one with the <b>smaller scheduling priority value</b> is
    executed first. If priorities are the same,
<li>the one <b>scheduled or sent earlier</b> is executed first.
</ol>

<p><i>Scheduling priority</i><!--message!priority--> is a user-assigned integer
attribute of messages.

<p>

<p><h3><a name="sec143"/>4.1.4 Simulation Time</h3>
<a name="sec:simple-modules:simulation-time"></a>

<p>The current simulation time can be obtained with the <tt>simTime()</tt> function.

<p>Simulation time in OMNeT++ is represented by the C++ type <tt>simtime_t</tt>,
which is by default a typedef to the <tt><a href="../api/classSimTime.html">SimTime</a></tt> class.
<tt><a href="../api/classSimTime.html">SimTime</a></tt> class stores simulation time in a 64-bit integer,
using decimal fixed-point representation. The resolution is controlled
by the <i>scale exponent</i> global configuration variable; that is,
<tt><a href="../api/classSimTime.html">SimTime</a></tt> instances have the same resolution. The exponent can be
between chosen between -18 (attosecond resolution) and 0 (seconds).
Some exponents with the ranges they provide are shown in the following table.

<p><center>
  <table border>
<TR> <TD align=right>
    Exponent </TD> <TD align=right> Resolution </TD> <TD align=center> Approx. Range </TD></TR>
<TR> <TD align=right>      -18 </TD> <TD align=right> <i>10<sup>-18</sup></i>s (1as) </TD> <TD align=center> <i>+/- 9.22</i>s </TD></TR>
<TR> <TD align=right>      -15 </TD> <TD align=right> <i>10<sup>-15</sup></i>s (1fs) </TD> <TD align=center> <i>+/- 153.72</i> minutes </TD></TR>
<TR> <TD align=right>      -12 </TD> <TD align=right> <i>10<sup>-12</sup></i>s (1ps) </TD> <TD align=center> <i>+/- 106.75</i> days </TD></TR>
<TR> <TD align=right>      -9  </TD> <TD align=right> <i>10<sup>-9</sup></i>s (1ns)  </TD> <TD align=center> <i>+/- 292.27</i> years </TD></TR>
<TR> <TD align=right>      -6  </TD> <TD align=right> <i>10<sup>-6</sup></i>s (1us)  </TD> <TD align=center> <i>+/- 292271</i> years </TD></TR>
<TR> <TD align=right>      -3  </TD> <TD align=right> <i>10<sup>-3</sup></i>s (1ms)  </TD> <TD align=center> <i>+/- 2.9227e8</i> years </TD></TR>
<TR> <TD align=right>      0   </TD> <TD align=right> 1s                </TD> <TD align=center> <i>+/- 2.9227e11</i> years </TD></TR>
<TR> <TD align=right>
  </table>
</center>

<p>Note that although simulation time cannot be negative, it is still useful to
be able to represent negative numbers, because they often arise
during the evaluation of arithmetic expressions.

<p>The <tt><a href="../api/classSimTime.html">SimTime</a></tt> class performs additions and subtractions as 64-bit integer
operations. Integer overflows are checked, and will cause the simulation to
stop with an error message. Other operations (multiplication, division, etc)
are performed in <tt>double</tt>, then converted back to integer.

<p>There is no implicit conversion from <tt><a href="../api/classSimTime.html">SimTime</a></tt> to <tt>double</tt>, mostly
because it would conflict with overloaded arithmetic operations of <tt><a href="../api/classSimTime.html">SimTime</a></tt>;
use the <tt>dbl()</tt> method of <tt>Simtime</tt> to convert. To reduce the
need for <tt>dbl()</tt>, several functions and methods have overloaded variants
that directly accept <tt><a href="../api/classSimTime.html">SimTime</a></tt>, for example <tt>fabs()</tt>, <tt>fmod()</tt>,
<tt>ceil()</tt>, <tt>floor()</tt>, <tt>uniform()</tt>, <tt>exponential()</tt>, and
<tt>normal()</tt>.

<p><ul class="note"><b>NOTE</b><br>
   Converting a <tt><a href="../api/classSimTime.html">SimTime</a></tt> to <tt>double</tt> may lose precision, because
   <tt>double</tt> only has a 52-bit mantissa.
</ul>

<p>Other useful methods of <tt><a href="../api/classSimTime.html">SimTime</a></tt> include <tt>str()</tt>,
which returns the value as a string; <tt>parse()</tt>, which converts a
string to <tt><a href="../api/classSimTime.html">SimTime</a></tt>; <tt>raw()</tt>, which returns the
underlying <tt>int64</tt> value; <tt>getScaleExp()</tt>, which returns the
global scale exponent; and <tt>getMaxTime</tt>, which returns the
maximum simulation time that can be represented at the current
scale exponent.

<p><p class="subheading">Compatibility</p>

<p>Earlier versions of OMNeT++ used <tt>double</tt> for simulation time. To facilitate
porting existing models to OMNeT++ 4.0 or later, OMNeT++ can be compiled to use
<tt>double</tt> for <tt>simtime_t</tt>. To enable this mode, define the
<tt>USE_DOUBLE_SIMTIME</tt> preprocessor macro during compiling OMNeT++
and the simulation models.

<p>There are several macros that can be used in simulation models to make
them compile with both <tt>double</tt> and <tt><a href="../api/classSimTime.html">SimTime</a></tt> simulation time:
<tt>SIMTIME_STR()</tt> converts simulation time to a <tt>const char *</tt>
(can be used in <tt>printf</tt> argument lists);
<tt>SIMTIME_DBL(t)</tt> converts simulation time to <tt>double</tt>;
<tt>SIMTIME_RAW(t)</tt> returns the underlying <tt>int64</tt> or <tt>double</tt>;
<tt>STR_SIMTIME(s)</tt> converts string to simulation time; and
<tt>SIMTIME_TTOA(buf,t)</tt> converts simulation time to string,
and places the result into the given buffer. <tt>MAXTIME</tt> is
also defined correctly for both <tt>simtime_t</tt> types.

<p><ul class="note"><b>NOTE</b><br>
   Why did OMNeT++ switch to <tt>int64</tt>-based simulation time?
   <tt>double</tt>'s mantissa is only 52 bits long, and this caused
   problems in long simulations that relied on fine-grained timing,
   for example MAC protocols. Other problems were the accumulation of
   rounding errors, and non-associativity (often <i>(x+y)+z != x+(y+z)</i>, see
   ~[<a href="#bib-Goldberg91what">Goldberg91what</a>]) which meant that two <tt>double</tt> simulation
   times could not be reliably compared for equality.
</ul>

<p>
<h3><a name="sec144"/>4.1.5 FES Implementation</h3>
<a name="sec:simple-modules:fes-implementation"></a>

<p>The implementation of the FES<!--FES--> is a crucial factor in the
performance of a discrete event simulator. In OMNeT++, the FES is
implemented with <i>binary heap</i><!--binary heap-->, the most
widely used data structure for this purpose. Heap is generally considered the best
algorithm, although exotic data structures like
<i>skiplist</i><!--skiplist--> may perform better than heap in some
cases. In case you are interested, the FES implementation is in the
<tt><a href="../api/classcMessageHeap.html">cMessageHeap</a></tt> class, but knowledge of the FES implementation is
not necessary for the typical simulation programmer.

<p>
<h2><a name="sec145"/>4.2 Components, Simple Modules, Channels</h2>
<a name="sec:simple-modules-in-opp"></a>

<p>OMNeT++ simulation models are composed of modules and connections. Modules
may be simple (atomic) modules or compound modules; simple modules are the
active components in a model, and their behaviour is defined by the user as
C++ code. Connections may have associated channel objects. Channel objects
encapsulate channel behavior: propagation and transmission time modeling,
error modeling, and possibly others. Channels are also programmable in C++
by the user.

<p>Modules and channels are represented with the <tt><a href="../api/classcModule.html">cModule</a></tt> and <tt><a href="../api/classcChannel.html">cChannel</a></tt>
classes, respectively. <tt><a href="../api/classcModule.html">cModule</a></tt> and <tt><a href="../api/classcChannel.html">cChannel</a></tt> are both
derived from the <tt><a href="../api/classcComponent.html">cComponent</a></tt> class.

<p>The user defines simple module types by subclassing <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>.
Compound modules are instantiated with <tt><a href="../api/classcModule.html">cModule</a></tt>, although
the user can override it with <b><tt>@class</tt></b> in the NED file, and can even
use a simple module C++ class (i.e. one derived from <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>)
for a compound module.

<p>The <tt><a href="../api/classcChannel.html">cChannel</a></tt>'s subclasses include the three built-in channel
types: <tt><a href="../api/classcIdealChannel.html">cIdealChannel</a></tt>, <tt><a href="../api/classcDelayChannel.html">cDelayChannel</a></tt> and
<tt><a href="../api/classcDatarateChannel.html">cDatarateChannel</a></tt>. The user can create new channel types
by subclassing <tt><a href="../api/classcChannel.html">cChannel</a></tt> or any other channel class.

<p>The following inheritance diagram illustrates the relationship
of the classes mentioned above.

<p>
  <center>
    <img src="component-inheritance.png">
    <center><i>Figure: Inheritance of component, module and channel classes</i></center>
  </center>

<p>
Simple modules and channels can be programmed by redefining certain
member functions, and providing your own code in them. Some of those
member functions are declared on <tt><a href="../api/classcComponent.html">cComponent</a></tt>, the common base
class of channels and modules.

<p><tt><a href="../api/classcComponent.html">cComponent</a></tt> has the following member functions meant for
redefining in subclasses:

<p><ul>
  <li> <tt>initialize()</tt>. This method is invoked after OMNeT++ has
    set up the network (i.e. created modules and connected them according
    to the definitions), and provides a place for initialization code;
  <li> <tt>finish()</tt> is called when the simulation has terminated
    successfully, and its recommended use is the recording of summary
    statistics.
</ul>

<p><tt>initialize()</tt> and <tt>finish()</tt>, together with <tt>initialize()</tt>'s
variants for multi-stage initialization, will be covered in detail in
section <a href="#sec149">[4.3.3]</a>.

<p>
In OMNeT++, events occur inside simple modules<!--module!simple-->.
Simple modules encapsulate C++ code that generates events and reacts to events,
in other words, implements the behaviour of the model.

<p>To define the dynamic behavior of a simple module, you need to redefine one
of the following member functions:

<p><ul>
  <li> <tt>handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)</tt>. It
     is invoked with the message as parameter whenever the
     module receives a message. <tt>handleMessage()</tt> is
     expected to <i>process</i> the message, and then return.
     Simulation time never elapses inside <tt>handleMessage()</tt>
     calls, only between them.
  <li> <tt>activity()</tt> is started as a coroutine<br><ul><font size=-1>[Cooperatively
     scheduled thread, explained later.]</font></ul> at the beginning of the simulation, and
     it runs until the end of simulation (or until the function
     returns or otherwise terminates). Messages are obtained with
     <tt>receive()</tt> calls. Simulation time elapses inside
     <tt>receive()</tt> calls.
</ul>

<p>Modules written with <tt>activity()</tt> and <tt>handleMessage()</tt> can be
freely mixed within a simulation model. Generally, <tt>handleMessage()</tt>
should be preferred to <tt>activity()</tt>, due to scalability and other
practical reasons. The two functions will be described in detail in sections
<a href="#sec151">[4.4.1]</a> and <a href="#sec152">[4.4.2]</a>,
including their advantages and disadvantages.

<p>The behavior of channels can also be modified by redefining member functions.
However, the channel API is slightly more complicated than that of simple
modules, so we'll describe it in a later section (<a href="#sec173">[4.8]</a>).

<p>

<p><h2><a name="sec146"/>4.3 Defining Simple Module Types</h2>
<a name="sec:simple-modules:defining-simple-modules"></a>

<p><h3><a name="sec147"/>4.3.1 Overview</h3>

<p>As mentioned before, a simple module<!--module!simple--> is nothing more
than a C++ class which has to be subclassed from <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>,
with one or more virtual member functions redefined to define its behavior.

<p>The class has to be registered with OMNeT++ via the <tt>Define_Module()</tt> macro.
The <tt>Define_Module()</tt> line should always be put into <tt>.cc</tt> or <tt>.cpp</tt>
files and not header file (<tt>.h</tt>), because the compiler generates code from it.

<p>The following <tt>HelloModule</tt> is about the simplest simple module one could write.
(We could have left out the <tt>initialize()</tt> method as well to make it even smaller,
but how would it say Hello then?) Note <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> as base class,
and the <tt>Define_Module()</tt> line.

<pre class="cpp">
// file: HelloModule.cc
#include &lt;omnetpp.h&gt;

class HelloModule : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

// register module class with `\opp`
Define_Module(HelloModule);

void HelloModule::initialize()
{
    ev &lt;&lt; "Hello World!\n";
}

void HelloModule::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    delete msg; // just discard everything we receive
}
</pre>
<p>
In order to be able to refer to this simple<!--module!simple--> module type
in NED files, we also need an associated NED declaration which might
look like this:

<pre class="ned">
// file: HelloModule.ned
simple HelloModule
{
    gates:
        input in;
}
</pre>
<p>

<p><h3><a name="sec148"/>4.3.2 Constructor</h3>
<a name="sec:simple-modules:module-ctor"></a>

<p>Simple modules are never instantiated by the user directly, but rather by
the simulation kernel. This implies that one cannot write arbitrary
constructors: the signature must be what is expected by the simulation kernel.
Luckily, this contract is very simple: the constructor must be public, and must take
no arguments:

<pre class="cpp">
  public:
    HelloModule();  // constructor takes no arguments
</pre>
<p>
<tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> itself has two constructors:
<ol>
  <li><tt><a href="../api/classcSimpleModule.html">cSimpleModule</a>()</tt> -- one without arguments
  <li><tt><a href="../api/classcSimpleModule.html">cSimpleModule</a>(size_t stacksize)</tt> -- one that accepts the coroutine
        stack size<!--module!stack size--><!--stack!size-->
</ol>

<p>The first version should be used with <tt>handleMessage()</tt> simple modules,
and the second one with <tt>activity()</tt> modules.
(With the latter, the <tt>activity()</tt> method of the module class
runs as a coroutine<!--coroutine--> which needs a separate CPU stack,
usually of 16..32K. This will be discussed in detail later.)
Passing zero stack size to the latter constructor also selects <tt>handleMessage()</tt>.

<p>Thus, the following constructor definitions are all OK, and select
<tt>handleMessage()</tt> to be used with the module:

<pre class="cpp">
HelloModule::HelloModule() {...}
HelloModule::HelloModule() : <a href="../api/classcSimpleModule.html">cSimpleModule</a>() {...}
</pre>
<p>
It is also OK to omit the constructor altogether, because the
compiler-generated one is suitable too.

<p>The following constructor definition selects <tt>activity()</tt> to be used
with the module, with 16K of coroutine stack:

<pre class="cpp">
HelloModule::HelloModule() : <a href="../api/classcSimpleModule.html">cSimpleModule</a>(16384) {...}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
    The <tt>Module_Class_Members()</tt> macro, already deprecated in OMNeT++ 3.2,
    has been removed in the 4.0 version. When porting older simulation models,
    occurrences of this macro can simply be removed from the source code.
</ul>

<p>
<h3><a name="sec149"/>4.3.3 Initialization and Finalization</h3>
<a name="sec:simple-modules:initialize-and-finish"></a>

<p><p class="subheading">Basic Usage</p>

<p>The <tt>initialize()</tt> and <tt>finish()</tt> methods are declared
as part of <tt><a href="../api/classcComponent.html">cComponent</a></tt>, and provide the user the opportunity
of running code at the beginning and at successful termination of the
simulation.

<p>The reason <tt>initialize()</tt> exists is that usually you cannot put
simulation-related code into the simple module
constructor<!--module!constructor-->, because the simulation model is still
being setup when the constructor runs, and many required objects are not yet
available. In contrast, <tt>initialize()</tt> is called just before the
simulation starts executing, when everything else has been set up
already.

<p><tt>finish()</tt> is for recording statistics, and it only gets called
when the simulation has terminated normally. It does not get called when
the simulations stops with an error message. The destructor always
gets called at the end, no matter how the simulation stopped, but
at that time it is fair to assume that the simulation model has been
halfway demolished already.

<p>Based on the above considerations, the following usage conventions exist
for these four methods:

<p><dl>

<p><li> Constructor:

<p>Set pointer members of the module class to <tt>NULL</tt>; postpone all other
initialization tasks to <tt>initialize()</tt>.

<p><li> <tt>initialize()</tt>:

<p>Perform all initialization tasks: read module parameters, initialize
class variables, allocate dynamic data structures with <tt>new</tt>;
also allocate and initialize self-messages (timers) if needed.

<p><li> <tt>finish()</tt>:

<p>Record statistics. Do <b>not</b> <tt>delete</tt> anything or cancel timers --
all cleanup must be done in the destructor.

<p><li> Destructor:

<p>Delete everything which was allocated by <tt>new</tt> and is still held
by the module class. With self-messages (timers), use the
<tt>cancelAndDelete(msg)</tt> function! It is almost always wrong
to just delete a self-message from the destructor, because it might be
in the scheduled events list. The <tt>cancelAndDelete(msg)</tt> function
checks for that first, and cancels the message before deletion if necessary.

<p></dl>

<p>OMNeT++ prints the list of unreleased objects at the end of the simulation.
When a simulation model dumps <i>"undisposed object ..."</i> messages, this indicates
that the corresponding module destructors should be fixed. As a temporary measure, these
messages may be hidden by setting <tt>print-undisposed=false</tt> in the
configuration.

<p><ul class="note"><b>NOTE</b><br>
    The <tt>perform-gc</tt> configuration option has been removed in OMNeT++ 4.0.
    Automatic garbage collection cannot be implemented reliably, due to the
    limitations of the C++ language.
</ul>

<p>
<p class="subheading">Invocation Order</p>

<p>The <tt>initialize()</tt> functions of the modules are invoked <i>before</i>
the first event is processed, but <i>after</i> the initial events (starter
messages<!--starter messages-->) have been placed into the FES<!--FES--> by
the simulation kernel.

<p>Both simple and compound modules have <tt>initialize()</tt> functions. A
compound module's <tt>initialize()</tt> function runs <i>before</i> that of
its submodules.

<p>The <tt>finish()</tt> functions are called when the event loop<!--event loop-->
has terminated, and only if it terminated normally.

<p><ul class="note"><b>NOTE</b><br>
<tt>finish()</tt> is not called if the simulation has terminated
with a runtime error.
</ul>

<p>The calling order for <tt>finish()</tt> is the reverse of the order of
<tt>initialize()</tt>: first submodules, then the encompassing compound module.
  <br><ul><font size=-1>[The way you can provide an <tt>initialize()</tt> function
  for a compound module is to subclass <tt><a href="../api/classcModule.html">cModule</a></tt>, and tell
  OMNeT++ to use the new class for the compound module. The latter is done
  by adding the <tt>@class(&lt;classname&gt;)</tt> property into the NED declaration.]</font></ul>

<p>This is summarized in the following pseudocode:

<p>
<pre class="verbatim">
<i>perform simulation run:</i>
    build network
      (i.e. the system module and its submodules recursively)
    insert starter messages for all submodules using activity()
    do callInitialize() on system module
        <i>enter event loop // (described earlier)</i>
    if (event loop terminated normally) // i.e. no errors
        do callFinish() on system module
    clean up

callInitialize()
{
    call to user-defined initialize() function
    if (module is compound)
        for (each submodule)
            do callInitialize() on submodule
}

callFinish()
{
    if (module is compound)
        for (each submodule)
            do callFinish() on submodule
    call to user-defined finish() function
}
</pre>

<p>Keep in mind that <tt>finish()</tt> is not always called, so it isn't a
good place for cleanup code which should run every time the module is
deleted. <tt>finish()</tt> is only a good place for writing statistics,
result post-processing and other operations  which are supposed to run only on
successful completion. Cleanup code should go into the
destructor<!--module!destructor-->.

<p>
<p class="subheading">Multi-Stage Initialization</p>
<a name="sec:simple-modules:multi-stage-init"></a>

<p>
In simulation models where one-stage
initialization<!--initialization--> provided by <tt>initialize()</tt>
is not sufficient, one can use multi-stage
initialization<!--initialization!multi-stage-->.  Modules have two
functions which can be redefined by the user:

<pre class="cpp">
void initialize(int stage);
int numInitStages() const;
</pre>
<p>
At the beginning of the simulation, <tt>initialize(0)</tt>
is called for <i>all</i> modules, then <tt>initialize(1)</tt>,
<tt>initialize(2)</tt>, etc. You can think of it like
initialization takes place in several &#8220;waves&#8221;. For each module,
<tt>numInitStages()</tt> must be redefined to return the number of init
stages required, e.g. for a two-stage init, <tt>numInitStages()</tt>
should return 2, and <tt>initialize(int stage)</tt> must be implemented to
handle the <i>stage=0</i> and <i>stage=1</i> cases.
  <br><ul><font size=-1>[Note <tt>const</tt> in the <tt>numInitStages()</tt> declaration.
  If you forget it, by C++ rules you create a <i>different</i> function
  instead of redefining the existing one in the base class, thus the
  existing one will remain in effect and return 1.]</font></ul>

<p>The <tt>callInitialize()</tt> function performs the full multi-stage initialization
for that module and all its submodules.

<p>If you do not redefine the multi-stage initialization functions, the
default behavior is single-stage initialization: the default
<tt>numInitStages()</tt> returns 1, and the default <tt>initialize(int stage)</tt>
simply calls <tt>initialize()</tt>.

<p>
<p class="subheading">&#8220;End-of-Simulation&#8221; Event</p>

<p>The task of <tt>finish()</tt> is implemented in several other simulators
by introducing a special <i>end-of-simulation</i><!--end-of-simulation--> event.
This is not a very good practice because the simulation programmer has to
code the models (often represented as FSMs) so that they can <i>always</i>
properly respond to end-of-simulation events, in whichever state they are. This
often makes program code unnecessarily complicated.
 For this reason OMNeT++ does not use the end of simulation event.

<p>This can also be witnessed in the design of the PARSEC<!--PARSEC-->
simulation language (UCLA). Its predecessor Maisie used
end-of-simulation events, but -- as documented in the PARSEC manual --
this has led to awkward programming in many cases, so for PARSEC
end-of-simulation events were dropped in favour of <tt>finish()</tt>
(called <tt>finalize()</tt> in PARSEC).

<p>
<h2><a name="sec150"/>4.4 Adding Functionality to <a href="../api/classcSimpleModule.html">cSimpleModule</a></h2>
<a name="sec:simple-modules:adding-functionality-to-csimplemodule"></a>

<p>This section discusses <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>'s four previously
mentioned member functions, intended to be redefined by the user:
<tt>initialize()</tt>, <tt>handleMessage()</tt>, <tt>activity()</tt>
and <tt>finish()</tt>. A fifth, less frequently used method,
<tt>handleParameterChange</tt>, is described in section
<a href="#sec160">[4.5.5]</a>.

<p>
<h3><a name="sec151"/>4.4.1 handleMessage()</h3>
<a name="sec:simple-modules:handlemessage"></a>

<p><p class="subheading">Function Called for Each Event</p>

<p>
The idea is that at each event<!--event--> (message arrival) we
simply call a user-defined function. This function,
<tt>handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)</tt> is a
virtual member function of <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> which does
nothing by default -- the user has to redefine it in subclasses
and add the message processing code.

<p>The <tt>handleMessage()</tt> function will be called for every message
that arrives at the module. The function should process the message
and return immediately after that. The simulation time is potentially
different in each call. No simulation time elapses within a call
to <tt>handleMessage()</tt>.

<p>The event loop inside the simulator handles both <tt>activity()</tt>
and <tt>handleMessage()</tt> simple modules, and it corresponds
to the following pseudocode:

<p><pre class="verbatim">
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve first event from FES
    t:= timestamp of this event
    m:= module containing this event
    if (m works with handleMessage())
        <b>m-&gt;handleMessage( event )</b>
    else // m works with activity()
        transferTo( m )
}
</pre>

<p>Modules with <tt>handleMessage()</tt> are NOT started automatically:
the simulation kernel creates starter messages<!--starter messages-->
only for modules with <tt>activity()</tt>. This means that you have to
schedule self-messages<!--self-message--> from the
<tt>initialize()</tt> function if you want a <tt>handleMessage()</tt>
simple module to start working &#8220;by itself&#8221;, without first receiving
a message from other modules.

<p>
<p class="subheading">Programming with handleMessage()</p>

<p>
To use the <tt>handleMessage()</tt> mechanism in a
simple module, you must specify <i>zero
  stack size</i><!--zero stack size--> for the module. This is
important, because this tells OMNeT++ that you want to use
<tt>handleMessage()</tt> and not <tt>activity()</tt>.

<p>Message/event related functions you can use in <tt>handleMessage()</tt>:

<p><ul>
  <li><tt>send()</tt> family of functions -- to send messages to other modules
  <li><tt>scheduleAt()</tt> -- to schedule an event (the module &#8220;sends a message to itself&#8221;)
  <li><tt>cancelEvent()</tt> -- to delete an event scheduled with <tt>scheduleAt()</tt>
</ul>

<p>You cannot use the <tt>receive()</tt> and
<tt>wait()</tt> functions in <tt>handleMessage()</tt>, because they are
coroutine-based by nature, as explained in the section about
<tt>activity()</tt>.

<p>You have to add data members to the module class for every piece
of information you want to preserve. This information cannot
be stored in local variables of <tt>handleMessage()</tt> because they
are destroyed when the function returns. Also, they cannot be
stored in static variables in the function (or the class), because
they would be shared between all instances of the class.

<p>
Data members to be added to the module class will typically include
things like:

<p><ul>
  <li>state (e.g. IDLE/BUSY, CONN_DOWN/CONN_ALIVE/...)
  <li>other variables which belong to the state of the module: retry
    counts, packet queues, etc.
  <li>values retrieved/computed once and then stored: values of module
    parameters, gate indices, routing information, etc.
  <li>pointers of message objects created once and then reused for
    timers, timeouts, etc.
  <li>variables/objects for statistics collection
</ul>

<p>You can initialize these variables from the <tt>initialize()</tt>
function.  The constructor<!--module!constructor--> is not a very good place
for this purpose, because it is called in the network setup phase when
the model is still under construction, so a lot of information you may
want to use is not yet available.

<p>Another task you have to do in <tt>initialize()</tt> is to schedule
initial event(s)<!--events!initial--> which trigger the first call(s)
to <tt>handleMessage()</tt>.  After the first call,
<tt>handleMessage()</tt> must take care to schedule further events for
itself so that the &#8220;chain&#8221; is not broken. Scheduling events is not
necessary if your module only has to react to messages coming from
other modules.

<p><tt>finish()</tt> is normally used to record statistics information
accumulated in data members of the class at the end of the simulation.

<p>
<p class="subheading">Application Area</p>

<p>
<tt>handleMessage()</tt> is in most cases a better choice than <tt>activity()</tt>:

<p><ol>
  <li>When you expect the module to be used in large simulations,
      involving several thousand modules. In such cases, the module stacks
      required by <tt>activity()</tt> would simply consume too much memory.
  <li>For modules which maintain little or no state information,
      such as packet sinks, <tt>handleMessage()</tt> is more convenient to program.
  <li>Other good candidates are modules with a large state space and
      many arbitrary state transition possibilities (i.e. where there
      are many possible subsequent states for any state). Such algorithms
      are difficult to program with <tt>activity()</tt>, and
      better suited for <tt>handleMessage()</tt> (see rule of thumb
      below). This is the case for most communication protocols.
</ol>

<p>
<p class="subheading">Example 1: Protocol Models</p>

<p>Models of protocol layers in a communication network tend to have
a common structure on a high level because fundamentally they all have to react
to three types of events: to messages arriving from higher layer protocols
(or apps), to messages arriving from lower layer protocols (from the network),
and to various timers and timeouts (that is, self-messages).

<p>This usually results in the following source code pattern:

<pre class="cpp">
class FooProtocol : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    // state variables
    // ...

    virtual void processMsgFromHigherLayer(<a href="../api/classcMessage.html">cMessage</a> *packet);
    virtual void processMsgFromLowerLayer(FooPacket *packet);
    virtual void processTimer(<a href="../api/classcMessage.html">cMessage</a> *timer);

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

// ...

void FooProtocol::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    if (msg-&gt;isSelfMessage())
        processTimer(msg);
    else if (msg-&gt;arrivedOn("fromNetw"))
        processMsgFromLowerLayer(check_and_cast&lt;FooPacket *&gt;(msg));
    else
        processMsgFromHigherLayer(msg);
}
</pre>
<p>
The functions <tt>processMsgFromHigherLayer()</tt>, <tt>processMsgFromLowerLayer()</tt>
and <tt>processTimer()</tt> are then usually split further: there are separate
methods to process separate packet types and separate timers.

<p>
<p class="subheading">Example 2: Simple Traffic Generators and Sinks</p>

<p>
The code for simple packet generators and sinks programmed with <tt>handleMessage()</tt> might
be as simple as the following pseudocode:

<pre class="cpp">
PacketGenerator::handleMessage(msg)
{
    create and send out a new packet;
    schedule msg again to trigger next call to handleMessage;
}

PacketSink::handleMessage(msg)
{
    delete msg;
}
</pre>
<p>
Note that <i>PacketGenerator</i> will need to redefine <tt>initialize()</tt>
to create <i>m</i> and schedule the first event.

<p>The following simple module generates packets with exponential
inter-arrival time. (Some details in the source haven't been
discussed yet, but the code is probably understandable nevertheless.)

<p>
<pre class="cpp">
class Generator : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  public:
    Generator() : <a href="../api/classcSimpleModule.html">cSimpleModule</a>() {}
  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(Generator);

void Generator::initialize()
{
    // schedule first sending
    scheduleAt(simTime(), new <a href="../api/classcMessage.html">cMessage</a>);
}

void Generator::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    // generate & send packet
    <a href="../api/classcMessage.html">cMessage</a> *pkt = new <a href="../api/classcMessage.html">cMessage</a>;
    send(pkt, "out");
    // schedule next call
    scheduleAt(simTime()+exponential(1.0), msg);
}
</pre>

<p>

<p><p class="subheading">Example 3: Bursty Traffic Generator</p>

<p>
A bit more realistic example is to rewrite our Generator to create
packet bursts, each consisting of <tt>burstLength</tt> packets.

<p>We add some data members to the class:
<ul>
<li><tt>burstLength</tt> will store the parameter that specifies how many
    packets a burst must contain,
<li><tt>burstCounter</tt> will count in how many packets are left to be sent
    in the current burst.
</ul>

<p>The code:

<pre class="cpp">
class BurstyGenerator : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    int burstLength;
    int burstCounter;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    // init parameters and state variables
    burstLength = par("burstLength");
    burstCounter = burstLength;
    // schedule first packet of first burst
    scheduleAt(simTime(), new <a href="../api/classcMessage.html">cMessage</a>);
}

void BurstyGenerator::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    // generate & send packet
    <a href="../api/classcMessage.html">cMessage</a> *pkt = new <a href="../api/classcMessage.html">cMessage</a>;
    send(pkt, "out");
    // if this was the last packet of the burst
    if (--burstCounter == 0)
    {
        // schedule next burst
        burstCounter = burstLength;
        scheduleAt(simTime()+exponential(5.0), msg);
    }
    else
    {
        // schedule next sending within burst
        scheduleAt(simTime()+exponential(1.0), msg);
    }
}
</pre>
<p>

<p>
<p class="subheading">Pros and Cons of Using <tt>handleMessage()</tt></p>

<p>
Pros:
<ul>
  <li>consumes less memory: no separate stack needed for simple modules
  <li>fast: function call is faster than switching between coroutines<!--coroutine-->
</ul>

<p>Cons:
<ul>
  <li>local variables cannot be used to store state information
  <li>need to redefine <tt>initialize()</tt>
</ul>

<p>Usually, <tt>handleMessage()</tt> should be preferred over <tt>activity()</tt>.

<p>
<p class="subheading">Other Simulators</p>

<p>
Many simulation packages use a similar approach, often topped with
something like a state machine<!--finite state machine-->
(FSM<!--FSM-->) which hides the underlying function calls. Such
systems are:
<ul>
  <li>OPNET<i><sup>TM</sup></i> which uses FSM's designed using a graphical editor;
  <li>NetSim++ clones OPNET's approach;
  <li>SMURPH (University of Alberta) defines a (somewhat eclectic)
      language to describe FSMs, and uses a precompiler to turn it
      into C++ code;
  <li>Ptolemy (UC Berkeley) uses a similar method.
</ul>

<p>OMNeT++'s FSM<!--FSM--> support is described in the next section.

<p>

<p><h3><a name="sec152"/>4.4.2 activity()</h3>
<a name="sec:simple-modules:activity"></a>

<p><p class="subheading">Process-Style Description</p>

<p>With <tt>activity()</tt>, you can code the simple
module much like you would code an operating system process or a
thread. You can wait for an incoming message (event) at any point of
the code, you can suspend the execution for some time (model time!),
etc. When the <tt>activity()</tt> function exits, the module is
terminated.  (The simulation can continue if there are other modules
which can run.)

<p>
The most important functions you can use in <tt>activity()</tt> are
(they will be discussed in detail later):
<ul>
<li><tt>receive()</tt> -- to receive messages (events)
<li><tt>wait()</tt> -- to suspend execution<!--suspend execution-->
    for some time (model time)
<li><tt>send()</tt> family of functions -- to send messages to other
    modules
<li><tt>scheduleAt()</tt> -- to schedule an event (the module &#8220;sends
    a message to itself&#8221;)
<li><tt>cancelEvent()</tt> -- to delete an event scheduled with
    scheduleAt()
<li><tt>end()</tt> -- to finish execution of this module (same as
    exiting the <tt>activity()</tt> function)
</ul>

<p>The <tt>activity()</tt> function normally contains an infinite loop,
with at least a <tt>wait()</tt> or <tt>receive()</tt> call in its body.

<p>

<p><p class="subheading">Application Area</p>

<p>Generally you should prefer <tt>handleMessage()</tt> to <tt>activity()</tt>.
The main problem with <tt>activity()</tt> is that it doesn't scale because
every module needs a separate coroutine stack. It has also been observed
that <tt>activity()</tt> does not encourage a good programming style.

<p>There is one scenario where <tt>activity()</tt>'s process-style
description is convenient: when the process has many
states but transitions are very limited, ie. from any state the
process can only go to one or two other states.  For example, this is
the case when programming a network application, which uses a single
network connection.  The pseudocode of the application which talks to
a transport layer protocol might look like this:

<p><pre class="verbatim">
<i>activity()</i>
{
    while(true)
    {
        open connection by sending OPEN command to transport layer
        receive reply from transport layer
        if (open not successful)
        {
            wait(some time)
            continue // loop back to while()
        }

        while (there is more to do)
        {
            send data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
            receive data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
        }
        close connection by sending CLOSE command to transport layer
        if (close not successful)
        {
            // handle error
        }
        wait(some time)
    }
}
</pre>

<p>If you have to handle several connections simultaneously, you may
dynamically create them as instances of the simple module above.
Dynamic module creation will be discussed later.

<p>There are situations when you certainly <i>do not want</i> to use <tt>activity()</tt>.
If your <tt>activity()</tt> function contains no <tt>wait()</tt> and it has
only one <tt>receive()</tt> call at the top of an infinite loop,
there is no point in using <tt>activity()</tt> and the code should be written
with <tt>handleMessage()</tt>.
The body of the infinite loop would then become the body to <tt>handleMessage()</tt>,
state variables inside <tt>activity()</tt> would become data members in
the module class, and you'd initialize them in <tt>initialize()</tt>.

<p>Example:

<pre class="cpp">
void Sink::activity()
{
    while(true)
    {
        msg = receive();
        delete msg;
    }
}
</pre>
<p>
should rather be programmed as:

<pre class="cpp">
void Sink::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    delete msg;
}
</pre>
<p>

<p>
<p class="subheading">Activity() Is Run as a Coroutine</p>

<p>
<tt>activity()</tt> is run in a coroutine<!--coroutine-->.
Coroutines are similar to threads, but are scheduled
non-preemptively (this is also called cooperative
multitasking<!--multitasking!cooperative-->). From one coroutine you
can switch to another coroutine by a
<tt>transferTo(otherCoroutine)</tt> call. Then this
coroutine is suspended and <i>otherCoroutine</i> will run. Later,
when <i>otherCoroutine</i> does a
<tt>transferTo(firstCoroutine)</tt> call, execution of
the first coroutine will resume from the point of the
<tt>transferTo(otherCoroutine)</tt> call.  The full state
of the coroutine, including local variables are preserved while the
thread of execution is in other coroutines.  This implies that each
coroutine must have its own processor stack<!--stack-->, and
<tt>transferTo()</tt> involves a switch from one processor stack to
another.

<p>
Coroutines<!--coroutine--> are at the heart of OMNeT++, and the
simulation programmer doesn't ever need to call <tt>transferTo()</tt>
or other functions in the coroutine library, nor does he need to care
about the coroutine library implementation. It is important to
understand, however, how the event loop found in discrete event simulators
works with coroutines.

<p>
When using coroutines, the event loop<!--event loop--> looks like
this (simplified):

<p>
<pre class="verbatim">
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve first event from FES
    t:= timestamp of this event
    <b>transferTo(module containing the event)</b>
}
</pre>

<p>

<p>That is, when a module has an event<!--event-->, the simulation
kernel transfers the control to the module's coroutine. It is expected
that when the module &#8220;decides it has finished the processing of the
event&#8221;, it will transfer the control back to the simulation kernel by
a <tt>transferTo(main)</tt> call. Initially,
simple<!--module!simple--> modules using <tt>activity()</tt> are
&#8220;booted&#8221; by events (<i>''starter messages''</i><!--starter messages-->)
inserted into the FES<!--FES--> by the simulation kernel before the
start of the simulation.

<p>
How does the coroutine know it has &#8220;finished processing the event&#8221;?
The answer: <i>when it requests another event</i>.  The functions
which request events from the simulation kernel are the
<tt>receive()</tt> and <tt>wait()</tt>, so their
implementations contain a <tt>transferTo(main)</tt> call
somewhere.

<p>
Their pseudocode, as implemented in OMNeT++:

<p>
<pre class="verbatim">
receive()
{
    transferTo(main)
    retrieve current event
    return the event // remember: events = messages
}

wait()
{
    create event e
    schedule it at (current sim. time + wait interval)
    transferTo(main)
    retrieve current event
    if (current event is not e) {
        error
    }
    delete e  // note: actual impl. reuses events
    return
}
</pre>

<p>

<p>Thus, the <tt>receive()</tt> and <tt>wait()</tt> calls are
special points in the <tt>activity()</tt> function, because
they are where

<p><ul>
  <li>simulation time elapses in the module, and
  <li>other modules get a chance to execute.
</ul>

<p>
<p class="subheading">Starter Messages</p>

<p>
Modules written with <tt>activity()</tt> need starter
messages<!--starter messages--> to &#8220;boot&#8221;.  These starter messages
are inserted into the FES<!--FES--> automatically by OMNeT++ at the
beginning of the simulation, even before the <tt>initialize()</tt>
functions are called.

<p>
<p class="subheading">Coroutine Stack Size</p>

<p>
The simulation programmer needs to define the processor stack size<!--coroutine!stack size-->
for coroutines. This cannot be automated.

<p>16 or 32 kbytes is usually a good choice, but you may need more if the
module uses recursive functions or has local variables, which occupy a
lot of stack space. OMNeT++ has a built-in mechanism that will usually
detect if the module stack is too small and overflows<!--stack!overflow-->.
OMNeT++ can also tell you how much stack space a module actually uses<!--stack!usage-->,
so you can find out if you overestimated the stack needs.

<p>
<p class="subheading">initialize() and finish() with activity()</p>

<p>
Because local variables of <tt>activity()</tt> are preserved across
events, you can store everything (state information, packet buffers,
etc.) in them. Local variables can be initialized at the top of the
<tt>activity()</tt> function, so there isn't much need to use
<tt>initialize()</tt>.

<p>
You do need <tt>finish()</tt>, however, if you want to write statistics at
the end of the simulation. Because <tt>finish()</tt> cannot access
the local variables of <tt>activity()</tt>, you have to put the variables
and objects containing the statistics into the module class.
You still don't need <tt>initialize()</tt> because class members can also
be initialized at the top of <tt>activity()</tt>.

<p>
Thus, a typical setup looks like this in pseudocode:

<p>
<pre class="verbatim">
<i>class MySimpleModule...</i>
{
    ...
    variables for statistics collection
    activity();
    finish();
};

MySimpleModule::activity()
{
    declare local vars and initialize them
    initialize statistics collection variables

    while(true)
    {
        ...
    }
}

MySimpleModule::finish()
{
    record statistics into file
}
</pre>

<p>
<p class="subheading">Pros and Cons of Using <tt>activity()</tt></p>

<p>
Pros:
<ul>
   <li><tt>initialize()</tt> not needed, state can be stored in local
       variables of <tt>activity()</tt>
   <li>process-style description is a natural programming model in some cases
</ul>

<p>Cons:
<ul>
   <li>limited scalability: coroutine stacks can unacceptably increase the
       memory requirements of the simulation program if you have several
       thousands or ten thousands of simple modules;
   <li>run-time overhead: switching between coroutines is somewhat slower
       than a simple function call
   <li>does not enforce a good programming style: using <tt>activity()</tt>
       tends to lead to unreliable, spaghetti code
</ul>

<p>In most cases, cons outweigh pros and it is a better idea to use
<tt>handleMessage()</tt> instead.

<p>
<p class="subheading">Other Simulators</p>

<p>
Coroutines are used by a number of other simulation packages:
<ul>
<li>All simulation software which inherits from SIMULA (e.g. C++SIM)
    is based on coroutines, although all in all the programming
    model is quite different.
<li>The simulation/parallel programming language Maisie and its successor
    PARSEC (from UCLA) also use coroutines (although implemented
    with &#8220;normal&#8221; preemptive threads). The philosophy
    is quite similar to OMNeT++. PARSEC, being &#8220;just&#8221;
    a programming language, it has a more elegant syntax but far fewer
    features than OMNeT++.
<li>Many Java-based simulation libraries are based on Java
    threads.
</ul>

<p><h3><a name="sec153"/>4.4.3 How to Avoid Global Variables</h3>
<a name="sec:simple-modules:global-vars"></a>
<!--global variables-->

<p>If possible, avoid using global variables, including
static class members. They are prone to cause several problems.
First, they are not reset to their initial values (to zero)
when you rebuild the simulation in Tkenv, or start another run
in Cmdenv. This may produce surprising results.
Second, they prevent you from running your simulation in parallel.
When using parallel simulation, each partition of your model
(may) run in a separate process, having its own copy of the
global variables. This is usually not what you want.

<p>The solution is to encapsulate the variables into simple modules
as private or protected data members, and expose them via public methods.
Other modules can then call these public methods to get or set the values.
Calling methods of other modules will be discussed in section
<a href="#sec182">[4.12]</a>.
Examples of such modules are the <tt>Blackboard</tt> in the <i>Mobility Framework</i>,
and <tt>InterfaceTable</tt> and <tt>RoutingTable</tt> in the <i>INET Framework</i>.

<p>
<h3><a name="sec154"/>4.4.4 Reusing Module Code via Subclassing</h3>
<a name="sec:simple-modules:module-subclassing"></a>

<p>The code of simple modules can be reused via subclassing, and redefining
virtual member functions. An example:

<pre class="cpp">
class TransportProtocolExt : public TransportProtocol
{
  protected:
    virtual void recalculateTimeout();
};

Define_Module(TransportProtocolExt);

void TransportProtocolExt::recalculateTimeout()
{
    //...
}
</pre>
<p>
The corresponding NED declaration:

<pre class="ned">
simple TransportProtocolExt extends TransportProtocol
{
    @class(TransportProtocolExt);  // Important!
}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  Note the <tt>@class()</tt> property, which tells OMNeT++ to use the
  <tt>TransportProtocolExt</tt> C++ class for the module type! It is needed
  because NED inheritance is NED inheritance <i>only</i>, so without <tt>@class()</tt>
  the <tt>TransportProtocolExt</tt> NED type would inherit the C++ class from
  its base NED type.
</ul>

<p>

<p><h2><a name="sec155"/>4.5 Accessing Module Parameters</h2>
<a name="sec:simple-modules:parameters"></a>

<p>Module parameters declared in NED files are represented with the <tt><a href="../api/classcPar.html">cPar</a></tt>
class at runtime, and be accessed<!--module!accessing parameters-->
by calling the <tt>par()</tt> member function of <tt><a href="../api/classcComponent.html">cComponent</a></tt>:

<pre class="cpp">
<a href="../api/classcPar.html">cPar</a>& delayPar = par("delay");
</pre>
<p>
<tt><a href="../api/classcPar.html">cPar</a></tt>'s value can be read with methods that correspond to
the parameter's NED type: <tt>boolValue()</tt>, <tt>longValue()</tt>,
<tt>doubleValue()</tt>, <tt>stringValue()</tt>, <tt>stdstringValue()</tt>,
<tt>xmlValue()</tt>.
There are also overloaded type cast operators for the corresponding types
(<tt>bool</tt>; integer types including <tt>int</tt>, <tt>long</tt>, etc;
<tt>double</tt>; <tt>const char *</tt>; <tt><a href="../api/classcXMLElement.html">cXMLElement</a> *</tt>).

<pre class="cpp">
long numJobs = par("numJobs").longValue();
double processingDelay = par("processingDelay"); // using operator double()
</pre>
<p>
Note that <tt><a href="../api/classcPar.html">cPar</a></tt> has two methods for returning a string value:
<tt>stringValue()</tt>, which returns <tt>const char *</tt>, and
<tt>stdstringValue()</tt>, which returns <tt>std::string</tt>.
For volatile parameters, only <tt>stdstringValue()</tt> may be used,
but otherwise the two are interchangeable.

<p>If you use the <tt>par("foo")</tt> parameter in expressions (such as
<tt>4*par("foo")+2</tt>), the C++ compiler may be unable to decide
between overloaded operators and report ambiguity. In that case
you have to clarify by adding either an explicit cast
(<tt>(double)par("foo")</tt> or <tt>(long)par("foo")</tt>) or use
the <tt>doubleValue()</tt> or <tt>longValue()</tt> methods.

<p>
<h3><a name="sec156"/>4.5.1 Volatile and Non-Volatile Parameters</h3>
<a name="sec:simple-modules:volatile-parameters"></a>

<p>A parameter can be declared <tt>volatile</tt> in the NED file. The <tt>volatile</tt>
modifier indicates that a parameter is re-read every time a value is needed
during simulation. Volatile parameters typically are used for things like
random packet generation interval, and are assigned values like <tt>exponential(1.0)</tt>
(numbers drawn from the exponential distribution with mean 1.0).

<p>In contrast, non-volatile NED parameters are constants, and reading their
values multiple times is guaranteed to yield the same value. When a non-volatile
parameter is assigned a random value like <tt>exponential(1.0)</tt>, it is
evaluated once at the beginning of the simulation and replaced with the result,
so all reads will get same (randomly generated) value.

<p>The typical usage for non-volatile parameters is to read them in the
<tt>initialize()</tt> method of the module class, and store the values
in class variables for easy access later:

<pre class="cpp">
class Source : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    long numJobs;
    virtual void initialize();
    ...
};

void Source::initialize()
{
    numJobs = par("numJobs");
    ...
}
</pre>
<p>
<tt>volatile</tt> parameters need to be re-read every time the value is needed.
For example, a parameter that represents a random packet generation interval
may be used like this:

<pre class="cpp">
void Source::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    ...
    scheduleAt(simTime() + par("interval").doubleValue(), timerMsg);
    ...
}
</pre>
<p>
This code looks up the the parameter by name every time. This lookup
can be avoided by storing the parameter object's pointer in a class variable,
resulting in the following code:

<pre class="cpp">
class Source : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    <a href="../api/classcPar.html">cPar</a> *intervalp;
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
    ...
};

void Source::initialize()
{
    intervalp = &par("interval");
    ...
}

void Source::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    ...
    scheduleAt(simTime() + intervalp-&gt;doubleValue(), timerMsg);
    ...
}
</pre>
<p>

<p><h3><a name="sec157"/>4.5.2 Changing a Parameter's Value</h3>
<a name="sec:simple-modules:setting-parameters"></a>

<p>Parameter values can be changed from the program, during execution.
This is rarely needed, but may be useful for some scenarios.

<p><ul class="note"><b>NOTE</b><br>
    The parameter's type cannot be changed at runtime -- it must
    remain the type declared in the NED file. It is also not possible
    to add or remove module parameters at runtime.
</ul>

<p>The methods to set the parameter value are <tt>setBoolValue()</tt>,
<tt>setLongValue()</tt>, <tt>setStringValue()</tt>,
<tt>setDoubleValue()</tt>, <tt>setXMLValue()</tt>. There are also
overloaded assignment operators for various types including <tt>bool</tt>,
<tt>int</tt>, <tt>long</tt>, <tt>double</tt>, <tt>const char *</tt>, and
<tt><a href="../api/classcXMLElement.html">cXMLElement</a> *</tt>.

<p>To allow a module to be notified about parameter changes, override
its <tt>handleParameterChange()</tt> method, see
<a href="#sec160">[4.5.5]</a>.

<p>
<h3><a name="sec158"/>4.5.3 Further <a href="../api/classcPar.html">cPar</a> Methods</h3>

<p>The parameter's name and type are returned by the <tt>getName()</tt> and
<tt>getType()</tt> methods. The latter returns a value from an enum,
which can be converted to a readable string with the <tt>getTypeName()</tt>
static method. The enum values are <tt>BOOL</tt>, <tt>DOUBLE</tt>, <tt>LONG</tt>,
<tt>STRING</tt> and <tt>XML</tt>; and since the enum is an inner type,
they usually have to be qualified with <tt><a href="../api/classcPar.html">cPar</a>::</tt>.

<p><tt>isVolatile()</tt> returns whether the parameter was declared volatile
in the NED file. <tt>isNumeric()</tt> returns true if the parameter
type is double or long.

<p>The <tt>str()</tt> method returns the parameter's value in a string form.
If the parameter contains an expression, then the string representation
of the expression is returned.

<p>An example usage of the above methods:

<pre class="cpp">
int n = getNumParams();
for (int i=0; i&lt;n; i++)
{
    <a href="../api/classcPar.html">cPar</a>& p = par(i);
    ev &lt;&lt; "parameter: " &lt;&lt; p.getName() &lt;&lt; "\n";
    ev &lt;&lt; "  type:" &lt;&lt; <a href="../api/classcPar.html">cPar</a>::getTypeName(p.getType()) &lt;&lt; "\n";
    ev &lt;&lt; "  contains:" &lt;&lt; p.str() &lt;&lt; "\n";
}
</pre>
<p>
The NED properties of a parameter can be accessed with the <tt>getProperties()</tt>
method that returns a pointer to the <tt><a href="../api/classcProperties.html">cProperties</a></tt> object that stores
the properties of this parameter. Specifically, <tt>getUnit()</tt> returns
the unit of measurement associated with the parameter (<b><tt>@unit</tt></b> property in NED).

<p>Further <tt><a href="../api/classcPar.html">cPar</a></tt> methods and related classes like <tt><a href="../api/classcExpression.html">cExpression</a></tt> and
<tt><a href="../api/classcDynamicExpression.html">cDynamicExpression</a></tt> are used by the NED infrastructure to set up and
assign parameters. They are documented in the <b>API Reference</b>, but
they are normally of little interest to users.

<p>
<h3><a name="sec159"/>4.5.4 Emulating Parameter Arrays</h3>

<p>As of version 4.2, OMNeT++ does not support parameter arrays,
but in practice they can be emulated using string parameters.
One can assign the parameter a string which contains all values
in a textual form (for example, <tt>"0 1.234 3.95 5.467"</tt>), then
parse this string in the simple module.

<p>The <tt><a href="../api/classcStringTokenizer.html">cStringTokenizer</a></tt> class can be quite useful for this
purpose. The constructor accepts a string, which it regards as
a sequence of tokens (words) separated by delimiter characters
(by default, spaces). Then you can either enumerate the tokens
and process them one by one (<tt>hasMoreTokens()</tt>, <tt>nextToken()</tt>),
or use one of the <tt><a href="../api/classcStringTokenizer.html">cStringTokenizer</a></tt> convenience methods to convert
them into a vector of strings (<tt>asVector()</tt>), integers (<tt>asIntVector()</tt>),
or <tt>double</tt>s (<tt>asDoubleVector()</tt>).

<p>The latter methods can be used like this:

<pre class="cpp">
const char *vstr = par("v").stringValue(); // e.g. "aa bb cc";
std::vector&lt;std::string&gt; v = <a href="../api/classcStringTokenizer.html">cStringTokenizer</a>(vstr).asVector();
</pre>
<p>
and

<pre class="cpp">
const char *str = "34 42 13 46 72 41";
std::vector&lt;int&gt; v = <a href="../api/classcStringTokenizer.html">cStringTokenizer</a>().asIntVector();

const char *str = "0.4311 0.7402 0.7134";
std::vector&lt;double&gt; v = <a href="../api/classcStringTokenizer.html">cStringTokenizer</a>().asDoubleVector();
</pre>
<p>
The following example processes the string by enumerating the tokens:

<pre class="cpp">
const char *str = "3.25 1.83 34 X 19.8"; // input

std::vector&lt;double&gt; result;
<a href="../api/classcStringTokenizer.html">cStringTokenizer</a> tokenizer(str);
while (tokenizer.hasMoreTokens())
{
    const char *token = tokenizer.nextToken();
    if (strcmp(token, "X")==0)
        result.push_back(DEFAULT_VALUE);
    else
        result.push_back(atof(token));
}
</pre>
<p>
<h3><a name="sec160"/>4.5.5 handleParameterChange()</h3>
<a name="sec:simple-modules:handleParameterChange"></a>

<p>It is possible for modules to be notified when the value of a
parameter changes at runtime, possibly due to another module
dynamically changing it. A typical use is to re-read the changed
parameter, and update the module's state if needed.

<p>To enable notification, redefine the <tt>handleParameterChange()</tt> method
of the module class. This method will be called back by the
simulation kernel when a module parameter changes, <i>except during
initialization of the given module</i>.

<p><ul class="note"><b>NOTE</b><br>
  Notifications are disabled during the initialization of the component,
  because they would make it very difficult to write components
  that work reliably under all conditions.
  <tt>handleParameterChange()</tt> is usually triggered from another
  module (it does not make much sense for a module to change
  its own parameters), so the relative order of
  <tt>initialize()</tt> and <tt>handleParameterChange()</tt>
  would be effectively determined by the initialization order
  of modules, which generally cannot be relied upon. After the last
  stage of the initialization of the component is finished,
  <tt>handleParameterChange()</tt> is called by the simulation kernel
  with <tt>NULL</tt> as a parameter name. This allows the component
  to react to parameter changes that occurred during the initialization phase.
</ul>

<p>The method signature is the following:

<pre class="cpp">
void handleParameterChange(const char *parameterName);
</pre>
<p>
The following example shows a module that re-reads
its <tt>serviceTime</tt> parameter when its value changes:

<pre class="cpp">
void Queue::handleParameterChange(const char *parname)
{
    if (strcmp(parname, "serviceTime")==0)
        serviceTime = par("serviceTime"); // refresh data member
}
</pre>
<p>
If your code heavily depends on notifications and you would like to
receive notifications during initialization or finalization as well, one
workaround is to explicitly call <tt>handleParameterChange()</tt>
from the <tt>initialize()</tt> or <tt>finish()</tt> function:

<pre class="cpp">
for (int i=0; i&lt;getNumParams(); i++)
    handleParameterChange(par(i).getName());
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  Be extremely careful when changing parameters from inside
  <tt>handleParameterChange()</tt>, because it is easy to accidentally
  create an infinite notification loop.
</ul>

<p>
<h2><a name="sec161"/>4.6 Accessing Gates and Connections</h2>
<a name="sec:simple-modules:gates"></a>

<p><h3><a name="sec162"/>4.6.1 Gate Objects</h3>

<p>Module gates<!--gate--> are represented by <tt><a href="../api/classcGate.html">cGate</a></tt> objects.
Gate objects know to which other gates they are connected, and
what are the channel objects associated with the links.

<p><p class="subheading">Accessing Gates by Name</p>

<p>The <tt><a href="../api/classcModule.html">cModule</a></tt> class has a number of member functions that
deal with gates. You can look up a gate by name using the <tt>gate()</tt>
method:

<pre class="cpp">
<a href="../api/classcGate.html">cGate</a> *outGate = gate("out");
</pre>
<p>
This works for input and output gates. However, when a gate was declared
<tt>inout</tt> in NED, it is actually represented by the simulation kernel
with two gates, so the above call would result in a <i>gate not found</i>
error. The <tt>gate()</tt> method needs to be told whether the input or
the output half of the gate you need. This can be done by appending
the <tt>"$i"</tt> or <tt>"$o"</tt> to the gate name. The following example
retrieves the two gates for the inout gate <tt>"g"</tt>:

<pre class="cpp">
<a href="../api/classcGate.html">cGate</a> *gIn = gate("g$i");
<a href="../api/classcGate.html">cGate</a> *gOut = gate("g$o");
</pre>
<p>
Another way is to use the <tt>gateHalf()</tt> function, which takes
the inout gate's name plus either <tt><a href="../api/classcGate.html">cGate</a>::INPUT</tt> or <tt><a href="../api/classcGate.html">cGate</a>::OUTPUT</tt>:

<pre class="cpp">
<a href="../api/classcGate.html">cGate</a> *gIn = gateHalf("g", <a href="../api/classcGate.html">cGate</a>::INPUT);
<a href="../api/classcGate.html">cGate</a> *gOut = gateHalf("g", <a href="../api/classcGate.html">cGate</a>::OUTPUT);
</pre>
<p>
These methods throw an error if the gate does not exist, so they cannot
be used to determine whether the module has a particular gate.
For that purpose there is a <tt>hasGate()</tt> method. An example:

<pre class="cpp">
if (hasGate("optOut"))
   send(new <a href="../api/classcMessage.html">cMessage</a>(), "optOut");
</pre>
<p>
A gate can also be identified and looked up by a numeric gate ID.
You can get the ID from the gate itself (<tt>getId()</tt> method),
or from the module by gate name (<tt>findGate()</tt> method).
The <tt>gate()</tt> method also has an overloaded variant which
returns the gate from the gate ID.

<pre class="cpp">
int gateId = gate("in")-&gt;getId();  // or:
int gateId = findGate("in");
</pre>
<p>
As gate IDs are more useful with gate vectors, we'll cover them
in detail in a later section.

<p>
<p class="subheading">Gate Vectors</p>

<p>Gate vectors possess one <tt><a href="../api/classcGate.html">cGate</a></tt> object per element.
To access individual gates in the vector, you need to call
the <tt>gate()</tt> function with an additional <i>index</i>
parameter. The index should be between zero and <i>size</i>-1.
The size of the gate vector can be read with the <tt>gateSize()</tt>
method. The following example iterates through all elements in the
gate vector:

<pre class="cpp">
for (int i=0; i&lt;gateSize("out"); i++) {
    <a href="../api/classcGate.html">cGate</a> *gate = gate("out", i);
    //...
}
</pre>
<p>
A gate vector cannot have &#8220;holes&#8221; in it; that is, <tt>gate()</tt>
never returns <tt>NULL</tt> or throws an error if the gate vector exists
and the index is within bounds.

<p>For inout gates, <tt>gateSize()</tt> may be called with or without
the <tt>"$i"</tt>/<tt>"$o"</tt> suffix, and returns the same number.

<p>The <tt>hasGate()</tt> method may be used both with and without an
index, and they mean two different things: without an index it tells
the existence of a gate vector with the given name, regardless of its
size (it returns <tt>true</tt> for an existing vector even if its size
is currently zero!); with an index it also examines whether the index
is within the bounds.

<p>
<p class="subheading">Gate IDs</p>

<p>A gate can also be accessed by its ID. A very important property of gate IDs
is that they are <i>contiguous</i> within a gate vector, that is,
the ID of a gate <tt>g[k]</tt> can be calculated as the ID of <tt>g[0]</tt> plus <i>k</i>.
This allows you to efficiently access any gate in a gate vector, because
retrieving a gate by ID is more efficient than by name and index.
The index of the first gate can be obtained with <tt>gate("out",0)-&gt;getId()</tt>,
but it is better to use a dedicated method, <tt>gateBaseId()</tt>,
because it also works when the gate vector size is zero.

<p>Two further important properties of gate IDs: they are <i>stable</i>
and <i>unique</i> (within the module). By stable we mean that the ID
of a gate never changes; and by unique we not only mean that at any
given time no two gates have the same IDs, but also that IDs of deleted
gates do not get reused later, so gate IDs are unique in the lifetime
of a simulation run.

<p><ul class="note"><b>NOTE</b><br>
    OMNeT++ version earlier than 4.0 did not have these guarantees -- resizing
    a gate vector could cause its ID range to be relocated, if it
    would have overlapped with the ID range of other gate vectors.
    OMNeT++ 4.x solves the same problem by interpreting the gate ID
    as a bitfield, basically containing bits that identify the gate name,
    and other bits that hold the index. This also means that the theoretical
    upper limit for a gate size is now smaller, albeit it is still
    big enough so that it can be safely ignored for practical purposes.
</ul>

<p>The following example iterates through a gate vector, using IDs:

<pre class="cpp">
int baseId = gateBaseId("out");
int size = gateSize("out");
for (int i=0; i&lt;size; i++) {
    <a href="../api/classcGate.html">cGate</a> *gate = gate(baseId + i);
    //...
}
</pre>
<p>

<p><p class="subheading">Enumerating All Gates</p>

<p>If you need to go through all gates of a module, there are
two possibilities. One is invoking the <tt>getGateNames()</tt> method
that returns the names of all gates and gate vectors the module
has; then you can call <tt>isGateVector(name)</tt> to determine
whether individual names identify a scalar gate or a gate vector;
then gate vectors can be enumerated by index. Also, for inout
gates <tt>getGateNames()</tt> returns the base name without the
<tt>"$i"</tt>/<tt>"$o"</tt> suffix, so the two directions
need to be handled separately. The <tt>gateType(name)</tt> method
can be used to test whether a gate is inout, input or output
(it returns <tt><a href="../api/classcGate.html">cGate</a>::INOUT</tt>, <tt><a href="../api/classcGate.html">cGate</a>::INPUT</tt>, or
<tt><a href="../api/classcGate.html">cGate</a>::OUTPUT</tt>).

<p>Clearly, the above solution can be quite difficult. An alternative is to use
the <tt>GateIterator</tt> class provided by <tt><a href="../api/classcModule.html">cModule</a></tt>.
It goes like this:

<pre class="cpp">
for (<a href="../api/classcModule.html">cModule</a>::GateIterator i(this); !i.end(); i++) {
    <a href="../api/classcGate.html">cGate</a> *gate = i();
    ...
}
</pre>
<p>
Where <tt>this</tt> denotes the module whose gates are being enumerated
(it can be replaced by any <tt><a href="../api/classcModule.html">cModule</a> *</tt> variable).

<p><ul class="note"><b>NOTE</b><br>
    In earlier OMNeT++ versions, gate IDs used to be small integers, so
    it made sense to iterate over all gates of a module by enumerating
    all IDs from zero to a maximum, skipping the holes (<tt>NULL</tt>s).
    This is no longer the case with OMNeT++ 4.0 and later versions.
    Moreover, the <tt>gate()</tt> method now throws an error when called
    with an invalid ID, and not just returns <tt>NULL</tt>.
</ul>

<p>
<p class="subheading">Adding and Deleting Gates</p>

<p>Although rarely needed, it is possible to add and remove gates during
simulation. You can add scalar gates and gate vectors, change the size of
gate vectors, and remove scalar gates and whole gate vectors.
It is not possible to remove individual random gates from a gate vector,
to remove one half of an inout gate (e.g. <tt>"gate$o"</tt>), or to set
different gate vector sizes on the two halves of an inout gate vector.

<p>The <tt><a href="../api/classcModule.html">cModule</a></tt> methods for adding and removing gates are
<tt>addGate(name,type,isvector=false)</tt> and <tt>deleteGate(name)</tt>.
Gate vector size can be changed by using <tt>setGateSize(name,size)</tt>.
None of these methods accept <tt>"$i"</tt> / <tt>"$o"</tt> suffix in gate names.

<p><ul class="note"><b>NOTE</b><br>
    When memory efficiency is of concern, it is useful to know that
    in OMNeT++ 4.0 and later, a gate vector will consume significantly less
    memory than the same number of individual scalar gates.
</ul>

<p>
<p class="subheading"><a href="../api/classcGate.html">cGate</a> Methods</p>

<p>The <tt>getName()</tt> method of <tt><a href="../api/classcGate.html">cGate</a></tt> returns the name of the
gate or gate vector without the index. If you need a string that contains the gate index
as well, <tt>getFullName()</tt> is what you want. If you also want to
include the hierarchical name of the owner module, call <tt>getFullPath()</tt>.

<p>The <tt>getType()</tt> method of <tt><a href="../api/classcGate.html">cGate</a></tt> returns the gate type,
either <tt><a href="../api/classcGate.html">cGate</a>::INPUT</tt> or <tt><a href="../api/classcGate.html">cGate</a>::OUTPUT</tt>. (It cannot return
<tt><a href="../api/classcGate.html">cGate</a>::INOUT</tt>, because an inout gate is represented by a pair
of <tt><a href="../api/classcGate.html">cGate</a></tt>s.)

<p>If you have a gate that represents half of an inout gate (that is,
<tt>getName()</tt> returns something like <tt>"g$i"</tt> or <tt>"g$o"</tt>), you
can split the name with the <tt>getBaseName()</tt> and
<tt>getNameSuffix()</tt> methods. <tt>getBaseName()</tt> method returns the
name without the <tt>$i</tt>/<tt>$o</tt> suffix; and <tt>getNameSuffix()</tt>
returns just the suffix (including the dollar sign). For normal gates,
<tt>getBaseName()</tt> is the same as <tt>getName()</tt>, and
<tt>getNameSuffix()</tt> returns the empty string.

<p>The <tt>isVector()</tt>, <tt>getIndex()</tt>, <tt>getVectorSize()</tt> speak
for themselves; <tt>size()</tt> is an alias to <tt>getVectorSize()</tt>. For
non-vector gates, <tt>getIndex()</tt> returns 0 and <tt>getVectorSize()</tt>
returns 1.

<p>The <tt>getId()</tt> method returns the gate ID (not to be confused
with the gate index).

<p>The <tt>getOwnerModule()</tt> method returns the module the gate object
belongs to.

<p>To illustrate these methods, we expand the gate iterator example
to print some information about each gate:

<pre class="cpp">
for (<a href="../api/classcModule.html">cModule</a>::GateIterator i(this); !i.end(); i++) {
    <a href="../api/classcGate.html">cGate</a> *gate = i();
    ev &lt;&lt; gate-&gt;getFullName() &lt;&lt; ": ";
    ev &lt;&lt; "id=" &lt;&lt; gate-&gt;getId() &lt;&lt; ", ";
    if (!gate-&gt;isVector())
        ev &lt;&lt; "scalar gate, ";
    else
        ev &lt;&lt; "gate " &lt;&lt; gate-&gt;getIndex()
           &lt;&lt; " in vector " &lt;&lt; gate-&gt;getName()
           &lt;&lt; " of size " &lt;&lt; gate-&gt;getVectorSize() &lt;&lt; ", ";
    ev &lt;&lt; "type:" &lt;&lt; <a href="../api/classcGate.html">cGate</a>::getTypeName(gate-&gt;getType());
    ev &lt;&lt; "\n";
}
</pre>
<p>
There are further <tt><a href="../api/classcGate.html">cGate</a></tt> methods to access and manipulate
the connection(s) attached to the gate; they will be covered in the
following sections.

<p>
<h3><a name="sec163"/>4.6.2 Connections</h3>
<a name="sec:simple-modules:connections"></a>

<p>Simple module gates have normally one connection attached. Compound module
gates, however, need to be connected both inside and outside of the
module to be useful. A series of connections (joined with compound
module gates) is called a <i>connection path</i> or just path.
A path is directed, and it normally starts at an output gate of
a simple module, ends at an input gate of a simple module,
and passes through several compound module gates.

<p>Every <tt><a href="../api/classcGate.html">cGate</a></tt> object contains pointers to the previous gate
and the next gate in the path (returned by the <tt>getPreviousGate()</tt>
and <tt>getNextGate()</tt> methods), so a path can be thought of as
a double-linked list.

<p>The use of the <i>previous gate</i> and <i>next gate</i> pointers
with various gate types is illustrated on figure
<a href="#fig:ch-simple-modules:gates">below</a>.

<p>
<center>
<img src="simple-gates.png">
<center><i>Figure: (a) simple module output gate, (b) compound module output gate,
         (c) simple module input gate, (d) compound module input gate</i></center>
<a name="fig:ch-simple-modules:gates"></a>
</center>

<p>
The start and end gates of the path can be found with the <tt>getPathStartGate()</tt>
and <tt>getPathEndGate()</tt> methods, which simply follow the <i>previous gate</i> and
<i>next gate</i> pointers, respectively, until they are <tt>NULL</tt>.

<p>The <tt>isConnectedOutside()</tt> and <tt>isConnectedInside()</tt> methods
return whether a gate is connected on the outside or on the inside. They
examine either the <i>previous</i> or the <i>next</i> pointer, depending on the
gate type (input or output). For example, an output gate is <i>connected outside</i>
if the <i>next</i> pointer is non-<tt>NULL</tt>; the same function for an input gate
checks the <i>previous</i> pointer. Again, see figure <a href="#fig:ch-simple-modules:gates">below</a>
for an illustration.

<p>The <tt>isConnected()</tt> method is a bit different: it returns true if the gate
is <i>fully</i> connected, that is, for a compound module gate
both inside and outside, and for a simple module gate, outside.

<p>The following code prints the name of the gate a simple module gate is
connected to:

<pre class="cpp">
<a href="../api/classcGate.html">cGate</a> *gate = gate("somegate");
<a href="../api/classcGate.html">cGate</a> *otherGate = gate-&gt;getType()==<a href="../api/classcGate.html">cGate</a>::OUTPUT ? gate-&gt;getNextGate() :
                                                    gate-&gt;getPreviousGate();
if (otherGate)
  ev &lt;&lt; "gate is connected to: " &lt;&lt; otherGate-&gt;getFullPath() &lt;&lt; endl;
else
  ev &lt;&lt; "gate not connected" &lt;&lt; endl;
</pre>
<p>

<p><h3><a name="sec164"/>4.6.3 The Connection's Channel</h3>

<p>The channel object associated with a connection is accessible by
a pointer stored at the source gate of the connection. The pointer
is returned by the <tt>getChannel()</tt> method of the gate:

<pre class="cpp">
<a href="../api/classcChannel.html">cChannel</a> *channel = gate-&gt;getChannel();
</pre>
<p>
The result may be <tt>NULL</tt>, that is, a connection may not have
an associated channel object.

<p>If you have a channel pointer, you can get back its source gate
with the <tt>getSourceGate()</tt> method:

<pre class="cpp">
<a href="../api/classcGate.html">cGate</a> *gate = channel-&gt;getSourceGate();
</pre>
<p>
<tt><a href="../api/classcChannel.html">cChannel</a></tt> is just an abstract base class for channels, so
to access details of the channel you might need to cast the resulting
pointer into a specific channel class, for example <tt><a href="../api/classcDelayChannel.html">cDelayChannel</a></tt>
or <tt><a href="../api/classcDatarateChannel.html">cDatarateChannel</a></tt>.

<p>Another specific channel type is <tt><a href="../api/classcIdealChannel.html">cIdealChannel</a></tt>, which basically
does nothing: it acts as if there was no channel object assigned to the
connection. OMNeT++ sometimes transparently inserts a <tt><a href="../api/classcIdealChannel.html">cIdealChannel</a></tt>
into a channel-less connection, for example to hold the display string
associated with the connection.

<p>Often you are not really interested in a specific connection's channel, but
rather in the <i>transmission channel</i> (see
<a href="#sec171">[4.7.6]</a>) of the connection path that
starts at a specific output gate. The transmission channel can be found by
following the connection path until you find a channel whose
<tt>isTransmissionChannel()</tt> method returns <tt>true</tt>, but
<tt><a href="../api/classcGate.html">cGate</a></tt> has a convenience method for this, named
<tt>getTransmissionChannel()</tt>. An example usage:

<pre class="cpp">
<a href="../api/classcChannel.html">cChannel</a> *txChan = gate("ppp$o")-&gt;getTransmissionChannel();
</pre>
<p>
A complementer method to <tt>getTransmissionChannel()</tt> is
<tt>getIncomingTransmissionChannel()</tt>; it is usually invoked
on input gates, and searches the connection path in reverse direction.

<pre class="cpp">
<a href="../api/classcChannel.html">cChannel</a> *incomingTxChan = gate("ppp$i")-&gt;getIncomingTransmissionChannel();
</pre>
<p>
Both methods throw an error if no transmission channel is found. If this
is not suitable, use the similar <tt>findTransmissionChannel()</tt> and
<tt>findIncomingTransmissionChannel()</tt> methods that simply return
<tt>NULL</tt> in that case.

<p>Channels are covered in more detail in section <a href="#sec173">[4.8]</a>.

<p>
<h2><a name="sec165"/>4.7 Sending and Receiving Messages</h2>
<a name="sec:simple-modules:sending-and-receiving"></a>

<p>On an abstract level, an OMNeT++ simulation model is a set of
simple modules that communicate with each other via message passing.
The essence of simple modules is that they create, send, receive,
store, modify, schedule and destroy messages -- the rest of OMNeT++ exists
to facilitate this task, and collect statistics
about what was going on.

<p>Messages in OMNeT++ are instances of the <tt><a href="../api/classcMessage.html">cMessage</a></tt> class or one of
its subclasses. Network packets are represented with <tt><a href="../api/classcPacket.html">cPacket</a></tt>,
which is also subclassed from <tt><a href="../api/classcMessage.html">cMessage</a></tt>. Message objects are
created using the C++ <tt>new</tt> operator, and destroyed using the
<tt>delete</tt> operator when they are no longer needed.

<p>Messages are described in detail in chapter <a href="#sec202">[5]</a>.
At this point, all we need to know about them is that they are
referred to as <tt><a href="../api/classcMessage.html">cMessage</a> *</tt> pointers. In the examples below,
messages will be created with <tt>new <a href="../api/classcMessage.html">cMessage</a>("foo")</tt> where
<tt>"foo"</tt> is a descriptive message name, used for visualization
and debugging purposes.

<p>
<h3><a name="sec166"/>4.7.1 Self-Messages</h3>
<a name="sec:ch-simple-modules:self-messages"></a>

<p>Nearly all simulation models need to schedule future events in order
to implement timers, timeouts, delays, etc. Some typical examples:

<p><ul>
  <li> A source module that periodically creates and sends messages
    needs to schedule the next send after every send operation;
  <li> A server which processes jobs from a queue needs to start
    a timer every time it begins processing a job. When the timer
    expires, the finished job can be sent out, and a new job may
    start processing;
  <li> When a packet is sent by a communications protocol that employs
    retransmission, it needs to schedule a timeout so that the packet
    can be retransmitted if no acknowledge arrives within a certain
    amount of time.
</ul>

<p>In OMNeT++, you solve such tasks by letting the simple module send a message
to itself; the message would be delivered to the simple module at a later
point of time. Messages used this way are called
<i>self-messages</i><!--self-message-->, and the module class has
special methods for them that allow for implementing self-messages without
gates and connections.

<p><p class="subheading">Scheduling an Event</p>

<p>The module can send a message to itself using the <tt>scheduleAt()</tt> function.
<tt>scheduleAt()</tt> accepts an <i>absolute</i> simulation time,
usually calculated as <tt>simTime()</tt>+<i>delta</i>:

<pre class="cpp">
scheduleAt(absoluteTime, msg);
scheduleAt(simTime()+delta, msg);
</pre>
<p>
Self-messages are delivered to the module in the same way as other
messages (via the usual receive calls or <tt>handleMessage()</tt>);
the module may call the <tt>isSelfMessage()</tt> member of any received
message to determine if it is a self-message.

<p>You can determine whether a message is currently in the FES<!--FES-->
by calling its <tt>isScheduled()</tt> member function.

<p><p class="subheading">Cancelling an Event</p>

<p>Scheduled self-messages can be cancelled<!--self-message!cancelling-->
<!--message!cancelling--> (i.e. removed from the FES<!--FES-->).
This feature facilitates implementing timeouts.

<pre class="cpp">
cancelEvent(msg);
</pre>
<p>
The <tt>cancelEvent()</tt> function takes a pointer to the message to
be cancelled, and also returns the same pointer. After having it
cancelled, you may delete the message or reuse it in subsequent
<tt>scheduleAt()</tt> calls. <tt>cancelEvent()</tt> has no effect if
the message is not scheduled at that time.

<p>There is also a convenience method called <tt>cancelAndDelete()</tt>
implemented as <tt>if (msg!=NULL) delete cancelEvent(msg)</tt>;
this method is primarily useful for writing destructors.

<p>The following example shows how to implement a timeout in a simple
imaginary stop-and-wait protocol. The code utilizes a <tt>timeoutEvent</tt>
module class data member that stores the pointer of the <tt><a href="../api/classcMessage.html">cMessage</a></tt> used
as self-message, and compares it to the pointer of the received message
to identify whether a timeout has occurred.

<pre class="cpp">
void Protocol::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    if (msg == timeoutEvent) {
        // timeout expired, re-send packet and restart timer
        send(currentPacket-&gt;dup(), "out");
        scheduleAt(simTime() + timeout, timeoutEvent);
    }
    else if (...) {  // if acknowledgement received
        // cancel timeout, prepare to send next packet, etc.
        cancelEvent(timeoutEvent);
        ...
    }
    else {
       ...
    }
}
</pre>
<p>

<p><p class="subheading">Re-scheduling an Event</p>

<p>If you want to reschedule an event which is currently scheduled to a different
simulation time, first you have to cancel it using <tt>cancelEvent()</tt>.
This is shown in the following example code:

<pre class="cpp">
if (msg-&gt;isScheduled())
    cancelEvent(msg);
scheduleAt(simTime() + delay, msg);
</pre>
<p>

<p><h3><a name="sec167"/>4.7.2 Sending Messages</h3>

<p>Once created, a message object can be sent through an
output gate<!--output!gate--> using one of the following functions:

<pre class="cpp">
send(<a href="../api/classcMessage.html">cMessage</a> *msg, const char *gateName, int index=0);
send(<a href="../api/classcMessage.html">cMessage</a> *msg, int gateId);
send(<a href="../api/classcMessage.html">cMessage</a> *msg, <a href="../api/classcGate.html">cGate</a> *gate);
</pre>
<p>
In the first function, the argument <tt>gateName</tt> is the name of
the gate the message has to be sent through. If this gate is
a vector gate, <tt>index</tt> determines though which particular output
gate this has to be done; otherwise, the <tt>index</tt> argument is not
needed.

<p>The second and third functions use the gate ID and the pointer to the gate
object. They are faster than the first one because they don't have to
search for the gate by name.

<p>Examples:

<pre class="cpp">
send(msg, "out");
send(msg, "outv", i); // send via a gate in a gate vector
</pre>
<p>
To send via an inout gate, remember that an inout gate is an input and an
output gate glued together, and the two halves can be identified with the
<tt>$i</tt> and <tt>$o</tt> name suffixes. Thus, for sending you need to specify
the gate name with the <tt>$o</tt> suffix:

<pre class="cpp">
send(msg, "g$o");
send(msg, "g$o", i); // if "g[]" is a gate vector
</pre>
<p>

<p><h3><a name="sec168"/>4.7.3 Broadcasts and Retransmissions</h3>

<p>When you implement broadcasts or retransmissions, two frequently
occurring tasks in protocol simulation, you might feel tempted
to use the same message in multiple <tt>send()</tt> operations.
Do not do it -- you cannot send the same message object multiple times.
Instead, duplicate the message object.

<p>Why? A message is like any real world object -- it cannot be at two places
at the same time. Once you've sent it, the message object no longer belongs
to the module: it is taken over by the simulation kernel, and will
eventually be delivered to the destination module. The sender module should
not even refer to its pointer any more. Once the message arrived in the
destination module, that module will have full authority over it -- it can
send it on, destroy it immediately, or store it for further handling. The
same applies to messages that have been scheduled -- they belong to the
simulation kernel until they are delivered back to the module.

<p>To enforce the rules above, all message sending functions check that you
actually own the message you are about to send. If the message is in
another module, currently scheduled or in a queue, etc., you'll get a
runtime error: <i>not owner of message</i>.
  <br><ul><font size=-1>[The feature does not increase runtime overhead significantly, because
  it uses the object ownership<!--ownership--> management (described in
  Section <a href="#sec309">[7.13]</a>);
  it merely checks that the owner of the message is the module that
  wants to send it.]</font></ul>

<p>
<p class="subheading">Broadcasting Messages</p>

<p>In your model, you may need to broadcast a message to several destinations.
Broadcast can be implemented in a simple module by sending out copies
of the same message, for example on every gate of a gate vector.
As described above, you cannot use the same message pointer for
in all <tt>send()</tt> calls -- what you have to do instead is
create copies (duplicates) of the message object and send them.

<p>Example:

<pre class="cpp">
for (int i=0; i&lt;n; i++)
{
    <a href="../api/classcMessage.html">cMessage</a> *copy = msg-&gt;dup();
    send(copy, "out", i);
}
delete msg;
</pre>
<p>
You might have noticed that copying the message for the last gate is
redundant: we can just send out the original message there.
Also, we can utilize gate IDs to avoid looking up the gate by name
for each send operation. We can exploit the fact that the ID of gate
<i>k</i> in a gate vector can be produced as <i>baseID + k</i>.
The optimized version of the code looks like this:

<pre class="cpp">
int outGateBaseId = gateBaseId("out");
for (int i=0; i&lt;n; i++)
    send(i==n-1 ? msg : msg-&gt;dup(), outGateBaseId+i);
</pre>
<p>

<p><p class="subheading">Retransmissions</p>

<p>Many communication protocols involve retransmissions of packets (frames).
When implementing retransmissions, you cannot just hold a pointer
to the same message object and send it again and again -- you'd get
the <i>not owner of message</i> error on the first resend.

<p>Instead, for (re)transmission, you should create and
send copies of the message, and retain the original.
When you are sure there will not be any more retransmission,
you can delete the original message.

<p>Creating and sending a copy:

<pre class="cpp">
// (re)transmit packet:
<a href="../api/classcMessage.html">cMessage</a> *copy = packet-&gt;dup();
send(copy, "out");
</pre>
<p>
and finally (when no more retransmissions will occur):

<pre class="cpp">
delete packet;
</pre>
<p>

<p><h3><a name="sec169"/>4.7.4 Delayed Sending</h3>
<a name="sec:simple-modules:delayed-sending"></a>

<p>Sometimes it is necessary for module to hold a message for some time interval,
and then send it. This can be achieved with self-messages, but there is a
more straightforward method: delayed sending<!--delayed sending-->. The
following methods are provided for delayed sending:

<pre class="cpp">
sendDelayed(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, const char *gateName, int index);
sendDelayed(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, int gateId);
sendDelayed(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, <a href="../api/classcGate.html">cGate</a> *gate);
</pre>
<p>
The arguments are the same as for <tt>send()</tt>, except for the extra
<i>delay</i> parameter. The delay value must be non-negative.
The effect of the function is similar to as if the module
had kept the message for the delay interval and sent it afterwards;
even the <i>sending time</i> timestamp of the message will be set to
the current simulation time plus <i>delay</i>.

<p>A example call:

<pre class="cpp">
sendDelayed(msg, 0.005, "out");
</pre>
<p>
The <tt>sendDelayed()</tt> function does not internally perform a
<tt>scheduleAt()</tt> followed by a <tt>send()</tt>, but rather it computes
everything about the message sending up front, including the arrival time
and the target module. This has two consequences. First,
<tt>sendDelayed()</tt> is more efficient than a <tt>scheduleAt()</tt>
followed by a <tt>send()</tt> because it eliminates one event. The second, less
pleasant consequence is that changes in the connection path during the
delay will <i>not</i> be taken into account (because everything is
calculated in advance, before the changes take place).

<p><ul class="note"><b>NOTE</b><br>
  The fact that <tt>sendDelayed()</tt> computes the message arrival
  information up front does not make a difference if the model is static,
  but may lead to surprising results if the model changes in time.
  For example, if a connection in the path gets deleted, disabled, or
  reconnected to another module during the delay period, the message
  will still be delivered to the original module as if nothing happened.

<p>  Therefore, despite its performance advantage, you should think twice
  before using <tt>sendDelayed()</tt> in a simulation model. It may have
  its place in a one-shot simulation model that you know is static,
  but it certainly should be avoided in reusable modules that need to
  work correctly in a wide variety of simulation models.
</ul>

<p>
<h3><a name="sec170"/>4.7.5 Direct Message Sending</h3>
<a name="sec:simple-modules:direct-sending"></a>

<p>At times it is covenient to be able to send a message directly to an input
gate of another module. The <tt>sendDirect()</tt> function is provided for
this purpose.

<p>This function has several flavors. The first set of <tt>sendDirect()</tt>
functions accept a message and a target gate; the latter can be specified
in various forms:

<pre class="cpp">
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, <a href="../api/classcModule.html">cModule</a> *mod, int gateId)
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, <a href="../api/classcModule.html">cModule</a> *mod, const char *gateName, int index=-1)
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, <a href="../api/classcGate.html">cGate</a> *gate)
</pre>
<p>
An example for direct sending:

<pre class="cpp">
<a href="../api/classcModule.html">cModule</a> *targetModule = getParentModule()-&gt;getSubmodule("node2");
sendDirect(new <a href="../api/classcMessage.html">cMessage</a>("msg"), targetModule, "in");
</pre>
<p>
At the target module, there is no difference between messages received
directly and those received over connections.

<p>The target gate must be an unconnected gate; in other words,
modules must have dedicated gates to be able to receive messages
sent via <tt>sendDirect()</tt>. You cannot have a gate which receives
messages via both connections and <tt>sendDirect()</tt>.

<p>It is recommended to tag gates dedicated for receiving messages via
<tt>sendDirect()</tt> with the <tt>@directIn</tt> property in the module's NED
declaration. This will cause OMNeT++ not to complain that the gate is not
connected in the network or compound module where the module is used.

<p>An example:

<pre class="ned">
simple Radio {
    gates:
        input radioIn @directIn; // for receiving air frames
}
</pre>
<p>
The target module is usually a simple module, but it can also be a compound
module. The message will follow the connections that start at the target
gate, and will be delivered to the module at the end of the path -- just as
with normal connections. The path must end in a simple module.

<p>It is even permitted to send to an output gate, which will also cause the
message to follow the connections starting at that gate.
This can be useful, for example, when several submodules are sending
to a single output gate of their parent module.

<p>A second set of <tt>sendDirect()</tt> methods accept a propagation
delay and a transmission duration as parameters as well:

<pre class="cpp">
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration,
           <a href="../api/classcModule.html">cModule</a> *mod, int gateId)
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration,
           <a href="../api/classcModule.html">cModule</a> *mod, const char *gateName, int index=-1)
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration,
           <a href="../api/classcGate.html">cGate</a> *gate)
</pre>
<p>
The transmission duration parameter is important when the message is also
a packet (instance of <tt><a href="../api/classcPacket.html">cPacket</a></tt>). For messages that are not packets
(not subclassed from <tt><a href="../api/classcPacket.html">cPacket</a></tt>), the duration parameter
is ignored.

<p>If the message is a packet, the duration will be written into the packet,
and can be read by the receiver with the <tt>getDuration()</tt> method of
the packet.

<p>The receiver module can choose whether it wants the simulation kernel
to deliver the packet object to it at the start or at the end of the
reception. The default is the latter; the module can change it by calling
<tt>setDeliverOnReceptionStart()</tt> on the final input gate, that is, on
<tt>targetGate-&gt;getPathEndGate()</tt>.

<p>
<h3><a name="sec171"/>4.7.6 Packet Transmissions</h3>
<a name="sec:simple-modules:packet-transmission"></a>

<p>When a message is sent out on a gate, it usually travels through
a series of connections until it arrives at the destination module.
We call this series of connections a <i>connection path</i>.

<p>Several connections in the path may have an associated channel,
but there can be only one channel per path that models nonzero
transmission duration. This restriction is enforced by the simulation
kernel. This channel is called the <i>transmission channel</i>.
  <br><ul><font size=-1>[Moreover, if <tt>sendDirect()</tt> with a nonzero duration
  was used to send the packet to the start gate of the path,
  then the path cannot have a transmission channel at all.
  The point is that the a transission duration must be unambiguous.]</font></ul>

<p><ul class="note"><b>NOTE</b><br>
  In practice, this means that there can be only one <tt>ned.DatarateChannel</tt>
  in the path. Note that unnamed channels with a <tt>datarate</tt> parameter
  also map to <tt>ned.DatarateChannel</tt>.
</ul>

<p><p class="subheading">Transmitting a Packet</p>

<p>Packets may only be sent when the transmission channel is idle.
This means that after each transmission, the sender module needs
to wait until the channel has finished transmitting before it can
send another packet.

<p>You can get a pointer to the transmission channel by calling the
<tt>getTransmissionChannel()</tt> method on the output gate.
The channel's <tt>isBusy()</tt> and <tt>getTransmissionFinishTime()</tt>
methods can tell you whether a channel is currently transmitting,
and when the transmission is going to finish. (When the latter is
less or equal the current simulation time, the channel is free.)
If the channel is currently busy, sending needs to be postponed:
the packet can be stored in a queue, and a timer (self-message) can be
scheduled for the time when the channel becomes empty.

<p>A code example to illustrate the above process:

<pre class="cpp">
<a href="../api/classcPacket.html">cPacket</a> *pkt = ...; // packet to be transmitted
<a href="../api/classcChannel.html">cChannel</a> *txChannel = gate("out")-&gt;getTransmissionChannel();
simtime_t txFinishTime = txChannel-&gt;getTransmissionFinishTime();
if (txFinishTime &lt;= simTime())
{
    // channel free; send out packet immediately
    send(pkt, "out");
}
else
{
    // store packet and schedule timer; when the timer expires,
    // the packet should be removed from the queue and sent out
    txQueue.insert(pkt);
    scheduleAt(txFinishTime, endTxMsg);
}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  If there is a channel with a propagation delay in
  the path before the transmission channel, the delay should be manually
  substracted from the value returned by <tt>getTransmissionFinishTime()</tt>!
  The same applies to <tt>isBusy()</tt>: it tells whether the channel is
  currently busy, and not whether it will be busy when a packet that you send
  gets there. It is therefore advisable that you never use propagation delays
  in front of a transmission channel in a path.
</ul>

<p>The <tt>getTransmissionChannel()</tt> method searches the connection path each
time it is called. If performance is important, it is recommended that you
obtain the transmission channel pointer once, and cache it. When the network topology
changes, the cached channel pointer needs to be updated; section
<a href="#sec194">[4.14.3]</a> describes the mechanism that can
be used to get notifications about topology changes.

<p><p class="subheading">Receiving a Packet</p>

<p>As a result of error modeling in the channel, the packet may arrive
with the <i>bit error</i> flag set (<tt>hasBitError() method</tt>.
It is the receiver module's responsibility to examine this flag
and take appropriate action (i.e. discard the packet).

<p>Normally the packet object gets delivered to the destination module
at the simulation time that corresponds to finishing the reception
of the message (ie. the arrival of its last bit). However, the receiver
module may change this by &#8220;reprogramming&#8221; the receiver gate with
the <tt>setDeliverOnReceptionStart()</tt> method:

<pre class="cpp">
gate("in")-&gt;setDeliverOnReceptionStart(true);
</pre>
<p>
This method may only be called on simple module input gates, and it
instructs the simulation kernel to deliver packets arriving through
that gate at the simulation time that corresponds to the
beginning of the reception process.
<tt>getDeliverOnReceptionStart()</tt> only needs to be called once,
so it is usually done in the <tt>initialize()</tt> method of the module.

<p>
<center>
<img src="transmission.png">
<center><i>Figure: Packet transmission</i></center>
<a name="fig:ch-simple-modules:transmission"></a>
</center>

<p>
When a packet is delivered to the module, the packet's
<tt>isReceptionStart()</tt> method can be called to determine
whether it corresponds to the start or end of the reception
process (it should be the same as the <tt>getDeliverOnReceptionStart()</tt>
flag of the input gate), and <tt>getDuration()</tt> returns the transmission
duration.

<p>The following example code prints the start and end times of a packet reception:

<pre class="cpp">
simtime_t startTime, endTime;
if (pkt-&gt;isReceptionStart())
{
    // gate was reprogrammed with setDeliverOnReceptionStart(true)
    startTime = pkt-&gt;getArrivalTime(); // or: simTime();
    endTime = startTime + pkt-&gt;getDuration();
}
else
{
    // default case
    endTime = pkt-&gt;getArrivalTime(); // or: simTime();
    startTime = endTime - pkt-&gt;getDuration();
}
ev &lt;&lt; "interval: " &lt;&lt; startTime &lt;&lt; ".." &lt;&lt; endTime &lt;&lt; "\n";
</pre>
<p>
Note that this works with wireless connections (<tt>sendDirect()</tt>)
as well; there, the duration is an argument to the <tt>sendDirect()</tt>
call.

<p><p class="subheading">Aborting Transmissions</p>

<p>Sometimes you want the sender to abort transmission. The support OMNeT++
provides for this task is the <tt>forceTransmissionFinishTime()</tt> method
of channels. This method forcibly overwrites the <i>transmissionFinishTime</i>
member of the channel with the given value, allowing the sender to transmit
another packet without raising the <i>&#8220;channel is currently busy&#8221;</i>
error. The receiving party needs to be notified about the aborted transmission
by some user-defined means, for example by sending another packet
or an out-of-band message.

<p><p class="subheading">Implementation of Message Sending</p>

<p>Message sending is implemented like this: the arrival time<!--arrival time-->
and the bit error<!--bit error--> flag of a message are calculated right inside
the <tt>send()</tt> call, then the message is inserted into the FES<!--FES-->
with the calculated arrival time. The message does <i>not</i> get scheduled
individually for each link. This implementation was chosen because of its
run-time efficiency.

<p><ul class="note"><b>NOTE</b><br>
   The consequence of this implementation is that any change in the
   channel's parameters (delay, data rate, bit error rate, etc.) will only affect
   messages <i>sent</i> after the change. Messages already underway will not
   be influenced by the change.

<p>   This is not a huge problem in practice, but if it is important to model
   channels with changing parameters, the solution is to insert simple modules
   into the path to ensure strict scheduling.
</ul>

<p>
<h3><a name="sec172"/>4.7.7 Receiving Messages with activity()</h3>

<p><p class="subheading">Receiving Messages</p>
<a name="sec:simple-modules:receiving-messages"></a>

<p><tt>activity()</tt>-based modules receive messages with the <tt>receive()</tt>
method of <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>. <tt>receive()</tt> cannot be used with
<tt>handleMessage()</tt>-based modules.

<pre class="cpp">
<a href="../api/classcMessage.html">cMessage</a> *msg = receive();
</pre>
<p>
The <tt>receive()</tt> function accepts an optional <i>timeout</i>
parameter<!--receive!timeout-->. (This is a <i>delta</i>, not an
absolute simulation time.) If no message arrives within the timeout
period, the function returns a <tt>NULL</tt> pointer.
    <br><ul><font size=-1>[Putaside-queue and the functions <tt>receiveOn()</tt>,
    <tt>receiveNew()</tt>, and <tt>receiveNewOn()</tt> were deprecated
    in OMNeT++ 2.3 and removed in OMNeT++ 3.0.]</font></ul>

<pre class="cpp">
simtime_t timeout = 3.0;
<a href="../api/classcMessage.html">cMessage</a> *msg = receive(timeout);

if (msg==NULL)
{
    ...   // handle timeout
}
else
{
    ...  // process message
}
</pre>
<p>
<p class="subheading">The wait() Function</p>
<a name="sec:simple-modules:wait"></a>

<p>The <tt>wait()</tt> function suspends the execution of the module for a
given amount of simulation time (a <i>delta</i>). <tt>wait()</tt> cannot
be used with <tt>handleMessage()</tt>-based modules.

<pre class="cpp">
wait(delay);
</pre>
<p>
In other simulation software, <tt>wait()</tt> is often called <i>hold</i>.
Internally, the <tt>wait()</tt> function is implemented by a
<tt>scheduleAt()</tt> followed by a <tt>receive()</tt>.
The <tt>wait()</tt> function is very convenient in modules that do not need
to be prepared for arriving messages, for example message generators.
An example:

<pre class="cpp">
for (;;)
{
    // wait for some, potentially random, amount of time, specified
    // in the interarrivalTime volatile module parameter
    wait(par("interarrivalTime").doubleValue());

    // generate and send message
    ...
}
</pre>
<p>
It is a runtime error if a message arrives during the wait interval.
If you expect messages to arrive during the wait period, you can
use the <tt>waitAndEnqueue()</tt> function. It takes a pointer to a queue object
(of class <tt><a href="../api/classcQueue.html">cQueue</a></tt>, described in chapter <a href="#sec258">[7]</a>)
in addition to the wait interval. Messages that arrive during the
wait interval will be accumulated in the queue, so you can
process them after the <tt>waitAndEnqueue()</tt> call returned.

<pre class="cpp">
<a href="../api/classcQueue.html">cQueue</a> queue("queue");
...
waitAndEnqueue(waitTime, &queue);
if (!queue.empty())
{
    // process messages arrived during wait interval
    ...
}
</pre>
<p>

<p><h2><a name="sec173"/>4.8 Channels</h2>
<a name="sec:simple-modules:channels"></a>

<p><h3><a name="sec174"/>4.8.1 Overview</h3>

<p>Channels encapsulate parameters and behavior associated with connections.
Channel types are like simple modules, in the sense that they are declared
in NED, and there are C++ implementation classes behind them. Section
<a href="#sec125">[3.5]</a> describes NED language support for channels,
and explains how to associate C++ classes with channel types declared in
NED.

<p>C++ channel classes must subclass from the abstract base class
<tt><a href="../api/classcChannel.html">cChannel</a></tt>. However, when creating a new channel class, it may be
more practical to extend one of the existing C++ channel classes behind the
three predefined NED channel types:

<p><ul>
  <li> <tt><a href="../api/classcIdealChannel.html">cIdealChannel</a></tt> implements the functionality of <tt>ned.IdealChannel</tt>
  <li> <tt><a href="../api/classcDelayChannel.html">cDelayChannel</a></tt> implements the functionality of <tt>ned.DelayChannel</tt>
  <li> <tt><a href="../api/classcDatarateChannel.html">cDatarateChannel</a></tt> implements the functionality of <tt>ned.DatarateChannel</tt>
</ul>

<p>Channel classes need to be registered with the <tt>Define_Channel()</tt> macro,
just like simple module classes need <tt>Define_Module()</tt>.

<p>The channel base class <tt><a href="../api/classcChannel.html">cChannel</a></tt> inherits from <tt><a href="../api/classcComponent.html">cComponent</a></tt>,
so channels participate in the initialization and finalization protocol
(<tt>initialize()</tt> and <tt>finish()</tt>) described in
<a href="#sec149">[4.3.3]</a>.

<p>The parent module of a channel (as returned by the
<tt>getParentModule()</tt>) is the module that contains
the connection. If a connection connects two modules that are children of
the same compound module, the channel's parent is the compound module. If
the connection connects a compound module to one of its submodules, the
channel's parent is also the compound module.

<p>
<h3><a name="sec175"/>4.8.2 The Channel API</h3>

<p>When subclassing <tt>Channel</tt>, you have to redefine and provide
implementations for the following pure virtual member functions:

<p><ul>
  <li> <tt>bool isTransmissionChannel() const</tt>
  <li> <tt>simtime_t getTransmissionFinishTime() const</tt>
  <li> <tt>void processMessage(<a href="../api/classcMessage.html">cMessage</a> *msg, simtime_t t, result_t&amp; result)</tt>
</ul>

<p>The first two functions are usually one-liners; the channel behavior is
encapsulated in the third function, <tt>processMessage()</tt>.

<p><p class="subheading">Transmission Channels</p>

<p>The first function, <tt>isTransmissionChannel()</tt>, determines whether
the channel is a <i>transmission channel</i>, i.e. one that models
transmission duration. A transmission channel sets the duration field of
packets sent through it (see the <tt>setDuration()</tt> field of
<tt><a href="../api/classcPacket.html">cPacket</a></tt>).

<p>The <tt>getTransmissionFinishTime()</tt> function is only used with
transmission channels, and it should return the simulation time the sender
will finish (or has finished) transmitting. This method is called by
modules that send on a transmission channel to find out when the channel
becomes available. The channel's <tt>isBusy()</tt> method is implemented
simply as <tt>return getTransmissionFinishTime() &lt; simTime()</tt>. For
non-transmission channels, the <tt>getTransmissionFinishTime()</tt> return
value may be any simulation time which is less than or equal to the current
simulation time.

<p><p class="subheading">The processMessage() Function</p>

<p>The third function, <tt>processMessage()</tt> encapsulates the channel's
functionality. However, before going into the details of this function
we need to understand how OMNeT++ handles message sending on connections.

<p>Inside the <tt>send()</tt> call, OMNeT++ follows the
connection path denoted by the <tt>getNextGate()</tt> functions of gates,
until it reaches the target module. At each &#8220;hop&#8221;, the corresponding
connection's channel (if the connection has one) gets a chance to add to
the message's arrival time (<i>propagation time modeling</i>), calculate a
<i>transmission duration</i>, and to modify the message object in various
ways, such as set the bit error flag in it (<i>bit error modeling</i>).
After processing all hops that way, OMNeT++ inserts the message object
into the Future Events Set (FES<!--FES-->, see section
<a href="#sec141">[4.1.2]</a>), and the <tt>send()</tt> call returns.
Then OMNeT++ continues to process events in increasing timestamp order.
The message will be delivered to the target module's <tt>handleMessage()</tt>
(or <tt>receive()</tt>) function when it gets to the front of the FES.

<p>A few more details: a channel may instruct OMNeT++ to delete the message
instead of inserting it into the FES; this can be useful to model
disabled channels, or to model that the message has been lost altogether.
The <tt>getDeliverOnReceptionStart()</tt> flag of the final gate in the path
will determine whether the transmission duration will be added to the
arrival time or not. Packet transmissions have been described in section
<a href="#sec171">[4.7.6]</a>.

<p>Now, back to the <tt>processMessage()</tt> method.

<p>The method gets called as part of the above process, when the message
is processed at the given hop. The method's arguments are the message
object, the simulation time the beginning of the message will reach
the channel (i.e. the sum of all previous propagation delays),
and a struct in which the method can return the results.

<p>The <tt>result_t</tt> struct is an inner type of <tt><a href="../api/classcChannel.html">cChannel</a></tt>,
and looks like this:

<pre class="cpp">
struct result_t {
    simtime_t delay;     // propagation delay
    simtime_t duration;  // transmission duration
    bool discard;        // whether the channel has lost the message
};
</pre>
<p>
It also has a constructor that initializes all fields to zero; it is left
out for brevity.

<p>The method should model the transmission of the given message starting at
the given <i>t</i> time, and store the results (propagation delay,
transmission duration, deletion flag) in the result object. Only the
relevant fields in the result object need to be changed, others can be left
untouched.

<p>Transmission duration and bit error modeling only applies to packets (i.e.
to instances of <tt><a href="../api/classcPacket.html">cPacket</a></tt>, where <tt><a href="../api/classcMessage.html">cMessage</a></tt>'s
<tt>isPacket()</tt> returns true); it should be skipped for non-packet
messages. <tt>processMessage()</tt> does not need to call the <tt>setDuration()</tt>
method on the packet; this is done by the simulation kernel. However,
it should call <tt>setBitError(true)</tt> on the packet
if error modeling results in bit errors.

<p>If the method sets the <tt>discard</tt> flag in the result object, that
means that the message object will be deleted by OMNeT++; this facility
can be used to model that the message gets lost in the channel.

<p>The <tt>processMessage()</tt> method does not need to throw error on overlapping
transmissions, or if the packet's duration field is already set; these
checks are done by the simulation kernel before <tt>processMessage()</tt> is called.



<p><h3><a name="sec176"/>4.8.3 Channel Examples</h3>

<p>To illustrate coding channel behavior, we look at how the built-in channel
types are implemented.

<p><tt><a href="../api/classcIdealChannel.html">cIdealChannel</a></tt> lets through messages and packets without
any delay or change. Its <tt>isTransmissionChannel()</tt> method returns
<tt>false</tt>, <tt>getTransmissionFinishTime()</tt> returns <i>0s</i>, and the
body of its <tt>processMessage()</tt> method is empty:

<pre class="cpp">
void <a href="../api/classcIdealChannel.html">cIdealChannel</a>::processMessage(<a href="../api/classcMessage.html">cMessage</a> *msg, simtime_t t, result_t& result)
{
}
</pre>
<p>
<tt><a href="../api/classcDelayChannel.html">cDelayChannel</a></tt> implements propagation delay, and it can be
disabled; in its disabled state, messages sent though it will be discarded.
This class still models zero transmission duration, so its
<tt>isTransmissionChannel()</tt> and <tt>getTransmissionFinishTime()</tt>
methods still return <tt>false</tt> and <i>0s</i>. The <tt>processMessage()</tt> method
sets the appropriate fields in the <tt>result_t</tt> struct:

<pre class="cpp">
void <a href="../api/classcDelayChannel.html">cDelayChannel</a>::processMessage(<a href="../api/classcMessage.html">cMessage</a> *msg, simtime_t t, result_t& result)
{
    // if channel is disabled, signal that message should be deleted
    result.discard = isDisabled;

    // propagation delay modeling
    result.delay = delay;
}
</pre>
<p>
The <tt>handleParameterChange()</tt> method is also redefined, so that
the channel can update its internal <tt>delay</tt> and <tt>isDisabled</tt>
data members if the corresponding channel parameters change during simulation.
<br><ul><font size=-1>[This code is a little simplified; the actual code uses a bit
in a bitfield to store the value of <tt>isDisabled</tt>.]</font></ul>

<p><tt><a href="../api/classcDatarateChannel.html">cDatarateChannel</a></tt> is different. It performs model packet duration
(duration is calculated from the data rate and the length of the packet),
so <tt>isTransmissionChannel()</tt> returns <tt>true</tt>.
<tt>getTransmissionFinishTime()</tt> returns the value of a <tt>txfinishtime</tt>
data member, which gets updated after every packet.

<pre class="cpp">
simtime_t <a href="../api/classcDatarateChannel.html">cDatarateChannel</a>::getTransmissionFinishTime() const
{
    return txfinishtime;
}
</pre>
<p>
<tt><a href="../api/classcDatarateChannel.html">cDatarateChannel</a></tt>'s <tt>processMessage()</tt> method makes use of
the <tt>isDisabled</tt>, <tt>datarate</tt>, <tt>ber</tt> and <tt>per</tt> data
members, which are also kept up to date with the help of
<tt>handleParameterChange()</tt>.

<pre class="cpp">
void <a href="../api/classcDatarateChannel.html">cDatarateChannel</a>::processMessage(<a href="../api/classcMessage.html">cMessage</a> *msg, simtime_t t, result_t& result)
{
    // if channel is disabled, signal that message should be deleted
    if (isDisabled) {
        result.discard = true;
        return;
    }

    // datarate modeling
    if (datarate!=0 && msg-&gt;isPacket()) {
        simtime_t duration = ((<a href="../api/classcPacket.html">cPacket</a> *)msg)-&gt;getBitLength() / datarate;
        result.duration = duration;
        txfinishtime = t + duration;
    }
    else {
        txfinishtime = t;
    }

    // propagation delay modeling
    result.delay = delay;

    // bit error modeling
    if ((ber!=0 || per!=0) && msg-&gt;isPacket())
    {
        <a href="../api/classcPacket.html">cPacket</a> *pkt = (<a href="../api/classcPacket.html">cPacket</a> *)msg;
        if (ber!=0 && dblrand() &lt; 1.0 - pow(1.0-ber, (double)pkt-&gt;getBitLength())
            pkt-&gt;setBitError(true);
        if (per!=0 && dblrand() &lt; per)
            pkt-&gt;setBitError(true);
    }
}
</pre>
<p>

<p>
<h2><a name="sec177"/>4.9 Stopping the Simulation</h2>
<a name="sec:simple-modules:stopping"></a>

<p><h3><a name="sec178"/>4.9.1 Normal Termination</h3>

<p>You can finish the simulation with the <tt>endSimulation()</tt> function:

<pre class="cpp">
endSimulation();
</pre>
<p>
<tt>endSimulation()</tt> is rarely needed in practice because you
can specify simulation time and CPU time limits<!--simulation time limits-->
in the ini file (see later).

<p><h3><a name="sec179"/>4.9.2 Raising Errors</h3>

<p>If your simulation encounters an error condition, you can throw a
<tt><a href="../api/classcRuntimeError.html">cRuntimeError</a></tt> exception to terminate the simulation with
an error message (and in case of Cmdenv, a nonzero exit code).
The <tt><a href="../api/classcRuntimeError.html">cRuntimeError</a></tt> class has a constructor whose argument list
is similar to <tt>printf()</tt>:

<pre class="cpp">
if (windowSize &lt;= 0)
    throw <a href="../api/classcRuntimeError.html">cRuntimeError</a>("Invalid window size %d; must be &gt;=1", windowSize);
</pre>
<p>
Do not include newline (<tt>\n</tt>), period or exclamation mark
in the error text; it will be added by OMNeT++.

<p>You can achieve the same effect by calling the <tt>error()</tt> method of
<tt><a href="../api/classcModule.html">cModule</a></tt>

<pre class="cpp">
if (windowSize &lt;= 0)
    error("Invalid window size %d; must be &gt;=1", windowSize);
</pre>
<p>
Of course, the <tt>error()</tt> method can only be used when a module pointer
is available.

<p>

<p><h2><a name="sec180"/>4.10 Finite State Machines</h2>
<a name="sec:simple-modules:fsm"></a>

<p><p class="subheading">Overview</p>

<p>Finite State Machines<!--finite state machine--> (FSMs)<!--FSM-->
can make life with <tt>handleMessage()</tt> easier. OMNeT++ provides a
class and a set of macros to build FSMs.

<p>The key points are:
<ul>
<li>There are two kinds of states:
    <i>transient</i><!--transient states--> and
    <i>steady</i><!--steady states-->. On each event (that is, at
    each call to <tt>handleMessage()</tt>), the FSM transitions out of
    the current (<i>steady</i>) state, undergoes a series of state
    changes (runs through a number of <i>transient</i> states), and
    finally arrives at another <i>steady</i> state. Thus between two
    events, the system is always in one of the steady states.
    Transient states are therefore not really a must -- they exist
    only to group actions to be taken during a transition in a
    convenient way.
<li>You can assign program code to handle entering and leaving a state
    (known as entry/exit code)<!--entry code--><!--exit code-->.
    Staying in the same state is handled as leaving and re-entering
    the state.
<li>Entry code should not modify the state (this is verified by
    OMNeT++).  State changes (transitions) must be put into the exit
    code.
</ul>

<p>OMNeT++'s FSMs <i>can</i> be nested<!--FSM!nested-->. This means
that any state (or rather, its entry or exit code) may contain a
further full-fledged <tt>FSM_Switch()</tt> (see below). This allows you
to introduce sub-states and thereby bring some structure into the
state space if it becomes too large.

<p>
<p class="subheading">The FSM API</p>

<p>
FSM state is stored in an object of type <tt><a href="../api/classcFSM.html">cFSM</a></tt>. The possible states
are defined by an enum; the enum is also a place to define which
state is transient and which is steady. In the following example, SLEEP
and ACTIVE are steady states and SEND is transient (the numbers
in parentheses must be unique within the state type and they are used
for constructing the numeric IDs for the states):

<pre class="cpp">
enum {
  INIT = 0,
  SLEEP = FSM_Steady(1),
  ACTIVE = FSM_Steady(2),
  SEND = FSM_Transient(1),
};
</pre>
<p>

<p>
The actual FSM is embedded in a switch-like statement,
<tt>FSM_Switch()</tt>, where you have cases for entering and leaving
each state:

<p>
<pre class="cpp">
FSM_Switch(fsm)
{
  case FSM_Exit(state1):
    //...
    break;
  case FSM_Enter(state1):
    //...
    break;
  case FSM_Exit(state2):
    //...
    break;
  case FSM_Enter(state2):
    //...
    break;
  //...
};
</pre>

<p>
State transitions<!--state transition--> are done via calls to
<tt>FSM_Goto()</tt>, which simply stores the new state in the
<tt><a href="../api/classcFSM.html">cFSM</a></tt> object:

<pre class="cpp">
FSM_Goto(fsm, newState);
</pre>
<p>
The FSM starts from the state with the numeric code 0; this state
is conventionally named INIT.

<p>
<p class="subheading">Debugging FSMs</p>

<p>FSMs can log their state transitions <tt>ev</tt><!--ev-->,
with the output looking like this:

<pre class="filelisting">
...
FSM GenState: leaving state SLEEP
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SEND
FSM GenState: leaving state SEND
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SLEEP
...
</pre>
<p>
To enable the above output, you have to <tt>#define FSM_DEBUG</tt><!--FSM_DEBUG-->
before including <tt>omnetpp.h</tt>.

<pre class="cpp">
#define FSM_DEBUG    // enables debug output from FSMs
#include &lt;omnetpp.h&gt;
</pre>
<p>
The actual logging is done via the <tt>FSM_Print()</tt> macro.
It is currently defined as follows, but you can change the
output format by undefining <tt>FSM_Print()</tt> after including
<tt>omnetpp.ini</tt> and providing a new definition instead.

<pre class="cpp">
#define FSM_Print(fsm,exiting)
  (ev &lt;&lt; "FSM " &lt;&lt; (fsm).getName()
      &lt;&lt; ((exiting) ? ": leaving state " : ": entering state ")
      &lt;&lt; (fsm).getStateName() &lt;&lt; endl)
</pre>
<p>

<p><p class="subheading">Implementation</p>

<p>
The <tt>FSM_Switch()</tt> is a macro. It expands to a <tt>switch()</tt>
statement embedded in a <tt>for()</tt> loop which repeats until the
FSM<!--FSM--> reaches a steady state. (The actual code is rather
scary, but if you are dying to see it, it is in <tt>cfsm.h</tt>.)

<p>Infinite loops are avoided by counting state transitions: if
an FSM goes through 64 transitions without reaching a steady
state, the simulation will terminate with an error message.

<p>
<p class="subheading">An Example</p>

<p>
Let us write another bursty packet generator. It will have two
states, SLEEP and ACTIVE. In the SLEEP state, the module does
nothing. In the ACTIVE state, it sends messages with a given
inter-arrival time. The code was taken from the Fifo2 sample
simulation.

<p>
<pre class="cpp">
#define FSM_DEBUG
#include &lt;omnetpp.h&gt;

class BurstyGenerator : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    // parameters
    double sleepTimeMean;
    double burstTimeMean;
    double sendIATime;
    <a href="../api/classcPar.html">cPar</a> *msgLength;

    // FSM and its states
    <a href="../api/classcFSM.html">cFSM</a> fsm;
    enum {
      INIT = 0,
      SLEEP = FSM_Steady(1),
      ACTIVE = FSM_Steady(2),
      SEND = FSM_Transient(1),
    };

    // variables used
    int i;
    <a href="../api/classcMessage.html">cMessage</a> *startStopBurst;
    <a href="../api/classcMessage.html">cMessage</a> *sendMessage;

    // the virtual functions
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    fsm.setName("fsm");
    sleepTimeMean = par("sleepTimeMean");
    burstTimeMean = par("burstTimeMean");
    sendIATime = par("sendIATime");
    msgLength = &par("msgLength");
    i = 0;
    WATCH(i); // always put watches in initialize()
    startStopBurst = new <a href="../api/classcMessage.html">cMessage</a>("startStopBurst");
    sendMessage = new <a href="../api/classcMessage.html">cMessage</a>("sendMessage");
    scheduleAt(0.0,startStopBurst);
}

void BurstyGenerator::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
   FSM_Switch(fsm)
   {
     case FSM_Exit(INIT):
       // transition to SLEEP state
       FSM_Goto(fsm,SLEEP);
       break;
     case FSM_Enter(SLEEP):
       // schedule end of sleep period (start of next burst)
       scheduleAt(simTime()+exponential(sleepTimeMean),
                  startStopBurst);
     break;
     case FSM_Exit(SLEEP):
       // schedule end of this burst
       scheduleAt(simTime()+exponential(burstTimeMean),
                  startStopBurst);
       // transition to ACTIVE state:
       if (msg!=startStopBurst) {
         error("invalid event in state ACTIVE");
       }
       FSM_Goto(fsm,ACTIVE);
       break;
     case FSM_Enter(ACTIVE):
       // schedule next sending
       scheduleAt(simTime()+exponential(sendIATime), sendMessage);
     break;
     case FSM_Exit(ACTIVE):
       // transition to either SEND or SLEEP
       if (msg==sendMessage) {
         FSM_Goto(fsm,SEND);
       } else if (msg==startStopBurst) {
         cancelEvent(sendMessage);
         FSM_Goto(fsm,SLEEP);
       } else {
         error("invalid event in state ACTIVE");
       }
       break;
     case FSM_Exit(SEND):
     {
       // generate and send out job
       char msgname[32];
       sprintf( msgname, "job-%d", ++i);
       ev &lt;&lt; "Generating " &lt;&lt; msgname &lt;&lt; endl;
       <a href="../api/classcMessage.html">cMessage</a> *job = new <a href="../api/classcMessage.html">cMessage</a>(msgname);
       job-&gt;setBitLength( (long) *msgLength );
       job-&gt;setTimestamp();
       send( job, "out" );
       // return to ACTIVE
       FSM_Goto(fsm,ACTIVE);
       break;
     }
   }
}
</pre>

<p>

<p>
<h2><a name="sec181"/>4.11 Navigating the Module Hierarchy</h2>
<a name="sec:simple-modules:walking-module-hierarchy"></a>

<p><p class="subheading">Module Vectors</p>

<p>
If a module is part of a module vector<!--module!vector-->, the
<tt>getIndex()</tt> and <tt>getVectorSize()</tt> member functions can be used to
query its index and the vector size:

<pre class="cpp">
ev &lt;&lt; "This is module [" &lt;&lt; module-&gt;getIndex() &lt;&lt;
      "] in a vector of size [" &lt;&lt; module-&gt;size() &lt;&lt; "].\n";
</pre>
<p>

<p><p class="subheading">Module IDs</p>

<p>
Each module in the network has a unique ID that is returned by the
<tt>getId()</tt> member function. The module ID<!--module!id--> is used
internally by the simulation kernel to identify modules.

<pre class="cpp">
int myModuleId = getId();
</pre>
<p>
If you know the module ID, you can ask the simulation object
(a global variable) to get back the module pointer:

<pre class="cpp">
int id = 100;
<a href="../api/classcModule.html">cModule</a> *mod = simulation.getModule( id );
</pre>
<p>

<p>Module IDs are guaranteed to be unique for the duration of the whole
simulation, even when modules are created and destroyed dynamically;
that is, IDs of deleted modules are not reused for newly created
modules.

<p>
<p class="subheading">Walking Up and Down the Module Hierarchy</p>

<p>
The surrounding compound module can be accessed by the
<tt>getParentModule()</tt> member function:

<pre class="cpp">
<a href="../api/classcModule.html">cModule</a> *parent = getParentModule();
</pre>
<p>
For example, the parameters of the parent module are accessed
like this:

<pre class="cpp">
double timeout = getParentModule()-&gt;par( "timeout" );
</pre>
<p>

<p><tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>findSubmodule()</tt> and <tt>getSubmodule()</tt>
member functions make it possible to look up the module's submodules
by name<!--module!submodule!lookup--> (or name+index if the submodule
is in a module vector). The first one returns the numeric module ID of
the submodule, and the latter returns the module pointer.  If the
submodule is not found, they return -1 or NULL, respectively.

<pre class="cpp">
int submodID = compoundmod-&gt;findSubmodule("child",5);
<a href="../api/classcModule.html">cModule</a> *submod = compoundmod-&gt;getSubmodule("child",5);
</pre>
<p>

<p>The <tt>getModuleByRelativePath()</tt> member function can be used to find
a submodule nested deeper than one level below. For example,

<pre class="cpp">
compoundmod-&gt;getModuleByRelativePath("child[5].grandchild");
</pre>
<p>
would give the same result as

<pre class="cpp">
compoundmod-&gt;getSubmodule("child",5)-&gt;getSubmodule("grandchild");
</pre>
<p>
(Provided that <tt>child[5]</tt> does exist, because otherwise the second
version would crash with an access violation because of the NULL
pointer dereference.)

<p>
The <tt><a href="../api/classcSimulation.html">cSimulation</a></tt>::<tt>getModuleByPath()</tt> function is similar
to <tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>moduleByRelativePath()</tt> function, and it
starts the search at the top-level module.

<p>
<p class="subheading">Iterating over Submodules</p>

<p>
To access all modules within a compound module,
use <tt><a href="../api/classcSubModIterator.html">cSubModIterator</a></tt>.

<p>For example:

<pre class="cpp">
for (<a href="../api/classcSubModIterator.html">cSubModIterator</a> iter(*getParentModule()); !iter.end(); iter++)
{
  ev &lt;&lt; iter()-&gt;getFullName();
}
</pre>
<p>
(<tt>iter()</tt> is pointer to the current module the iterator is at.)

<p>
The above method can also be used to iterate along a module
vector<!--module!vector!iteration-->, since the <tt>getName()</tt>
function returns the same for all modules:

<pre class="cpp">
for (<a href="../api/classcSubModIterator.html">cSubModIterator</a> iter(*getParentModule()); !iter.end(); iter++)
{
  if (iter()-&gt;isName(getName())) // if iter() is in the same
                              // vector as this module
  {
    int itsIndex = iter()-&gt;getIndex();
    // do something to it
  }
}
</pre>
<p>

<p><p class="subheading">Walking Along Links</p>

<p>To determine the module at the other end of a connection, use
<tt><a href="../api/classcGate.html">cGate</a></tt>'s <tt>getPreviousGate()</tt>, <tt>getNextGate()</tt> and
<tt>getOwnerModule()</tt> functions. For example:

<pre class="cpp">
<a href="../api/classcModule.html">cModule</a> *neighbour = gate("out")-&gt;getNextGate()-&gt;getOwnerModule();
</pre>
<p>
For input gates, you would use <tt>getPreviousGate()</tt> instead of
<tt>getNextGate()</tt>.

<p>
<h2><a name="sec182"/>4.12 Direct Method Calls Between Modules</h2>
<a name="sec:simple-modules:direct-method-calls"></a>
<!--method calls!between modules-->

<p>In some simulation models, there might be modules which are too
tightly coupled for message-based communication to be efficient.
In such cases, the solution might be calling one simple module's public
C++ methods from another module.

<p>Simple modules are C++ classes, so normal C++ method calls will
work. Two issues need to be mentioned, however:

<p><ul>
  <li> how to get a pointer to the object representing the module;
  <li> how to let the simulation kernel know that a method call across modules
     is taking place.
</ul>

<p>Typically, the called module is in the same compound module as the caller,
so the <tt>getParentModule()</tt> and <tt>getSubmodule()</tt> methods of
<tt><a href="../api/classcModule.html">cModule</a></tt> can be used to get a <tt><a href="../api/classcModule.html">cModule</a>*</tt> pointer to the
called module. (Further ways to obtain the pointer are described
in the section <a href="#sec181">[4.11]</a>.)
The <tt><a href="../api/classcModule.html">cModule</a>*</tt> pointer then has to be cast to the actual C++ class
of the module, so that its methods become visible.

<p>This makes the following code:

<pre class="cpp">
<a href="../api/classcModule.html">cModule</a> *calleeModule = getParentModule()-&gt;getSubmodule("callee");
Callee *callee = check_and_cast&lt;Callee *&gt;(calleeModule);
callee-&gt;doSomething();
</pre>
<p>
The <tt>check_and_cast&lt;&gt;()</tt> template function on the second line
is part of OMNeT++. It performs a standard C++ <tt>dynamic_cast</tt>,
and checks the result: if it is NULL, <tt>check_and_cast</tt> raises an OMNeT++ error.
Using <tt>check_and_cast</tt> saves you from writing error checking
code: if <tt>calleeModule</tt> from the first line is NULL because
the submodule named <tt>"callee"</tt> was not found, or if that
module is actually not of type <tt>Callee</tt>, an error is thrown
from <tt>check_and_cast</tt>.

<p>The second issue is how to let the simulation kernel know that
a method call across modules is taking place. Why is this necessary
in the first place? First, the simulation kernel always has to know which
module's code is currently executing, in order for ownership handling
and other internal mechanisms to work correctly. Second, the Tkenv
simulation GUI can animate method calls, but to be able to do that,
it has to know about them. Third, method calls are also recorded
in the event log.

<p>The solution is to add the <tt>Enter_Method()</tt> or <tt>Enter_Method_Silent()</tt>
macro at the top of the methods that may be invoked from other
modules. These calls perform context switching, and, in case of
<tt>Enter_Method()</tt>, notify the simulation GUI so that animation
of the method call can take place. <tt>Enter_Method_Silent()</tt>
does not animate the method call, but otherwise it is equivalent
<tt>Enter_Method()</tt>. Both macros accept a <tt>printf()</tt>-like
argument list (it is optional for <tt>Enter_Method_Silent()</tt>),
which should produce a string with the method name and the
actual arguments as much as practical. The string is displayed in
the animation (<tt>Enter_Method()</tt> only) and recorded into the event log.

<p>
<pre class="cpp">
void Callee::doSomething()
{
    Enter_Method("doSomething()");
    ...
}
</pre>

<p>

<p><h2><a name="sec183"/>4.13 Dynamic Module Creation</h2>
<a name="sec:simple-modules:dynamic-module-creation"></a>
<!--module!dynamic creation-->

<p><h3><a name="sec184"/>4.13.1 When Do You Need Dynamic Module Creation</h3>

<p>In some situations you need to dynamically create and maybe destroy
modules. For example, when simulating a mobile network,
you may create a new module whenever a new user enters
the simulated area, and dispose of them when they leave the area.

<p>As another example, when implementing a server or a transport
protocol, it might be convenient to dynamically create modules
to serve new connections, and dispose of them when the connection
is closed. (You would write a manager module that receives connection
requests and creates a module for each connection.
The Dyna example simulation does something like this.)

<p>Both simple and compound modules can be created dynamically.
If you create a compound module, all its submodules will be created
recursively.

<p>It is often convenient to use direct message sending with dynamically
created modules.

<p>Once created and started, dynamic modules aren't any different from
&#8220;static&#8221; modules; for example, one could also delete static modules
during simulation (though it is rarely useful.)

<p>
<h3><a name="sec185"/>4.13.2 Overview</h3>

<p>
To understand how dynamic module creation works, you have to know a
bit about how OMNeT++ normally instantiates modules. Each module type
(class) has a corresponding factory object of the class
<tt><a href="../api/classcModuleType.html">cModuleType</a></tt>. This object is created under the hood by the
<tt>Define_Module()</tt> macro, and it has a factory
method which can instantiate the module class (this function basically
only consists of a <tt>return new <i>&lt;moduleclass&gt;</i>(...)</tt> statement).

<p>The <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object can be looked up by its name
string (which is the same as the module class name). Once you have its
pointer, it is possible to call its factory method and create an
instance of the corresponding module class -- without having to
include the C++ header file containing module's class declaration
into your source file.

<p>The <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object also knows what gates and
parameters the given module type has to have. (This info comes from
NED files.)

<p>Simple modules can be created in one step. For a compound module, the
situation is more complicated, because its internal structure
(submodules, connections) may depend on parameter values and gate
vector sizes. Thus, for compound modules it is generally required to
first create the module itself, second, set parameter values and gate
vector sizes, and then call the method that creates its submodules and
internal connections.

<p>As you know already, simple modules with <tt>activity()</tt> need a
starter message<!--starter messages-->. For statically created
modules, this message is created automatically by OMNeT++, but for
dynamically created modules, you have to do this explicitly by calling
the appropriate functions.

<p>Calling <tt>initialize()</tt> has to take place after insertion of the
starter messages, because the initializing code may insert new messages
into the FES<!--FES-->, and these messages should be processed
<i>after</i> the starter message.

<p>
<h3><a name="sec186"/>4.13.3 Creating Modules</h3>

<p>The first step is to find the factory object. The <tt><a href="../api/classcModuleType.html">cModuleType</a>::get()</tt>
function expects a fully qualified NED type name, and returns the factory
object:

<pre class="cpp">
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = <a href="../api/classcModuleType.html">cModuleType</a>::get("foo.nodes.WirelessNode");
</pre>
<p>
The return value does not need to be checked for <tt>NULL</tt>, because
the function raises an error if the requested NED type was not found.
(If this behavior is not what you need, you can use the similar
<tt><a href="../api/classcModuleType.html">cModuleType</a>::find()</tt> function, which returns <tt>NULL</tt> if the type
was not found.)

<p><p class="subheading">The All-in-One Method</p>

<p><tt><a href="../api/classcModuleType.html">cModuleType</a></tt> has a \ffunc[createScheduleInit()]createScheduleInit(const
char *name, <a href="../api/classcModule.html">cModule</a> *parentmod) convenience function to get a module up
and running in one step.

<pre class="cpp">
<a href="../api/classcModule.html">cModule</a> *mod = moduleType-&gt;createScheduleInit("node", this);
</pre>
<p>
<tt>createScheduleInit()</tt> performs the following steps: <tt>create()</tt>,
<tt>finalizeParameters()</tt>, <tt>buildInside()</tt>,
<tt>scheduleStart(now)</tt> and <tt>callInitialize()</tt>.

<p>This method can be used for both simple and compound modules. Its
applicability is somewhat limited, however: because it does everything in
one step, you do not have the chance to set parameters or gate sizes, and
to connect gates before <tt>initialize()</tt> is called.
(<tt>initialize()</tt> expects all parameters and gates to be in place and
the network fully built when it is called.) Because of the above
limitation, this function is mainly useful for creating basic simple
modules.

<p>
<p class="subheading">The Detailed Procedure</p>

<p>If the <tt>createScheduleInit()</tt> all-in-one method is not applicable,
one needs to use the full procedure. It consists of five steps:

<p><ol>
  <li> Find the factory object;
  <li> Create the module;
  <li> Set up its parameters and gate sizes as needed;
  <li> Tell the (possibly compound) module to recursively create
        its internal submodules and connections;
  <li> Schedule activation message(s) for the new simple module(s).
</ol>

<p>Each step (except for Step 3.) can be done with one line of code.

<p>See the following example, where Step 3 is omitted:

<pre class="cpp">
// find factory object
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = <a href="../api/classcModuleType.html">cModuleType</a>::get("foo.nodes.WirelessNode");

// create (possibly compound) module and build its submodules (if any)
<a href="../api/classcModule.html">cModule</a> *module = moduleType-&gt;create("node", this);
module-&gt;finalizeParameters();
module-&gt;buildInside();

// create activation message
module-&gt;scheduleStart(simTime());
</pre>
<p>
If you want to set up parameter values or gate vector sizes (Step 3.),
the code goes between the <tt>create()</tt> and
<tt>buildInside()</tt> calls:

<pre class="cpp">
// create
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = <a href="../api/classcModuleType.html">cModuleType</a>::get("foo.nodes.WirelessNode");
<a href="../api/classcModule.html">cModule</a> *module = moduleType-&gt;create("node", this);

// set up parameters and gate sizes before we set up its submodules
module-&gt;par("address") = ++lastAddress;
module-&gt;finalizeParameters();

module-&gt;setGateSize("in", 3);
module-&gt;setGateSize("out", 3);

// create internals, and schedule it
module-&gt;buildInside();
module-&gt;scheduleStart(simTime());
</pre>
<p>

<p><h3><a name="sec187"/>4.13.4 Deleting Modules</h3>

<p>To delete a module dynamically<!--module!dynamic deletion-->, use
<tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>deleteModule()</tt> member function:

<pre class="cpp">
module-&gt;deleteModule();
</pre>
<p>
If the module was a compound module, this involves recursively
deleting all its submodules. A simple module can also delete itself;
in this case, the <tt>deleteModule()</tt> call does not return to the
caller.

<p>Currently, you cannot safely delete a compound module from a simple module
in it; you must delegate the job to a module outside the compound
module.

<p>
<h3><a name="sec188"/>4.13.5 Module Deletion and finish()</h3>

<p><tt>finish()</tt> is called for <i>all</i> modules at the end of the
simulation, no matter how the modules were created. If a module is
dynamically deleted before that, <tt>finish()</tt> will not be invoked
(<tt>deleteModule()</tt> does not do it). However, you can still manually
invoke it before <tt>deleteModule()</tt>.

<p>You can use the <tt>callFinish()</tt> function to invoke <tt>finish()</tt>
(It is not a good idea to invoke <tt>finish()</tt> directly). If you are
deleting a compound module, <tt>callFinish()</tt> will recursively invoke
<tt>finish()</tt> for all submodules, and if you are deleting a simple
module from another module, <tt>callFinish()</tt> will do the context switch
for the duration of the call.
  <br><ul><font size=-1>[The <tt>finish()</tt> function has even been made <tt>protected</tt>
  in <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, in order to discourage its invocation from
  other modules.]</font></ul>

<p>Example:

<pre class="cpp">
mod-&gt;callFinish();
mod-&gt;deleteModule();
</pre>
<p>

<p><h3><a name="sec189"/>4.13.6 Creating Connections</h3>
<!--connection!creating-->

<p>Connections can be created using <tt><a href="../api/classcGate.html">cGate</a></tt>'s <tt>connectTo()</tt>
method.
  <br><ul><font size=-1>[The earlier <tt>connect()</tt> global functions that
  accepted two gates have been deprecated, and may be removed
  from further OMNeT++ releases.]</font></ul>
<tt>connectTo()</tt> should be invoked on the source gate
of the connection, and expects the destination gate pointer as
an argument:

<pre class="cpp">
srcGate-&gt;connectTo(destGate);
</pre>
<p>
The <i>source</i> and <i>destination</i> words correspond
to the direction of the arrow in NED files.

<p>As an example, we create two modules and connect them in both directions:

<pre class="cpp">
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = <a href="../api/classcModuleType.html">cModuleType</a>::get("TicToc");
<a href="../api/classcModule.html">cModule</a> *a = modtype-&gt;createScheduleInit("a", this);
<a href="../api/classcModule.html">cModule</a> *b = modtype-&gt;createScheduleInit("b", this);

a-&gt;gate("out")-&gt;connectTo(b-&gt;gate("in"));
b-&gt;gate("out")-&gt;connectTo(a-&gt;gate("in"));
</pre>
<p>
<tt>connectTo()</tt> also accepts a channel object (<tt><a href="../api/classcChannel.html">cChannel</a>*</tt>) as an
additional, optional argument. Similarly to modules, channels can be
created using their factory object of the type <tt><a href="../api/classcChannelType.html">cChannelType</a></tt>:

<pre class="cpp">
<a href="../api/classcGate.html">cGate</a> *outg=..., *ing=...;

// find factory object and create a channel
<a href="../api/classcChannelType.html">cChannelType</a> *channelType = <a href="../api/classcChannelType.html">cChannelType</a>::get("foo.util.Channel");
<a href="../api/classcChannel.html">cChannel</a> *channel = channelType-&gt;create("channel");

// create connecting
outg-&gt;connectTo(ing, channel);
</pre>
<p>
The channel object will be owned by the source gate of the connection, and
you cannot reuse the same channel object with several connections.

<p>If you need one of the built-in channel types (<tt><a href="../api/classcIdealChannel.html">cIdealChannel</a></tt>,
<tt><a href="../api/classcDelayChannel.html">cDelayChannel</a></tt> or <tt><a href="../api/classcDatarateChannel.html">cDatarateChannel</a></tt>), the step to find the
factory object can be spared, as those classes have static <tt>create()</tt>
functions to create a channel instance.

<p><tt><a href="../api/classcDatarateChannel.html">cDatarateChannel</a></tt> also has member functions to set up its
parameters: <tt>setDelay()</tt>, <tt>setBitErrorRate()</tt>,
<tt>setPacketErrorRate()</tt> and <tt>setDatarate()</tt>.

<p>An example that sets up a channel with a delay:

<pre class="cpp">
<a href="../api/classcDatarateChannel.html">cDatarateChannel</a> *channel = <a href="../api/classcDatarateChannel.html">cDatarateChannel</a>::create("channel");
channel-&gt;setDelay(0.001);

a-&gt;gate("out")-&gt;connectTo(b-&gt;gate("in"), channel); // a, b are modules
</pre>
<p>

<p><h3><a name="sec190"/>4.13.7 Removing Connections</h3>
<!--connection!removing-->

<p>The <tt>disconnect()</tt> method of <tt><a href="../api/classcGate.html">cGate</a></tt> can be
used to remove connections. This method has to be invoked
on the <i>source</i> side of the connection. It also destroys
the channel object associated with the connection, if one has been set.

<pre class="cpp">
srcGate-&gt;disconnect();
</pre>
<p>
<h2><a name="sec191"/>4.14 Signals</h2>
<a name="sec:simple-modules:signals"></a>

<p>This section describes <i>simulation signals</i>, or signals for short.
Signals are a versatile concept that first appeared in OMNeT++ 4.1.

<p>Simulation signals can be used for:

<p><ul>
  <li> exposing statistical properties of the model, without specifying
        whether and how to record them
  <li> receiving notifications about simulation model changes at runtime, and
        acting upon them
  <li> implementing a publish-subscribe style communication among modules;
        this is advantageous when the producer and consumer of the information
        do not know about each other, and possibly there is many-to-one or
        many-to-many relationship among them
  <li> emitting information for other purposes, for example as input for
        custom animation effects
</ul>

<p>Signals are emitted by components (modules and channels). Signals propagate
on the module hierarchy up to the root. At any level, one can register
listeners (callback objects); these listeners will be notified (called
back) whenever a signal value is emitted. The result of upwards propagation
is that listeners registered at a compound module can receive signals from
all components in that submodule tree. A listener registered at the system
module can receive signals from the whole simulation.

<p><ul class="note"><b>NOTE</b><br>
    A channel's parent is the (compound) module that contains the connection,
    not the owner of either gate the channel is connected to.
</ul>

<p>Signals are identified by signal names (i.e. strings), but for efficiency reasons
at runtime we use dynamically assigned numeric identifiers (signal IDs,
typedef'd as <tt>simsignal_t</tt>). The mapping of signal names to signal IDs is
global, so all modules and channels asking to resolve a particular signal name
will get back the same numeric signal ID.

<p>Listeners can subscribe to signal names or IDs, regardless of their
source. For example, if two different and unrelated module types, say
<tt>Queue</tt> and <tt>Buffer</tt>, both emit a signal named <tt>"length"</tt>, then
a listener that subscribes to <tt>"length"</tt> at some higher compound module
will get notifications from both <tt>Queue</tt> and <tt>Buffer</tt> module
instances. The listener can still look at the source of the signal if it
wants to distinguish the two (it is available as a parameter to the
callback function), but the signals framework itself does not have such a
feature.

<p><ul class="note"><b>NOTE</b><br>
  Because the component type that emits the signal is not part of the signal's
  identity, it is advised to choose signal names carefully. A good naming scheme
  facilitates "merging" of signals that arrive from different sources but
  mean the same thing, and reduces the chance of collisions between signals that
  accidentally have the same name but represent different things.
</ul>

<p>When a signal is emitted, it can carry a value with it. This is realized via
overloaded <tt>emit()</tt> methods in components, and overloaded <tt>receiveSignal()</tt>
methods in listeners. The signal value can be of selected primitive types, or an
object pointer; anything that is not feasible to emit as a primitive type may be
wrapped into an object, and emitted as such.

<p><h3><a name="sec192"/>4.14.1 Design Considerations and Rationale</h3>

<p>The implementation of signals is based on the following assumptions:

<p><ul>
  <li> subscribe/unsubscribe operations are rare compared to <tt>emit()</tt>
    calls, so it is <tt>emit()</tt> that needs to be efficient
  <li> the signals mechanism is present in every module, so per-module
    memory overhead must be kept as low as possible
  <li> it is expected that modules and channels will be heavily instrumented
    with signals, and only a subset of signals will actually be used
    (will have listeners) in any particular simulation; therefore,
    the CPU and memory overhead of momentarily unused signals must be
    as low as possible
</ul>

<p>These goals have been achieved in the 4.1 version with the following
implementation. First, the data structure that used to store listeners in
components is dynamically allocated, so if there are no listeners, the
per-component overhead is only the size of the pointer (which will be
<tt>NULL</tt> then).

<p>Second, additionally there are two bitfields in every component that store
which one of the first 64 signals (IDs 0..63) have local listeners and
listeners in ancestor modules.<br><ul><font size=-1>[It is assumed that there will be
typically less than 64 frequently used signals used at a time in a
simulation.]</font></ul> Using these bitfields, it is possible to determine in constant
time for the first 64 signals whether the signal has listeners, so
<tt>emit()</tt> can return immediately if there are none. For other signals,
<tt>emit()</tt> needs to examine the listener lists up to the root every
time. Even if a simulation uses more than 64 signals, in
performance-critical situations it is possible to arrange that frequently
emitted signals (e.g. <tt>"txBegin"</tt>) get the &#8220;fast&#8221; signal IDs, while
infrequent signals (like e.g. <tt>"routerDown"</tt>) get the rest.

<p>
<h3><a name="sec193"/>4.14.2 The Signals Mechanism</h3>
<a name="sec:simple-modules:signals-api"></a>

<p>Signal-related methods are declared on <tt><a href="../api/classcComponent.html">cComponent</a></tt>, so they are available
for both <tt><a href="../api/classcModule.html">cModule</a></tt> and <tt><a href="../api/classcChannel.html">cChannel</a></tt>.

<p><p class="subheading">Signal IDs</p>

<p>Signals are identified by names, but internally numeric signal IDs are used
for efficiency. The <tt>registerSignal()</tt> method takes a signal name as
parameter, and returns the corresponding <tt>simsignal_t</tt> value.
The method is static, illustrating the fact that signal names are global.
An example:

<pre class="cpp">
simsignal_t lengthSignalId = registerSignal("length");
</pre>
<p>
The <tt>getSignalName()</tt> method (also static) does the reverse:
it accepts a <tt>simsignal_t</tt>, and returns the name of the signal as
<tt>const char *</tt> (or <tt>NULL</tt> for invalid signal handles):

<pre class="cpp">
const char *signalName = getSignalName(lengthSignalId); // --&gt; "length"
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  Since OMNeT++ 4.3, the lifetime of signal IDs is the entire program, and
  it is possible to call <tt>registerSignal()</tt> from initializers of
  global variables, e.g. static class members. In earlier versions,
  signal IDs were usually allocated in <tt>initialize()</tt>, and were
  only valid for that simulation run.
</ul>

<p><p class="subheading">Emitting Signals</p>

<p>The <tt>emit()</tt> family of functions emit a signal from the module or
channel. They take two parameters, the signal ID (<tt>simsignal_t</tt>) and
the value:

<pre class="cpp">
emit(lengthSignalId, queue.length());
</pre>
<p>
The value can be of type <tt>bool</tt>, <tt>long</tt>, <tt>double</tt>, <tt>simtime_t</tt>,
<tt>const char *</tt>, or <tt>(const) <a href="../api/classcObject.html">cObject</a> *</tt>. Other types can be cast into
one of these types, or wrapped into an object subclassed from <tt><a href="../api/classcObject.html">cObject</a></tt>.

<p>When there are no listeners, the runtime cost of <tt>emit()</tt> is usually minimal.
However, if producing a value has a significant runtime cost, then the
<tt>mayHaveListeners()</tt> or <tt>hasListeners()</tt> method can be used
to check beforehand whether the given signal has any listeners at all --
if not, emitting the signal can be skipped. For some signals (in OMNeT++ 4.3,
the first 64 signals used), the information whether it has listeners is cached per
component, and can be produced in constant time.

<p>Example usage:

<pre class="cpp">
if (mayHaveListeners(distanceToTargetSignal))
{
    double d = sqrt((x-targetX)*(x-targetX) + (y-targetY)*(y-targetY));
    emit(distanceToTargetSignal, d);
}
</pre>
<p>
The <tt>mayHaveListeners()</tt> method is very efficient (a constant-time
operation) because it only uses this cached information; if the state is
not cached for the signal, it just returns <tt>true</tt>. In contrast,
<tt>hasListeners()</tt> will search up to the top of the module tree if
the answer is not cached, so it is generally slower. We recommend that
you take into account the cost of producing notification information when
deciding between <tt>mayHaveListeners()</tt> and <tt>hasListeners()</tt>.

<p><p class="subheading">Signal Declarations</p>

<p>Since OMNeT++ 4.4, signals can be declared in NED files for documentation
purposes, and OMNeT++ can check that only declared signals are emitted,
and that they actually conform to the declarations (with regard to the
data type, etc.)

<p>The following example declares a queue module that emits a signal named
<tt>queueLength</tt>:

<pre class="ned">
simple Queue
{
    parameters:
        @signal[queueLength](type=long);
        ...
}
</pre>
<p>
As you can see, signals are declared with the <b><tt>@signal</tt></b> property on
the module or channel that emits it. (NED properties are described in
<a href="#sec135">[3.12]</a>). The property index corresponds
to the signal name, and the property's body may declare various attributes
of the signal; currently only the data type is supported.

<p>The <tt>type</tt> property key is optional; when present, its value should be
<tt>bool</tt>, <tt>long</tt>, <tt>unsigned long</tt>, <tt>double</tt>, <tt>simtime_t</tt>,
<tt>string</tt>, or a registered class name optionally followed by a question
mark. Classes can be registered using the <tt>Register_Class()</tt> or
<tt>Register_Abstract_Class()</tt> macros; these macros create a
<tt><a href="../api/classcObjectFactory.html">cObjectFactory</a></tt> instance, and the simulation kernel will call
<tt><a href="../api/classcObjectFactory.html">cObjectFactory</a></tt>'s <tt>isInstance()</tt> method to check that the
emitted object is really a subclass of the declared class.
<tt>isInstance()</tt> just wraps a C++ <tt>dynamic_cast</tt>.)

<p>A question mark after the class name means that the signal is allowed to
emit <tt>NULL</tt> pointers. For example, a module named <tt>PPP</tt> may emit
the frame (packet) object every time it starts transmiting, and emit
<tt>NULL</tt> when the transmission is completed:

<pre class="ned">
simple PPP
{
    parameters:
        @signal[txFrame](type=PPPFrame?);  // a PPPFrame or NULL
        ...
}
</pre>
<p>
The property index may contain wildcards, which is important if you want
to declare signals whose names are only known at runtime. For example, if
a module emits signals called <tt>session-1-seqno</tt>, <tt>session-2-seqno</tt>,
<tt>session-3-seqno</tt>, etc. for the individual sessions it handles, you
can declare those signals as:

<pre class="ned">
    @signal[session-*-seqno]();
</pre>
<p>

<p><p class="subheading">Enabling Signal Checking</p>

<p>In OMNeT++ 4.x, signal checking is turned off by default. You can turn it
on with the <b><tt>check-signals</tt></b> configuration option in <tt>omnetpp.ini</tt>:

<pre class="inifile">
check-signals = true
</pre>
<p>
It is expected that starting with OMNeT++ 5.0, signal checking will be
turned on by default when the simulation kernel is compiled in debug mode.
It will continue to be turned off in release mode simulation kernels due to
performance reasons.

<p>
<p class="subheading">Signal Data Objects</p>

<p>When emitting a signal with a <tt><a href="../api/classcObject.html">cObject</a>*</tt> pointer, you can pass as data
an object that you already have in the model, provided you have a suitable
object at hand. However, it is often necessary to declare a custom class
to hold all the details, and fill in an instance just for the purpose of
emitting the signal.

<p>The custom notification class must be derived from <tt><a href="../api/classcObject.html">cObject</a></tt>.
We recommend that you also add <tt><a href="../api/classnoncopyable.html">noncopyable</a></tt> as a base class, because
then you don't need to write a copy constructor, assignment operator, and
<tt>dup()</tt> function, sparing some work. When emitting the signal, you
can create a temporary object, and pass its pointer to the <tt>emit()</tt>
function.

<p>An example of custom notification classes is the firing of model change notifications
(see <a href="#sec194">[4.14.3]</a>). The data class
that accompanies a signal that announces that a gate or gate vector is
about to be created looks like this:

<pre class="cpp">
class <a href="../api/classcPreGateAddNotification.html">cPreGateAddNotification</a> : public <a href="../api/classcObject.html">cObject</a>, <a href="../api/classnoncopyable.html">noncopyable</a>
{
  public:
    <a href="../api/classcModule.html">cModule</a> *module;
    const char *gateName;
    <a href="../api/classcGate.html">cGate</a>::Type gateType;
    bool isVector;
};
</pre>
<p>
And the code that emits the signal:

<pre class="cpp">
if (hasListeners(PRE_MODEL_CHANGE))
{
    <a href="../api/classcPreGateAddNotification.html">cPreGateAddNotification</a> tmp;
    tmp.module = this;
    tmp.gateName = gatename;
    tmp.gateType = type;
    tmp.isVector = isVector;
    emit(PRE_MODEL_CHANGE, &tmp);
}
</pre>
<p>

<p><p class="subheading">Subscribing to Signals</p>

<p>The <tt>subscribe()</tt> method registers a listener for a signal.
Listeners are objects that extend the <tt><a href="../api/classcIListener.html">cIListener</a></tt> class.
The same listener object can be subscribed to multiple signals.
<tt>subscribe()</tt> has two arguments: the signal and a pointer to
the listener object:

<pre class="cpp">
<a href="../api/classcIListener.html">cIListener</a> *listener = ...;
simsignal_t lengthSignalId = registerSignal("length");
subscribe(lengthSignalId, listener);
</pre>
<p>
For convenience, the <tt>subscribe()</tt> method has a variant
that takes the signal name directly, so the <tt>registerSignal()</tt>
call can be omitted:

<pre class="cpp">
<a href="../api/classcIListener.html">cIListener</a> *listener = ...;
subscribe("length", listener);
</pre>
<p>
One can also subscribe at other modules, not only the local one.
For example, in order to get signals from all parts of the model,
one can subscribe at the system module level:

<pre class="cpp">
<a href="../api/classcIListener.html">cIListener</a> *listener = ...;
simulation.getSystemModule()-&gt;subscribe("length", listener);
</pre>
<p>
The <tt>unsubscribe()</tt> method has the same parameter list
as <tt>subscribe()</tt>, and unregisters the given listener
from the signal:

<pre class="cpp">
unsubscribe(lengthSignalId, listener);
</pre>
<p>
or

<pre class="cpp">
unsubscribe("length", listener);
</pre>
<p>
It is an error to subscribe the same listener to the same
signal twice.

<p><ul class="note"><b>NOTE</b><br>
  When a listener is deleted, it must already be unsubscribed from
  all components it has subscribed to. This is explained in
  <a href="#sec193">[4.14.2]</a>.
</ul>

<p>It is possible to test whether a listener is subscribed to a signal,
using the <tt>isSubscribed()</tt> method which also takes the same
parameter list.

<pre class="cpp">
if (isSubscribed(lengthSignalId, listener))
{
    ...
}
</pre>
<p>
For completeness, there are methods for getting the list of signals
that the component has subscribed to (<tt>getLocalListenedSignals()</tt>),
and the list of listeners for a given signal (<tt>getLocalSignalListeners()</tt>).
The former returns <tt>std::vector&lt;simsignal_t&gt;</tt>; the latter takes
a signal ID (<tt>simsignal_t</tt>) and returns <tt>std::vector&lt;<a href="../api/classcIListener.html">cIListener</a>*&gt;</tt>.

<p>The following example prints the number of listeners for each signal:

<pre class="cpp">
EV &lt;&lt; "Signal listeners:\n";
std::vector&lt;simsignal_t&gt; signals = getLocalListenedSignals();
for (unsigned int i = 0; i &lt; signals.size(); i++) {
    simsignal_t signalID = signals[i];
    std::vector&lt;<a href="../api/classcIListener.html">cIListener</a>*&gt; listeners = getLocalSignalListeners(signalID);
    EV &lt;&lt; getSignalName(signalID) &lt;&lt; ": " &lt;&lt; listeners.size() &lt;&lt; " signals\n";
}
</pre>
<p>
<p class="subheading">Listeners</p>

<p>Listeners are objects that subclass from the <tt><a href="../api/classcIListener.html">cIListener</a></tt> class, which
declares the following methods:

<pre class="cpp">
class <a href="../api/classcIListener.html">cIListener</a>
{
  public:
    virtual ~<a href="../api/classcIListener.html">cIListener</a>() {}
    virtual void receiveSignal(<a href="../api/classcComponent.html">cComponent</a> *src, simsignal_t id, bool b) = 0;
    virtual void receiveSignal(<a href="../api/classcComponent.html">cComponent</a> *src, simsignal_t id, long l) = 0;
    virtual void receiveSignal(<a href="../api/classcComponent.html">cComponent</a> *src, simsignal_t id, double d) = 0;
    virtual void receiveSignal(<a href="../api/classcComponent.html">cComponent</a> *src, simsignal_t id, simtime_t t) = 0;
    virtual void receiveSignal(<a href="../api/classcComponent.html">cComponent</a> *src, simsignal_t id, const char *s) = 0;
    virtual void receiveSignal(<a href="../api/classcComponent.html">cComponent</a> *src, simsignal_t id, <a href="../api/classcObject.html">cObject</a> *obj) = 0;
    virtual void finish(<a href="../api/classcComponent.html">cComponent</a> *component, simsignal_t id) {}
    virtual void subscribedTo(<a href="../api/classcComponent.html">cComponent</a> *component, simsignal_t id) {}
    virtual void unsubscribedFrom(<a href="../api/classcComponent.html">cComponent</a> *component, simsignal_t id) {}
};
</pre>
<p>
This class has a number of virtual methods:

<p><ul>
  <li> Several overloaded <tt>receiveSignal()</tt> methods, one for each
    data type. Whenever a signal is emitted (via <tt>emit()</tt>),
    the matching <tt>receiveSignal()</tt> methods of subscribed listeners
    are invoked.
  <li> <tt>finish()</tt> is called by a component on its local listeners
    after the component's <tt>finish()</tt> method was called. If the listener
    is subscribed to multiple signals or at multiple components, the method
    will be called multiple times. Note that <tt>finish()</tt> methods in general
    are not invoked if the simulation terminates with an error, so this method
    is not a place for doing cleanup.
  <li> <tt>subscribedTo()</tt>, <tt>unsubscribedFrom()</tt> are called
    when this listener object is subscribed/unsubscribed to (from) a signal.
    These methods give the opportunity for listeners to track whether
    and where they are subscribed. It is also OK for a listener to delete
    itself in the last statement of the <tt>unsubscribedFrom()</tt> method,
    but you must be sure that there are no other places the same listener
    is still subscribed.
</ul>

<p>Since <tt><a href="../api/classcIListener.html">cIListener</a></tt> has a large number of pure virtual methods, it is more
convenient to subclass from <tt><a href="../api/classcListener.html">cListener</a></tt>, a do-nothing implementation
instead. It defines <tt>finish()</tt>, <tt>subscribedTo()</tt> and
<tt>unsubscribedFrom()</tt> with an empty body, and the <tt>receiveSignal()</tt>
methods with a bodies that throw a <tt>"Data type not supported"</tt> error.
You can redefine the <tt>receiveSignal()</tt> method(s) whose data type
you want to support, and signals emitted with other (unexpected) data
types will result in an error instead of going unnoticed.

<p>The order in which listeners will be notified is undefined (it is not necessarily
the same order in which listeners were subscribed.)

<p><p class="subheading">Listener Life Cycle</p>
<a name="sec:simple-modules:signals:life-cycle"></a>

<p>When a component (module or channel) is deleted, it automatically
unsubscribes (but does not delete) the listeners it has. When a
module is deleted, it first unsubscribes all listeners from all
modules and channels in its submodule tree before starting
to recursively delete the modules and channels themselves.

<p>When a listener is deleted, it must already be unsubscribed from all
components at that point. If it is not unsubscribed, pointers to the dead
listener object will be left in the components' listener lists, and the
components will crash inside an <tt>emit()</tt> call, or when they
try to invoke <tt>unsubscribedFrom()</tt> on the dead listener from their
destructors. The <tt><a href="../api/classcIListener.html">cIListener</a></tt> class contains a subscription count,
and prints a warning message when it is not zero in the destructor.

<p><ul class="note"><b>NOTE</b><br>
  If your module has added listeners to other modules (e.g. the toplevel
  module), these listeners must be unsubscribed in the module
  destructor at latest. Remember to make sure the modules still exist before you
  call <tt>unsubscribe()</tt> on them, unless they are an ancestor
  of your module in the module tree.
</ul>

<p>
<h3><a name="sec194"/>4.14.3 Listening to Model Changes</h3>
<a name="sec:ch-simple-modules:model-change"></a>

<p>In simulation models it is often useful to hold references to other
modules, a connecting channel or other objects, or to cache information
derived from the model topology. However, such pointers or data may
become invalid when the model changes at runtime, and need to be updated
or recalculated. The problem is how to get notification that something has
changed in the model.

<p><ul class="note"><b>NOTE</b><br>
  Whenever you see a <tt><a href="../api/classcModule.html">cModule</a>*</tt>, <tt><a href="../api/classcChannel.html">cChannel</a>*</tt>, <tt><a href="../api/classcGate.html">cGate</a>*</tt> or
  similar pointer kept as state in a simple module, you should think about
  how it will be kept up-to-date if the model changes at runtime.
</ul>

<p>The solution is, of course, signals. OMNeT++ has two built-in signals,
<tt>PRE_MODEL_CHANGE</tt> and <tt>POST_MODEL_CHANGE</tt> (these macros
are <tt>simsignal_t</tt> values, not names) that are emitted before and
after each model change.

<p>Pre/post model change notifications are emitted with data objects that
carry the details of the change. The data classes are:

<p><ul>
  <li> <tt><a href="../api/classcPreModuleAddNotification.html">cPreModuleAddNotification</a></tt> / <tt><a href="../api/classcPostModuleAddNotification.html">cPostModuleAddNotification</a></tt>
  <li> <tt><a href="../api/classcPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a></tt> / <tt><a href="../api/classcPostModuleDeleteNotification.html">cPostModuleDeleteNotification</a></tt>
  <li> <tt><a href="../api/classcPreModuleReparentNotification.html">cPreModuleReparentNotification</a></tt> / <tt><a href="../api/classcPostModuleReparentNotification.html">cPostModuleReparentNotification</a></tt>
  <li> <tt><a href="../api/classcPreGateAddNotification.html">cPreGateAddNotification</a></tt> / <tt><a href="../api/classcPostGateAddNotification.html">cPostGateAddNotification</a></tt>
  <li> <tt><a href="../api/classcPreGateDeleteNotification.html">cPreGateDeleteNotification</a></tt> / <tt><a href="../api/classcPostGateDeleteNotification.html">cPostGateDeleteNotification</a></tt>
  <li> <tt><a href="../api/classcPreGateVectorResizeNotification.html">cPreGateVectorResizeNotification</a></tt> / <tt><a href="../api/classcPostGateVectorResizeNotification.html">cPostGateVectorResizeNotification</a></tt>
  <li> <tt><a href="../api/classcPreGateConnectNotification.html">cPreGateConnectNotification</a></tt> / <tt><a href="../api/classcPostGateConnectNotification.html">cPostGateConnectNotification</a></tt>
  <li> <tt><a href="../api/classcPreGateDisconnectNotification.html">cPreGateDisconnectNotification</a></tt> / <tt><a href="../api/classcPostGateDisconnectNotification.html">cPostGateDisconnectNotification</a></tt>
  <li> <tt><a href="../api/classcPrePathCreateNotification.html">cPrePathCreateNotification</a></tt> / <tt><a href="../api/classcPostPathCreateNotification.html">cPostPathCreateNotification</a></tt>
  <li> <tt><a href="../api/classcPrePathCutNotification.html">cPrePathCutNotification</a></tt> / <tt><a href="../api/classcPostPathCutNotification.html">cPostPathCutNotification</a></tt>
  <li> <tt><a href="../api/classcPreParameterChangeNotification.html">cPreParameterChangeNotification</a></tt> / <tt><a href="../api/classcPostParameterChangeNotification.html">cPostParameterChangeNotification</a></tt>
  <li> <tt><a href="../api/classcPreDisplayStringChangeNotification.html">cPreDisplayStringChangeNotification</a></tt> / <tt><a href="../api/classcPostDisplayStringChangeNotification.html">cPostDisplayStringChangeNotification</a></tt>
</ul>

<p>They all subclass from <tt><a href="../api/classcModelChangeNotification.html">cModelChangeNotification</a></tt>, which is of course a
<tt><a href="../api/classcObject.html">cObject</a></tt>. Inside the listener, you can use <tt>dynamic_cast&lt;&gt;</tt> to figure
out what notification arrived.

<p><ul class="note"><b>NOTE</b><br>
  Please look up these classes in the API documentation to see their data fields,
  when exactly they get fired, and what one needs to be careful about when using them.
</ul>

<p>An example listener that prints a message when a module is deleted:

<pre class="cpp">
class MyListener : public <a href="../api/classcListener.html">cListener</a>
{
   ...
};

void MyListener::receiveSignal(<a href="../api/classcComponent.html">cComponent</a> *src, simsignal_t id, <a href="../api/classcObject.html">cObject</a> *obj)
{
    if (dynamic_cast&lt;<a href="../api/classcPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a> *&gt;(obj))
    {
        <a href="../api/classcPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a> *data = (<a href="../api/classcPreModuleDeleteNotification.html">cPreModuleDeleteNotification</a> *)obj;
        EV &lt;&lt; "Module " &lt;&lt; data-&gt;module-&gt;getFullPath() &lt;&lt; " is about to be deleted\n";
    }
}
</pre>
<p>
If you'd like to get notification about the deletion of any module, you need
to install the listener on the system module:

<pre class="cpp">
simulation.getSystemModule()-&gt;subscribe(PRE_MODEL_CHANGE, listener);
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  <tt>PRE_MODEL_CHANGE</tt> and <tt>POST_MODEL_CHANGE</tt> are fired on the
  module (or channel) affected by the change, and <i>not</i> on the module
  which executes the code that causes the change. For example,
  <i>pre-module-deleted</i> is fired on the module to be removed, and
  <i>post-module-deleted</i> is fired on its parent (because the original
  module no longer exists), and not on the module that contains the
  <tt>deleteModule()</tt> call.
</ul>

<p><ul class="note"><b>NOTE</b><br>
  A listener will <i>not</i> receive <i>pre/post-module-deleted</i>
  notifications if the whole submodule tree that contains the subscription
  point is deleted. This is because compound module destructors begin
  by unsubscribing all modules/channels in the subtree before starting
  recursive deletion.
</ul>

<p>
<h2><a name="sec195"/>4.15 Signal-Based Statistics Recording</h2>
<a name="sec:ch-simple-modules:statistic-signals"></a>

<p><h3><a name="sec196"/>4.15.1 Motivation</h3>

<p>One use of signals is to expose variables for result collection without
telling where, how, and whether to record them. With this approach,
modules only publish the variables, and the actual result recording
takes place in listeners. Listeners may be added by the simulation
framework (based on the configuration), or by other modules (for example
by dedicated result collection modules).

<p>The signals approach allows for several possibilities:

<p><ul>
 <li> Provides a controllable level of detail: in some simulation runs
    you may want to record all values as a time series, in other runs
    only record the mean, time average, minimum/maximum value, standard
    deviation etc, and in yet other runs you may want to record the
    distribution as a histogram;
 <li> Depending on the purpose of the simulation experiment, you may want
    to process the results before recording them, for example
    record a smoothed or filtered value, record the percentage of time the
    value is nonzero or over a threshold, record the sum of the values, etc.;
 <li> You may want aggregate statistics, e.g. record the total number
    of packet drops or the average end-to-end delay for the whole network;
 <li> You may want to record combined statistics, for example a drop
    percentage (drop count/total number of packets);
 <li> You may want to ignore results generated during the warm-up period
    or during other transients.
</ul>

<p>With the signals approach the above goals can be fulfilled.

<p>
<h3><a name="sec197"/>4.15.2 Declaring Statistics</h3>
<a name="sec:ch-simple-modules:declaring-statistics"></a>

<p><p class="subheading">Introduction</p>

<p>In order to record simulation results based on signals, one must add
<b><tt>@statistic</tt></b> properties to the simple module's (or channel's) NED
definition. A <b><tt>@statistic</tt></b> property defines the name of the
statistic, which signal(s) are used as input, what processing steps are to
be applied to them (e.g. smoothing, filtering, summing, differential
quotient), and what properties are to be recorded (minimum, maximum,
average, etc.) and in which form (vector, scalar, histogram). Record items
can be marked optional, which lets you denote a <i>&#8220;default&#8221;</i> and a
more comprehensive <i>&#8220;all&#8221;</i> result set to be recorded; the list of
record items can be further tweaked from the configuration. One can also
specify a descriptive name (&#8220;title&#8221;) for the statistic, and also a
measurement unit.

<p>The following example declares a queue module with a queue length statistic:

<pre class="ned">
simple Queue
{
    parameters:
        @statistic[queueLength](record=max,timeavg,vector?);
    gates:
        input in;
        output out;
}
</pre>
<p>
As you can see, statistics are represented with indexed NED properties (see
<a href="#sec135">[3.12]</a>). The property name is always
<tt>statistic</tt>, and the index (here, <tt>queueLength</tt>) is the
name of the statistic. The property value, that is, everything inside the
parentheses, carries hints and extra information for recording.

<p>The above <tt>@statistic</tt> declaration assumes that module's C++ code
emits the queue's updated length as signal <tt>queueLength</tt> whenever
elements are inserted into the queue or are removed from it.
By default, the maximum and the time average of the queue length will
be recorded as scalars. One can also instruct the simulation (or parts
of it) to record &#8220;all&#8221; results; this will turn on optional record items,
those marked with a question mark, and then the queue lengths will also be
recorded into an output vector.

<p><ul class="note"><b>NOTE</b><br>
The configuration lets you fine-tune the list of result items even
beyond the <tt>default</tt> and <tt>all</tt> settings; see section
<a href="#sec409">[12.2.4]</a>.
</ul>

<p>In the above example, the signal to be recorded was taken from the
statistic name. When that is not suitable, the <tt>source</tt> property key
lets you specify a different signal as input for the statistic. The
following example assumes that the C++ code emits a <tt>qlen</tt> signal, and
declares a <tt>queueLength</tt> statistic based on that:

<pre class="ned">
simple Queue
{
    parameters:
        @signal[qlen](type=int); // optional
        @statistic[queueLength](source=qlen; record=max,timeavg,vector?);
        ...
}
</pre>
<p>
Note that beyond the <tt>source=qlen</tt> property key we have also added
a signal declaration (<b><tt>@signal</tt></b> property) for the <tt>qlen</tt> signal.
Declaring signals is currently optional and in fact <tt>@signal</tt> properties
are currently ignored by the system, but it is a good practice nevertheless.

<p>It is also possible to apply processing to a signal before recording it.
Consider the following example:

<pre class="ned">
@statistic[dropCount](source=count(drop); record=last,vector?);
</pre>
<p>
This records the total number of packet drops as a scalar, and
optionally the number of packets dropped in the function of time as a
vector, provided the C++ code emits a <tt>drop</tt> signal every time a packet
is dropped. The value and even the data type of the <tt>drop</tt> signal is
indifferent, because only the number of emits will be counted.
Here, <tt>count()</tt> is a <i>result filter</i>.

<p><ul class="note"><b>NOTE</b><br>
Starting from OMNeT++ 4.4, items containing parens (e.g. <tt>count(drop)</tt>)
no longer need to be enclosed in quotation marks.
</ul>

<p>Another example:

<pre class="ned">
@statistic[droppedBytes](source=sum(packetBytes(pkdrop)); record=last,
vector?);
</pre>
<p>
This example assumes that the C++ code emits a <tt>pkdrop</tt> signal with a
packet (<tt><a href="../api/classcPacket.html">cPacket</a>*</tt> pointer) as a value. Based on that signal, it
records the total number of bytes dropped (as a scalar, and optionally as a
vector too). The <tt>packetBytes()</tt> filter extracts the number of bytes
from each packet using <tt><a href="../api/classcPacket.html">cPacket</a></tt>'s <tt>getByteLength()</tt> method,
and the <tt>sum()</tt> filter, well, sums them up.

<p>Arithmetic expressions can also be used. For example, the following line
computes the number of dropped bytes using the <tt>packetBits()</tt> filter.

<pre class="ned">
@statistic[droppedBytes](source=sum(8*packetBits(pkdrop)); record=last,
vector?);
</pre>
<p>
The source can also combine multiple signals in an arithmetic expression:

<pre class="ned">
@statistic[dropRate](source=count(drop)/count(pk); record=last,vector?);
</pre>
<p>
When multiple signals are used, a value arriving on either signal will
result in one output value. The computation will use the last values of the
other signals (sample-hold interpolation). One limitation regarding
multiple signals is that the same signal cannot occur twice, because it
would cause glitches in the output.

<p>Record items may also be expressions and contain filters. For example, the
statistic below is functionally equivalent to one of the above examples: it
also computes and records as scalar and as vector the total number of bytes
dropped, using a <tt><a href="../api/classcPacket.html">cPacket</a>*</tt>-valued signal as input; however, some of
the computations have been shifted into the recorder part.

<pre class="ned">
@statistic[droppedBytes](source=packetBits(pkdrop); record=last(8*sum),
vector(8*sum)?);
</pre>
<p>

<p><p class="subheading">Property Keys</p>

<p>The following keys are understood in <b><tt>@statistic</tt></b> properties:

<p><dl>
  <li><b>source</b> : Defines the input for the recorders (see <tt>record=</tt> key).
     When missing, the statistic name is taken as the signal name;
  <li><b>record</b> : Contains a list of recording modes, separated by comma.
     Recording modes define how to record the source (see <tt>source=</tt> key).
  <li><b>title</b> : A longer, descriptive name for the statistic signal; result
      visualization tools may use it as chart label, e.g. in the legend.
  <li><b>unit</b> : Measurement unit of the values. This may also appear in charts.
  <li><b>interpolationmode</b> : Defines how to interpolate signal values where
      needed (e.g. for drawing); possible values are <tt>none</tt>,
      <tt>sample-hold</tt>, <tt>backward-sample-hold</tt>, <tt>linear</tt>.
  <li><b>enum</b> : Defines symbolic names for various integer signal values.
      The property value must be a string, containing <i>name=value</i> pairs
      separated by comma. Example: <tt>"IDLE=1,BUSY=2,DOWN=3"</tt>.
</dl>

<p>
<p class="subheading">Available Filters and Recorders</p>

<p>The following table contains the list of predefined result filters.
All filters in the table output a value for each input value.

<p><table border>
<TR> <TD align=left>
  
<p>  <b>Filter</b> </TD> <TD align=left> <b>Description</b> </TD></TR>
<TR> <TD align=left>   <tt>count</tt> </TD> <TD align=left> Computes and outputs the count of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>sum</tt> </TD> <TD align=left> Computes and outputs the sum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>min</tt> </TD> <TD align=left> Computes and outputs the minimum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>max</tt> </TD> <TD align=left> Computes and outputs the maximum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>mean</tt> </TD> <TD align=left> Computes and outputs the average (sum / count) of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>timeavg</tt> </TD> <TD align=left> Regards the input values and their timestamps as a step function (sample-hold style), and
                  computes and outputs its time average (integral divided by duration). </TD></TR>
<TR> <TD align=left>   <tt>constant0</tt> </TD> <TD align=left> Outputs a constant 0 for each received value (independent of the value). </TD></TR>
<TR> <TD align=left>   <tt>constant1</tt> </TD> <TD align=left> Outputs a constant 1 for each received value (independent of the value). </TD></TR>
<TR> <TD align=left>   <tt>packetBits</tt> </TD> <TD align=left> Expects <tt><a href="../api/classcPacket.html">cPacket</a></tt> pointers as value, and outputs the bit length
                     for each received one. Non-<tt><a href="../api/classcPacket.html">cPacket</a></tt> values are ignored. </TD></TR>
<TR> <TD align=left>   <tt>packetBytes</tt> </TD> <TD align=left> Expects <tt><a href="../api/classcPacket.html">cPacket</a></tt> pointers as value, and outputs the byte length
                      for each received one. Non-<tt><a href="../api/classcPacket.html">cPacket</a></tt> values are ignored. </TD></TR>
<TR> <TD align=left>   <tt>sumPerDuration</tt> </TD> <TD align=left> For each value, computes the sum of values received so far,
                         divides it by the duration, and outputs the result. </TD></TR>
<TR> <TD align=left>   <tt>removeRepeats</tt> </TD> <TD align=left> Removes repeated values, i.e. discards values that are the same as the previous value. </TD></TR>
</table>

<p>The list of predefined result recorders:

<p><table border>
<TR> <TD align=left>
  
<p>  <b>Recorder</b> </TD> <TD align=left> <b>Description</b> </TD></TR>
<TR> <TD align=left>   <tt>last</tt> </TD> <TD align=left> Records the last value into an output scalar. </TD></TR>
<TR> <TD align=left>   <tt>count</tt> </TD> <TD align=left> Records the count of the input values into an output scalar;
                functionally equivalent to <tt>last(count)</tt> </TD></TR>
<TR> <TD align=left>   <tt>sum</tt> </TD> <TD align=left> Records the sum of the input values into an output scalar
              (or zero if there was none);
              functionally equivalent to <tt>last(sum)</tt> </TD></TR>
<TR> <TD align=left>   <tt>min</tt> </TD> <TD align=left> Records the minimum of the input values into an output scalar
              (or positive infinity if there was none);
              functionally equivalent to <tt>last(min)</tt> </TD></TR>
<TR> <TD align=left>   <tt>max</tt> </TD> <TD align=left> Records the maximum of the input values into an output scalar
              (or negative infinity if there was none);
              functionally equivalent to <tt>last(max)</tt> </TD></TR>
<TR> <TD align=left>   <tt>mean</tt> </TD> <TD align=left> Records the mean of the input values into an output scalar
               (or NaN if there was none);
               functionally equivalent to <tt>last(mean)</tt> </TD></TR>
<TR> <TD align=left>   <tt>timeavg</tt> </TD> <TD align=left> Regards the input values with their timestamps as a step
               function (sample-hold style), and records the time average of the
               input values into an output scalar;
               functionally equivalent to <tt>last(timeavg)</tt> </TD></TR>
<TR> <TD align=left>   <tt>stats</tt> </TD> <TD align=left> Computes basic statistics (count, mean, std.dev, min, max) from the input values,
                and records them into the output scalar file as a statistic object. </TD></TR>
<TR> <TD align=left>   <tt>histogram</tt> </TD> <TD align=left> Computes a histogram and basic statistics (count, mean, std.dev, min, max)
                from the input values, and records the reslut into the output scalar file
                as a histogram object. </TD></TR>
<TR> <TD align=left>   <tt>vector</tt> </TD> <TD align=left> Records the input values with their timestamps into an output vector. </TD></TR>
</table>

<p><ul class="note"><b>NOTE</b><br>
You can have the list of available result filters and result recorders
printed by executing the <tt>opp_run -h resultfilters</tt> and <tt>opp_run
-h resultrecorders</tt> commands.
</ul>

<p>
<p class="subheading">Naming and Attributes of Recorded Results</p>

<p>The names of recorded result items will be formed by concatenating the
statistic name and the recording mode with a colon between them:
<tt>"<i>&lt;statisticName&gt;</i>:<i>&lt;recordingMode&gt;</i>"</tt>.

<p>Thus, the following statistics

<pre class="ned">
@statistic[dropRate](source=count(drop)/count(pk); record=last,vector?);
@statistic[droppedBytes](source=packetBytes(pkdrop); record=sum,vector(sum)?);
</pre>
<p>
will produce the following scalars: <tt>dropRate:last</tt>, <tt>droppedBytes:sum</tt>,
and the following vectors: <tt>dropRate:vector</tt>, <tt>droppedBytes:vector(sum)</tt>.

<p>All property keys (except for <tt>record</tt>) are recorded as result
attributes into the vector file or scalar file. The <tt>title</tt> property
will be tweaked a little before recording: the recording mode will be added
after a comma, otherwise all result items saved from the same statistic
would have exactly the same name.

<p>Example: "Dropped Bytes, sum", "Dropped Bytes, vector(sum)"

<p>
It is allowed to use other property keys as well, but they won't be
interpreted by the OMNeT++ runtime or the result analysis tool.

<p>
<p class="subheading">Source and Record Expressions in Detail</p>

<p>To fully understand <tt>source</tt> and <tt>record</tt>, it will be useful to see
how result recording is set up.

<p>When a module or channel is created in the simulation, the OMNeT++ runtime
examines the <tt>@statistic</tt> properties on its NED declaration, and adds
listeners on the signals they mention as input. There are two kinds of
listeners associated with result recording: <i>result filters</i> and
<i>result recorders</i>. Result filters can be chained, and at the end of
the chain there is always a recorder. So, there may be a recorder directly
subscribed to a signal, or there may be a chain of one or more filters plus
a recorder. Imagine it as a pipeline, or rather a &#8220;pipe tree&#8221;, where the
tree roots are signals, the leaves are result recorders, and the
intermediate nodes are result filters.

<p>Result filters typically perform some processing on the values they receive
on their inputs (the previous filter in the chain or directly a signal),
and propagate them to their output (chained filters and recorders). A
filter may also swallow (i.e. not propagate) values. Recorders may write
the received values into an output vector, or record output scalar(s)
at the end of the simulation.

<p>Many operations exist both in filter and recorder form. For example, the
<tt>sum</tt> <i>filter</i> propagates the sum of values received on its
input to its output; and the <tt>sum</tt> <i>recorder</i> only computes the
the sum of received values in order to record it as an output scalar on
simulation completion.

<p>The next figure illustrates which filters and recorders are created and how
they are connected for the following statistics:

<pre class="ned">
@statistic[droppedBytes](source=8*packetBits(pkdrop); record=sum,vector(sum));
</pre>
<p>

<p>  <center>
    <img src="statisticrecording.png">
    <center><i>Figure: Result filters and recorders chained</i></center>
  </center>

<p>
<ul class="hint"><b>HINT</b><br>
To see how result filters and recorders have been set up for a particular
simulation, run the simulation with the <b><tt>debug-statistics-recording</tt></b>
configuration option, e.g. specify <tt>--debug-statistics-recording=true</tt>
on the command line.
</ul>

<p>
<h3><a name="sec198"/>4.15.3 Statistics Recording for Dynamically Registered Signals</h3>

<p>It is often convenient to have a module record statistics per session, per
connection, per client, etc. One way of handling this use case is registering
signals dynamically (e.g. <tt>session1-jitter</tt>, <tt>session2-jitter</tt>, ...),
and setting up <b><tt>@statistic</tt></b>-style result recording on each.

<p>The NED file would look like this:

<pre class="ned">
@signal[session*-jitter](type=simtime_t); // note the wildcard
@statisticTemplate[sessionJitter](record=mean,vector?);
</pre>
<p>
In the C++ code of the module, you need to register each new signal with
<tt>registerSignal()</tt>, and in addition, tell OMNeT++ to set up statistics
recording for it as described by the <b><tt>@statisticTemplate</tt></b> property.
The latter can be achieved by calling <tt>ev.addResultRecorders()</tt>.

<pre class="cpp">
char signalName[32];
sprintf(signalName, "session%d-jitter", sessionNum);
simsignal_t signal = registerSignal(signalName);

char statisticName[32];
sprintf(statisticName, "session%d-jitter", sessionNum);
<a href="../api/classcProperty.html">cProperty</a> *statisticTemplate =
    getProperties()-&gt;get("statisticTemplate", "sessionJitter");
ev.addResultRecorders(this, signal, statisticName, statisticTemplate);
</pre>
<p>
In the <b><tt>@statisticTemplate</tt></b> property, the <tt>source</tt> key will be
ignored (because the signal given as parameter will be used as source). The
actual name and index of property will also be ignored. (With
<b><tt>@statistic</tt></b>, the index holds the result name, but here the name is
explicitly specified in the statisticName parameter.)

<p>When multiple signals are recorded using a common <b><tt>@statisticTemplate</tt></b>
property, you'll want the titles of the recorded statistics to differ
for each signal. This can be achieved by using dollar variables in the
<tt>title</tt> key of <b><tt>@statisticTemplate</tt></b>. The following variables
are available:

<p><ul>
  <li> <tt>$name</tt>: name of the statistic
  <li> <tt>$component</tt>: component fullpath
  <li> <tt>$mode</tt>: recording mode
  <li> <tt>$namePart[0-9]+</tt>: given part of statistic name, when split
    along colons (:); numbering starts with 1
</ul>

<p>For example, if the statistic name is <tt>"conn:host1-to-host4(3):bytesSent"</tt>,
and the title is <tt>"bytes sent in connection $namePart2"</tt>, it will become
<tt>"bytes sent in connection host1-to-host4(3)"</tt>.

<p>
<h3><a name="sec199"/>4.15.4 Adding Result Filters and Recorders Programmatically</h3>

<p>As an alternative to <b><tt>@statisticTemplate</tt></b> and <tt>ev.addResultRecorders()</tt>,
it is also possible to set up result recording programmatically, by creating and
attaching result filters and recorders to the desired signals.

<p>The following code example sets up recording to an output vector after
removing duplicate values, and is essentially equivalent to the following
<tt>@statistic</tt> line:

<pre class="ned">
@statistic[queueLength](source=qlen; record=vector(removeRepeats);
                        title="Queue Length"; unit=packets);
</pre>
<p>
The C++ code:

<pre class="cpp">
simsignal_t signal = registerSignal("qlen");

<a href="../api/classcResultFilter.html">cResultFilter</a> *removeRepeatsFilter =
    <a href="../api/classcResultFilterDescriptor.html">cResultFilterDescriptor</a>::get("removeRepeats")-&gt;create();

<a href="../api/classcResultRecorder.html">cResultRecorder</a> *vectorRecorder =
    <a href="../api/classcResultRecorderDescriptor.html">cResultRecorderDescriptor</a>::get("vector")-&gt;create();
<a href="../api/classopp__string__map.html">opp_string_map</a> *attrs = new <a href="../api/classopp__string__map.html">opp_string_map</a>;
(*attrs)["title"] = "Queue Length";
(*attrs)["unit"] = "packets";
vectorRecorder-&gt;init(this, "queueLength", "vector", NULL, attrs);

subscribe(signal, removeRepeatsFilter);
removeRepeatsFilter-&gt;addDelegate(vectorRecorder);
</pre>
<p>

<p><h3><a name="sec200"/>4.15.5 Emitting Signals</h3>

<p>Emitting signals for statistical purposes does not differ much from
emitting signals for any other purpose. Statistic signals are primarily
expected to contain numeric values, so the overloaded <tt>emit()</tt> functions
that take <tt>long</tt>, <tt>double</tt> and <tt>simtime_t</tt> are going to be the
most useful ones.

<p><b>Emitting with timestamp.</b> The emitted values are associated with
the current simulation time. At times it might be desirable to associate
them with a different timestamp, in much the same way as the
<tt>recordWithTimestamp()</tt> method of <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> (see
<a href="#sec292">[7.9.1]</a>) does. For example, assume that you want to
emit a signal at the start of every successful wireless frame reception.
However, whether any given frame reception is going to be successful can
only be known after the reception has completed. Hence, values can only be
emitted at reception completion, and need to be associated with past
timestamps.

<p>To emit a value with a different timestamp, an object containing
a <i>(timestamp, value)</i> pair needs to be filled in, and emitted using
the <tt>emit(simsignal_t, <a href="../api/classcObject.html">cObject</a> *)</tt> method. The class is called
<tt><a href="../api/classcTimestampedValue.html">cTimestampedValue</a></tt>, and it simply has two public data members called
<tt>time</tt> and <tt>value</tt>, with types <tt>simtime_t</tt> and <tt>double</tt>.
It also has a convenience constructor taking these two values.

<p><ul class="note"><b>NOTE</b><br>
<tt><a href="../api/classcTimestampedValue.html">cTimestampedValue</a></tt> is not part of the signal mechanism. Instead,
the result recording listeners provided by OMNeT++ have been written
in a way so that they understand <tt><a href="../api/classcTimestampedValue.html">cTimestampedValue</a></tt>, and know how
to handle it.
</ul>

<p>An example usage:

<pre class="cpp">
simtime_t frameReceptionStartTime = ...;
double receivePower = ...;
<a href="../api/classcTimestampedValue.html">cTimestampedValue</a> tmp(frameReceptionStartTime, receivePower);
emit(recvPowerSignal, &tmp);
</pre>
<p>
If performance is critical, the <tt><a href="../api/classcTimestampedValue.html">cTimestampedValue</a></tt> object may be
made a class member or a static variable to eliminate object
construction/destruction time.<br><ul><font size=-1>[It is safe to use a static
variable here because the simulation program is single-threaded,
but ensure that there isn't a listener somewhere that would modify
the same static variable during firing.]</font></ul>

<p>Timestamps must be monotonically increasing.

<p><b>Emitting non-numeric values.</b> Sometimes it is practical to have
multi-purpose signals, or to retrofit an existing non-statistical signal so
that it can be recorded as a result. For this reason, signals having
non-numeric types (that is, <tt>const char *</tt> and <tt><a href="../api/classcObject.html">cObject</a> *</tt>) may
also be recorded as results. Wherever such values need to be interpreted as
numbers, the following rules are used by the built-in result recording
listeners:

<p><ul>
  <li> Strings are recorded as 1.0, except for <tt>NULL</tt> which is recorded as 0.0;
  <li> Objects that can be cast to <tt><a href="../api/classcITimestampedValue.html">cITimestampedValue</a></tt> are recorded
     using the <tt>getSignalTime()</tt> and <tt>getSignalValue()</tt>
     methods of the class;
  <li> Other objects are recorded as 1.0, except for <tt>NULL</tt> pointers which
     are recorded as 0.0.
</ul>

<p><tt><a href="../api/classcITimestampedValue.html">cITimestampedValue</a></tt> is a C++ interface that may be used as an additional
base class for any class. It is declared like this:

<pre class="cpp">
class <a href="../api/classcITimestampedValue.html">cITimestampedValue</a> {
    public:
        virtual ~<a href="../api/classcITimestampedValue.html">cITimestampedValue</a>() {}
        virtual double getSignalValue(simsignal_t signalID) = 0;
        virtual simtime_t getSignalTime(simsignal_t signalID);
};
</pre>
<p>
<tt>getSignalValue()</tt> is pure virtual (it must return some value),
but <tt>getSignalTime()</tt> has a default implementation that
returns the current simulation time. Note the <tt>signalID</tt> argument
that allows the same class to serve multiple signals (i.e. to return
different values for each).

<p>
<h3><a name="sec201"/>4.15.6 Writing Result Filters and Recorders</h3>

<p>You can define your own result filters and recorders in addition to the
built-in ones. Similar to defining modules and new NED functions, you have
to write the implementation in C++, and then register it with a
registration macro to let OMNeT++ know about it. The new result filter or
recorder can then be used in the <tt>source=</tt> and <tt>record=</tt> attributes
of <b><tt>@statistic</tt></b> properties just like the built-in ones.

<p>Result filters must be subclassed from <tt><a href="../api/classcResultFilter.html">cResultFilter</a></tt> or from one
of its more specific subclasses <tt><a href="../api/classcNumericResultFilter.html">cNumericResultFilter</a></tt> and
<tt><a href="../api/classcObjectResultFilter.html">cObjectResultFilter</a></tt>. The new result filter class needs to be
registered using the <tt>Register_ResultFilter(NAME, CLASSNAME)</tt> macro.

<p>Similarly, a result recorder must subclass from the
<tt><a href="../api/classcResultRecorder.html">cResultRecorder</a></tt> or the more specific
<tt><a href="../api/classcNumericResultRecorder.html">cNumericResultRecorder</a></tt> class, and be registered using the
<tt>Register_ResultRecorder(NAME, CLASSNAME)</tt> macro.

<p>
  <center>
    <img src="resultlistener-inheritance.png">
    <center><i>Figure: Inheritance of result filter and recorder classes</i></center>
  </center>

<p>
An example result filter implementation from the simulation runtime:

<p>
<pre class="cpp">
/**
 * Filter that outputs the sum of signal values divided by the measurement
 * interval (simtime minus warmup period).
 */
class SumPerDurationFilter : public <a href="../api/classcNumericResultFilter.html">cNumericResultFilter</a>
{
    protected:
        double sum;
    protected:
        virtual bool process(simtime_t& t, double& value);
    public:
        SumPerDurationFilter() {sum = 0;}
};

Register_ResultFilter("sumPerDuration", SumPerDurationFilter);

bool SumPerDurationFilter::process(simtime_t& t, double& value)
{
    sum += value;
    value = sum / (simTime() - simulation.getWarmupPeriod());
    return true;
}
</pre>

<p>


<hr class='pgbr'><h1><a name="sec202"/>5 Messages and Packets</h1>
<a name="cha:messages"></a>

<p><h2><a name="sec203"/>5.1 Overview</h2>
<a name="sec:ch-msgs:overview"></a>

<p>Messages are a central concept in OMNeT++. In the model, message objects
represent events, packets, commands, jobs, customers or other kinds of
entities, depending on the model domain.

<p>Messages are represented with the <tt><a href="../api/classcMessage.html">cMessage</a></tt> class and its subclass
<tt><a href="../api/classcPacket.html">cPacket</a></tt>. <tt><a href="../api/classcPacket.html">cPacket</a></tt> is used for network packets (frames,
datagrams, transport packets, etc.) in a communication network, and
<tt><a href="../api/classcMessage.html">cMessage</a></tt> is used for everything else. Users are free to subclass
both <tt><a href="../api/classcMessage.html">cMessage</a></tt> and <tt><a href="../api/classcPacket.html">cPacket</a></tt> to create new types and to
add data.

<p><tt><a href="../api/classcMessage.html">cMessage</a></tt> has the following fields; some are used by
the simulation kernel, and others are provided for the convenience
of the simulation programmer:

<p><ul>
  <li> The <i>name</i> field is a string (<tt>const char *</tt>),
    which can be freely used by the simulation programmer. The message
    name is displayed at many places in the graphical runtime interface,
    so it is generally useful to choose a descriptive name. Message name
    is inherited from <tt><a href="../api/classcObject.html">cObject</a></tt> (see section
    <a href="#sec260">[7.1.1]</a>).
  <li> <i>Message kind</i> is an integer field.
    Some negative values are reserved by the simulation library, but zero
    and positive values can be freely used in the model for any purpose.
    Message kind is typically used to carry a value that conveys the
    role, type, category or identity of the message.
  <li> The <i>scheduling priority</i> field is used by the simulation
    kernel to determine the delivery order of messages that have the same
    arrival time values. This field is rarely used in practice.
  <li> The <i>send time</i>, <i>arrival time</i>, <i>source module</i>,
    <i>source gate</i>, <i>destination module</i>, <i>destination gate</i>
    fields store information about the message's last sending or scheduling,
    and should not be modified from the model. These fields are primarily
    used internally by the simulation kernel while the message is in the
    future events set (FES)<!--FES-->, but the information is still in
    the message object when the message is delivered to a module.
  <li> <i>Time stamp</i> (not to be confused with <i>arrival time</i>)
    is a utility field, which the programmer can freely use for any purpose.
    The time stamp is not examined or changed by the simulation kernel at all.
  <li> The <i>parameter list</i>, <i>control info</i> and
    <i>context pointer</i> fields make some simulation tasks easier
    to program, and they will be discussed later.
</ul>

<p>The <tt><a href="../api/classcPacket.html">cPacket</a></tt> class extends <tt><a href="../api/classcMessage.html">cMessage</a></tt> with fields that are
useful for representing network packets:

<p><ul>
  <li> The <i>packet length</i> field represents the length of the packet
    in bits. It is used by the simulation kernel to compute the transmission
    duration when a packet travels through a connection that has an assigned
    data rate, and also for error modeling on channels with a nonzero
    bit error rate.
  <li> The <i>encapsulated packet</i> field helps modeling protocol layers
    by supporting the concept of encapsulation and decapsulation.
  <li> The <i>bit error flag</i> field carries the result of error
    modelling after the packet is sent through a channel that has a nonzero
    packet error rate (PER) or bit error rate (BER). It is up to the receiver
    to examine this flag after having received the packet, and to act upon it.
  <li> The <i>duration</i> field carries the transmission duration after
    the packet was sent through a channel with a data rate.
  <li> The <i>is-reception-start</i> flag tells whether this packet
    represents the start or the end of the reception after the packet travelled
    through a channel with a data rate. This flag is controlled by the
    <i>deliver-on-reception-start</i> flag of the receiving gate.
</ul>

<p>
<h2><a name="sec204"/>5.2 The <a href="../api/classcMessage.html">cMessage</a> Class</h2>
<a name="sec:ch-msgs:cmessage"></a>

<p><h3><a name="sec205"/>5.2.1 Basic Usage</h3>

<p>The <tt><a href="../api/classcMessage.html">cMessage</a></tt> constructor accepts an <i>object name</i>
and a <i>message kind</i>, both optional:

<pre class="cpp">
<a href="../api/classcMessage.html">cMessage</a>(const char *name=NULL, short kind=0);
</pre>
<p>
Descriptive message names can be very useful when tracing, debugging or
demonstrating the simulation, so it is recommended to use them.
Message kind is usually initialized with a symbolic constant
(e.g. an <i>enum</i> value) which signals what the message object
represents. Only positive values and zero can be used --
negative values are reserved for use by the simulation kernel.

<p>The following lines show some examples of message creation:

<pre class="cpp">
<a href="../api/classcMessage.html">cMessage</a> *msg1 = new <a href="../api/classcMessage.html">cMessage</a>();
<a href="../api/classcMessage.html">cMessage</a> *msg2 = new <a href="../api/classcMessage.html">cMessage</a>("timeout");
<a href="../api/classcMessage.html">cMessage</a> *msg3 = new <a href="../api/classcMessage.html">cMessage</a>("timeout", KIND_TIMEOUT);
</pre>
<p>
Once a message has been created, its basic data members can be set
with the following methods:

<pre class="cpp">
void setName(const char *name);
void setKind(short k);
void setTimestamp();
void setTimestamp(simtime_t t);
void setSchedulingPriority(short p);
</pre>
<p>
The argument-less <tt>setTimeStamp()</tt> method is equivalent to
<tt>setTimeStamp(simTime())</tt>.

<p>The corresponding getter methods are:

<pre class="cpp">
const char *getName() const;
short getKind() const;
simtime_t getTimestamp() const;
short getSchedulingPriority() const;
</pre>
<p>
The <tt>getName()</tt>/<tt>setName()</tt> methods are inherited from
a generic base class in the simulation library, <tt><a href="../api/classcNamedObject.html">cNamedObject</a></tt>.

<p>Two more interesting methods:

<pre class="cpp">
bool isPacket() const;
simtime_t getCreationTime() const;
</pre>
<p>
The <tt>isPacket()</tt> method returns <tt>true</tt> if the particular message
object is a subclass of <tt><a href="../api/classcPacket.html">cPacket</a></tt>, and <tt>false</tt> otherwise. As
<tt>isPacket()</tt> is implemented as a virtual function that just contains
a <tt>return false</tt> or a <tt>return true</tt> statement, it might be faster
than calling <tt>dynamic_cast&lt;<a href="../api/classcPacket.html">cPacket</a>*&gt;</tt>.

<p>The <tt>getCreationTime()</tt> method returns the creation time of the
message. It is worthwhile to mention that with cloned messages (see
<tt>dup()</tt> later), the creation time of the original message is returned
and not the time of the cloning operation. This is particularly useful when
modeling communication protocols, because many protocols clone the
transmitted packages to be able to do retransmissions and/or
segmentation/reassembly.

<p>
<h3><a name="sec206"/>5.2.2 Duplicating Messages</h3>
<!--message!duplication-->

<p>It is often necessary to duplicate a message or a packet, for example,
to send one and keep a copy. Duplication can be done in the same way as
for any other OMNeT++ object:

<pre class="cpp">
<a href="../api/classcMessage.html">cMessage</a> *copy = msg-&gt;dup();
</pre>
<p>
The resulting message (or packet) will be an exact copy of the original
including message parameters and encapsulated messages, except for the
message ID field. The creation time field is also copied, so
for cloned messages <tt>getCreationTime()</tt> will return the creation
time of the original, not the time of the cloning operation.
  <br><ul><font size=-1>[Note, however, that the simulation library may delay the
  duplication of the encapsulated message until it is really needed;
  see section <a href="#sec219">[5.4.5]</a>.]</font></ul>

<p>If you subclass from <tt><a href="../api/classcMessage.html">cMessage</a></tt> or <tt><a href="../api/classcPacket.html">cPacket</a></tt>, you need
to reimplement <tt>dup()</tt>; the recommended implementation is to delegate
to the copy constructor of the new class:

<pre class="cpp">
class FooMessage : public <a href="../api/classcMessage.html">cMessage</a> {
  public:
    FooMessage(const FooMessage& other) {...}
    virtual FooMessage *dup() const {return new FooMessage(*this);}
    ...
};
</pre>
<p>
For generated classes (chapter <a href="#sec224">[6]</a>), this is
taken care of automatically.

<p>
<h3><a name="sec207"/>5.2.3 Message IDs</h3>
<!--message!IDs-->

<p>Every message object has a unique numeric <i>message ID</i>. It is normally
used for identifying the message in a recorded event log file, but may occasionally
be useful for other purposes as well. If you clone a message (<tt>msg-&gt;dup()</tt>),
the clone will have a different ID.

<p>There is also another ID called <i>tree ID</i>. A tree ID starts out with
the value of the message ID; however, if you clone a message, the clone
will retain the tree ID of the original. Thus, messages that have the same
tree ID have been created by cloning the same original message or its
clones (with one exception, the original message).  The size of <tt>long</tt>
is usually enough so that IDs remain unique during a single simulation run
(i.e. the counter does not wrap).

<p>The methods for obtaining message IDs:

<pre class="cpp">
long getId() const;
long getTreeId() const;
</pre>
<p>

<p><h3><a name="sec208"/>5.2.4 Control Info</h3>

<p>One of the main application areas of OMNeT++ is the simulation of
telecommunication networks. Here, protocol layers are usually
implemented as modules which exchange packets. Packets themselves
are represented by messages subclassed from <tt><a href="../api/classcPacket.html">cPacket</a></tt>.

<p>However, communication between protocol layers requires sending
additional information to be attached to packets. For example,
a TCP implementation sending down a TCP packet to IP will want
to specify the destination IP address and possibly
other parameters. When IP passes up a packet to TCP after
decapsulation from the IP header, it will want to let TCP know
at least the source IP address.

<p>This additional information is represented by <i>control info</i> objects
in OMNeT++. Control info objects have to be subclassed from <tt><a href="../api/classcObject.html">cObject</a></tt>
(a small footprint base class with no data members), and can be attached to
any message. <tt><a href="../api/classcMessage.html">cMessage</a></tt> has the following methods for this purpose:

<pre class="cpp">
void setControlInfo(<a href="../api/classcObject.html">cObject</a> *controlInfo);
<a href="../api/classcObject.html">cObject</a> *getControlInfo() const;
<a href="../api/classcObject.html">cObject</a> *removeControlInfo();
</pre>
<p>
When a "command" is associated with the message sending (such as
TCP OPEN, SEND, CLOSE, etc), the message kind field (<tt>getKind()</tt>,
<tt>setKind()</tt> methods of <tt><a href="../api/classcMessage.html">cMessage</a></tt>) should carry the command code.
When the command doesn't involve a data packet (e.g.
TCP CLOSE command), a dummy packet (empty <tt><a href="../api/classcMessage.html">cMessage</a></tt>) can be sent.

<p>An object set as control info via <tt>setControlInfo()</tt> will be owned
by the message object. When the message is deallocated, the control
info object is deleted as well.

<p>
<h3><a name="sec209"/>5.2.5 Information About the Last Arrival</h3>

<p>The following methods return the sending and arrival times that correspond
to the last sending of the message.

<pre class="cpp">
simtime_t getSendingTime() const;
simtime_t getArrivalTime() const;
</pre>
<p>
The following methods can be used to determine where the message came from
and which gate it arrived on (or will arrive if it is currently scheduled
or under way.) There are two sets of methods, one returning module/gate Ids,
and the other returning pointers.

<pre class="cpp">
int getSenderModuleId() const;
int getSenderGateId() const;
int getArrivalModuleId() const;
int getArrivalGateId() const;
<a href="../api/classcModule.html">cModule</a> *getSenderModule() const;
<a href="../api/classcGate.html">cGate</a> *getSenderGate() const;
<a href="../api/classcModule.html">cModule</a> *getArrivalModule() const;
<a href="../api/classcGate.html">cGate</a> *getArrivalGate() const;
</pre>
<p>
There are further convenience functions to tell whether
the message arrived on a specific gate given with id or
with name and index.

<pre class="cpp">
bool arrivedOn(int gateId) const;
bool arrivedOn(const char *gatename) const;
bool arrivedOn(const char *gatename, int gateindex) const;
</pre>
<p>

<p><h3><a name="sec210"/>5.2.6 Display String</h3>

<p><i>Display strings</i> affect the message's visualization on animating user interfaces, e.g. Tkenv.
Message objects do not store a display string by default, but contain a <tt>getDisplayString()</tt>
method that can be overridden in subclasses to return a desired string.  The method:

<pre class="cpp">
const char *getDisplayString() const;
</pre>
<p>
See chapter <a href="#sec380">[11]</a> for more information on display strings.

<p>

<p><h2><a name="sec211"/>5.3 Self-Messages</h2>
<a name="sec:ch-msgs:self-messages"></a>

<p><h3><a name="sec212"/>5.3.1 Using a Message as Self-Message</h3>

<p>Messages are often used to represent events internal to a module,
such as a periodically firing timer to represent expiry of a timeout.
A message is termed <i>self-message</i> when it is used
in such a scenario -- otherwise self-messages are normal messages
of class <tt><a href="../api/classcMessage.html">cMessage</a></tt> or a class derived from it.

<p>When a message is delivered to a module by the simulation kernel,
you can call the <tt>isSelfMessage()</tt> method to determine if it is
a self-message; it other words, if it was scheduled with
<tt>scheduleAt()</tt> or was sent with one of the
<tt>send...()</tt> methods. The <tt>isScheduled()</tt> method
returns true if the message is currently scheduled. A scheduled
message can also be cancelled (<tt>cancelEvent()</tt>).

<pre class="cpp">
bool isSelfMessage() const;
bool isScheduled() const;
</pre>
<p>
The methods <tt>getSendingTime()</tt> / <tt>getArrivalTime()</tt> are also
useful with self-messages: they return the time the message was scheduled
and arrived (or will arrive; while the message is scheduled, arrival time
is the time it will be delivered to the module).

<p>
<h3><a name="sec213"/>5.3.2 Context Pointer</h3>

<p><tt><a href="../api/classcMessage.html">cMessage</a></tt> contains a <i>context pointer</i> of type <tt>void*</tt>,
which can be accessed by the following functions:

<pre class="cpp">
void setContextPointer(void *p);
void *getContextPointer() const;
</pre>
<p>
The context pointer can be used for any purpose by the simulation programmer.
It is not used by the simulation kernel, and it is treated as
a mere pointer (no memory management is done on it).

<p>Intended purpose: a module which schedules several self-messages (timers)
will need to identify a self-message when it arrives back to the module,
ie. the module will have to determine which timer went off and what to do
then. The context pointer can be made to point at a data structure kept by
the module which can carry enough &#8220;context&#8221; information about the event.

<p>

<p><h2><a name="sec214"/>5.4 The <a href="../api/classcPacket.html">cPacket</a> Class</h2>
<a name="sec:ch-msgs:cpacket"></a>

<p><h3><a name="sec215"/>5.4.1 Basic Usage</h3>

<p>The <tt><a href="../api/classcPacket.html">cPacket</a></tt> constructor is similar to the <tt><a href="../api/classcMessage.html">cMessage</a></tt>
constructor, but it accepts an additional <i>bit length</i> argument:

<pre class="cpp">
<a href="../api/classcPacket.html">cPacket</a>(const char *name=NULL, short kind=0, int64 bitLength=0);
</pre>
<p>
The most important field <tt><a href="../api/classcPacket.html">cPacket</a></tt> has over <tt><a href="../api/classcMessage.html">cMessage</a></tt> is
the message length. This field is kept in bits, but it can also be
set/get in bytes. If the bit length is not a multiple of eight, the
<tt>getByteLength()</tt> method will round it up.

<pre class="cpp">
void setBitLength(int64 l);
void setByteLength(int64 l);
void addBitLength(int64 delta);
void addByteLength(int64 delta);
int64 getBitLength() const;
int64 getByteLength() const;
</pre>
<p>
Another extra field is the bit error flag. It can be accessed with the
following methods:

<pre class="cpp">
void setBitError(bool e);
bool hasBitError() const;
</pre>
<p>

<p><h3><a name="sec216"/>5.4.2 Identifying the Protocol</h3>

<p>In OMNeT++ protocol models, the protocol type is usually represented in the
message subclass. For example, instances of class <tt>IPv6Datagram</tt>
represent IPv6 datagrams and <tt>EthernetFrame</tt> represents Ethernet
frames. The C++ <tt>dynamic_cast</tt> operator can be used to determine if a
message object is of a specific protocol.

<p>An example:

<pre class="cpp">
<a href="../api/classcMessage.html">cMessage</a> *msg = receive();
if (dynamic_cast&lt;IPv6Datagram *&gt;(msg) != NULL)
{
    IPv6Datagram *datagram = (IPv6Datagram *)msg;
    ...
}
</pre>
<p>

<p><h3><a name="sec217"/>5.4.3 Information About the Last Transmission</h3>

<p>When a packet has been received, some information can be obtained
about the transmission, namely the <i>transmission duration</i>
and the <i>is-reception-start</i> flag. They are returned by
the following methods:

<pre class="cpp">
simtime_t getDuration() const;
bool isReceptionStart() const;
</pre>
<p>

<p><h3><a name="sec218"/>5.4.4 Encapsulating Packets</h3>

<p>It is often necessary to encapsulate a packet<!--packet!encapsulation-->
into another when you are modeling layered protocols of computer networks.

<p>The following <tt><a href="../api/classcPacket.html">cPacket</a></tt> methods are associated with encapsulation:

<pre class="cpp">
void encapsulate(<a href="../api/classcPacket.html">cPacket</a> *packet);
<a href="../api/classcPacket.html">cPacket</a> *decapsulate();
<a href="../api/classcPacket.html">cPacket</a> *getEncapsulatedPacket() const;
</pre>
<p>
The <tt>encapsulate()</tt> function encapsulates a packet into another one.
The length of the packet will grow by the length of the encapsulated
packet. An exception: when the encapsulating (outer) packet has zero
length, OMNeT++ assumes it is not a real packet but some out-of-band signal,
so its length is left at zero.

<p>A packet can only hold one encapsulated packet at a time; the second
<tt>encapsulate()</tt> call will result in an error. It is also an error if
the packet to be encapsulated is not owned by the module.

<p>You can get back the encapsulated packet by calling <tt>decapsulate()</tt>.
<tt>decapsulate()</tt> will decrease the length of the packet accordingly,
except if it was zero. If the length would become negative, an error
occurs.

<p>The <tt>getEncapsulatedPacket()</tt> function returns a pointer to the
encapsulated packet, or <tt>NULL</tt> if no packet is encapsulated.

<p>Example usage:

<pre class="cpp">
<a href="../api/classcPacket.html">cPacket</a> *data = new <a href="../api/classcPacket.html">cPacket</a>("data");
data-&gt;setByteLength(1024);

UDPPacket *udp = new UDPPacket("udp"); // subclassed from <a href="../api/classcPacket.html">cPacket</a>
udp-&gt;setByteLength(8);

udp-&gt;encapsulate(data);
ev &lt;&lt; udp-&gt;getByteLength() &lt;&lt; endl; // --&gt; 8+1024 = 1032
</pre>
<p>
And the corresponding decapsulation code:

<pre class="cpp">
<a href="../api/classcPacket.html">cPacket</a> *payload = udp-&gt;decapsulate();
</pre>
<p>

<p>
<h3><a name="sec219"/>5.4.5 Reference Counting</h3>
<a name="sec:messages:reference-counting"></a>

<p>Since the 3.2 release, OMNeT++ implements reference counting of
encapsulated packets, meaning that if you <tt>dup()</tt> a packet
that contains an encapsulated packet, then the encapsulated packet will
not be duplicated, only a reference count incremented. Duplication of
the encapsulated packet is deferred until <tt>decapsulate()</tt>
actually gets called. If the outer packet is deleted without its
<tt>decapsulate()</tt> method ever being called, then the reference
count of the encapsulated packet is simply decremented. The
encapsulated packet is deleted when its reference count reaches
zero.

<p>Reference counting can significantly improve performance, especially
in LAN and wireless scenarios. For example, in the simulation of a
broadcast LAN or WLAN, the IP, TCP and higher layer packets won't
be duplicated (and then discarded without being used) if the
MAC address doesn't match in the first place.

<p>The reference counting mechanism works transparently. However, there
is one implication: <b>one must not change anything in a packet
that is encapsulated into another!</b> That is,
<tt>getEncapsulatedPacket()</tt> should be viewed as if it returned a
pointer to a read-only object (it returns a <tt>const</tt> pointer
indeed), for quite obvious reasons: the encapsulated packet may be
shared between several packets, and any change would affect those
other packets as well.

<p>
<h3><a name="sec220"/>5.4.6 Encapsulating Several Packets</h3>

<p>The <tt><a href="../api/classcPacket.html">cPacket</a></tt> class does not directly support encapsulating more
than one packet, but you can subclass <tt><a href="../api/classcPacket.html">cPacket</a></tt> or <tt><a href="../api/classcMessage.html">cMessage</a></tt>
to add the necessary functionality. (It is recommended that you
use the message definition syntax that will be described in chapter
<a href="#sec224">[6]</a> -- it can spare you some work.)

<p>You can store the messages in a fixed-size or a dynamically allocated
array, or you can use STL classes like <tt>std::vector</tt> or <tt>std::list</tt>.
There is one additional &#8220;trick&#8221; that you might not expect: your message
class has to <b>take ownership</b> of the inserted messages, and
<b>release</b> them when they are removed from the message. These are
done via the <tt>take()</tt> and <tt>drop()</tt> methods. Let us see
an example which assumes you have added to the class an <tt>std::list</tt> member
called <tt>messages</tt> that stores message pointers:

<pre class="cpp">
void MultiMessage::insertMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    take(msg);  // take ownership
    messages.push_back(msg);  // store pointer
}

void MultiMessage::removeMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    messages.remove(msg);  // remove pointer
    drop(msg);  // release ownership
}
</pre>
<p>
You will also have to provide an <tt>operator=()</tt> method to
make sure your message objects can be copied and duplicated
properly -- this is something often needed in simulations
(think of broadcasts and retransmissions!). Section
<a href="#sec304">[7.12]</a> contains more
about the things you need to take care of when deriving new classes.

<p>

<p><h2><a name="sec221"/>5.5 Attaching Parameters and Objects</h2>
<a name="sec:ch-msgs:attaching-objects"></a>

<p>If you want to add parameters or objects to a message, the preferred
way to do that is via message definitions, described in chapter
<a href="#sec224">[6]</a>.

<p>
<h3><a name="sec222"/>5.5.1 Attaching Objects</h3>

<p>The <tt><a href="../api/classcMessage.html">cMessage</a></tt> class has an internal <tt><a href="../api/classcArray.html">cArray</a></tt> object which can
carry objects<!--message!attaching objects-->. Only objects
that are derived from <tt><a href="../api/classcObject.html">cObject</a></tt> (most OMNeT++ classes are so) can be attached.
The <tt>addObject()</tt>, <tt>getObject()</tt>, <tt>hasObject()</tt>,
<tt>removeObject()</tt> methods use the object name
as the key to the array. An example:

<pre class="cpp">
<a href="../api/classcLongHistogram.html">cLongHistogram</a> *pklenDistr = new <a href="../api/classcLongHistogram.html">cLongHistogram</a>("pklenDistr");
msg-&gt;addObject(pklenDistr);
...
if (msg-&gt;hasObject("pklenDistr"))
{
   <a href="../api/classcLongHistogram.html">cLongHistogram</a> *pklenDistr =
       (<a href="../api/classcLongHistogram.html">cLongHistogram</a> *) msg-&gt;getObject("pklenDistr");
   ...
}
</pre>
<p>
You should take care that names of the attached objects don't
conflict with each other or with <tt><a href="../api/classcMsgPar.html">cMsgPar</a></tt> parameter names
(see next section).
If you do not attach anything to the message and do not call the
<tt>getParList()</tt> function, the internal <tt><a href="../api/classcArray.html">cArray</a></tt> object
will not be created. This saves both storage and execution time.

<p>You can attach non-object types (or non-<tt><a href="../api/classcObject.html">cObject</a></tt> objects) to
the message<!--message!attaching non-object types--> by using
<tt><a href="../api/classcMsgPar.html">cMsgPar</a></tt>'s <tt>void*</tt> pointer 'P') type (see later in the description
of <tt><a href="../api/classcMsgPar.html">cMsgPar</a></tt>). An example:

<pre class="cpp">
struct conn_t *conn = new conn_t; // conn_t is a C struct
msg-&gt;addPar("conn") = (void *) conn;
msg-&gt;par("conn").configPointer(NULL,NULL,sizeof(struct conn_t));
</pre>
<p>

<p><h3><a name="sec223"/>5.5.2 Attaching Parameters</h3>

<p>The preferred way of extending messages with new data fields is to use
message definitions (see chapter <a href="#sec224">[6]</a>).

<p>The old, deprecated way of adding new fields to messages is via
attaching <tt><a href="../api/classcMsgPar.html">cMsgPar</a></tt> objects.
There are several downsides of this approach, the worst being
large memory and execution time overhead. <tt><a href="../api/classcMsgPar.html">cMsgPar</a></tt>'s are
heavy-weight and fairly complex objects themselves.
It has been reported that using <tt><a href="../api/classcMsgPar.html">cMsgPar</a></tt> message parameters
might account for a large part of execution time, sometimes as much as 80%.
Using <tt><a href="../api/classcMsgPar.html">cMsgPar</a></tt> is also error-prone because <tt><a href="../api/classcMsgPar.html">cMsgPar</a></tt> objects
have to be added dynamically and individually to each message object.
In contrast, subclassing benefits from static type checking:
if you mistype the name of a field in the C++ code, the compiler
can detect the mistake.

<p>If you still need <tt><a href="../api/classcMsgPar.html">cMsgPar</a></tt>s for some reason, here is a short summary.
At the sender side you can add a new named parameter to the message
with the <tt>addPar()</tt> member function, then set its value with
one of the methods <tt>setBoolValue()</tt>, <tt>setLongValue()</tt>,
<tt>setStringValue()</tt>, <tt>setDoubleValue()</tt>, <tt>setPointerValue()</tt>,
<tt>setObjectValue()</tt>, and <tt>setXMLValue()</tt>. There are also overloaded
assignment operators for the corresponding C/C++ types.

<p>At the receiver side, you can look up the parameter object on the message
by name and obtain a reference to it with the <tt>par()</tt> member function.
<tt>hasPar()</tt> can be used to check first whether the message object has a parameter
object with the given name. Then the value can be read with the methods
<tt>boolValue()</tt>, <tt>longValue()</tt>, <tt>stringValue()</tt>,
<tt>doubleValue()</tt>, <tt>pointerValue()</tt>, <tt>objectValue()</tt>,
<tt>xmlValue()</tt>, or by using the provided overloaded type cast operators.

<p>Example usage:

<pre class="cpp">
msg-&gt;addPar("destAddr");
msg-&gt;par("destAddr").setLongValue(168);
...
long destAddr = msg-&gt;par("destAddr").longValue();
</pre>
<p>
Or, using overloaded operators:

<pre class="cpp">
msg-&gt;addPar("destAddr");
msg-&gt;par("destAddr") = 168;
...
long destAddr = msg-&gt;par("destAddr");
</pre>
<p>
<hr class='pgbr'><h1><a name="sec224"/>6 Message Definitions</h1>
<a name="cha:message-definitions"></a>

<p><h2><a name="sec225"/>6.1 Introduction</h2>
<a name="sec:ch-msg-defs:intro"></a>

<p>In practice, you will need to add various fields to <tt><a href="../api/classcMessage.html">cMessage</a></tt> or
<tt><a href="../api/classcPacket.html">cPacket</a></tt> to make them useful. For example, if you are modelling
packets in communication networks, you need to have a way to store protocol
header fields in packets. Since the simulation library is written in C++,
the natural way of extending <tt><a href="../api/classcMessage.html">cMessage</a></tt>/<tt><a href="../api/classcPacket.html">cPacket</a></tt> is via
subclassing them. However, because for each field you need to write at
least three things (a private data member, a getter and a setter method),
and the resulting class has to integrate with the simulation framework,
writing the necessary C++ code can be a tedious and time-consuming task.

<p>OMNeT++ offers a more convenient way called <i>message definitions</i>.
Message definitions offer you a compact syntax to describe message
contents, and the corresponding C++ code is automatically generated from
the definitions. A common complaint about code generators in general is
lack of flexibility: if you have a different idea how the generated code
should look, there is little you can do about it. OMNeT++, however, allows
you to extensively customize the generated class. Even if you need to
heavily customize the generated class, message definitions still save you a
great deal of manual work.

<p>
<h3><a name="sec226"/>6.1.1 The First Message Class</h3>
<a name="sec:ch-msg-defs:first-msg-class"></a>

<p>Let us begin with a simple example. Suppose that you need a packet class that
carries source and destination addresses as well as a hop count. You may then
write a <tt>MyPacket.msg</tt> file with the following contents:

<pre class="msg">
packet MyPacket
{
     int srcAddress;
     int destAddress;
     int remainingHops = 32;
};
</pre>
<p>
It is the task of the <i>message compiler</i> is to generate C++ classes
you can use from your models. The message compiler is normally invoked
automatically for your <tt>.msg</tt> files during build.

<p>When the message compiler processes <tt>MyPacket.msg</tt>, it creates the
following files: <tt>MyPacket_m.h</tt> and <tt>MyPacket_m.cc</tt>. The
generated <tt>MyPacket_m.h</tt> will contain the following class declaration:

<pre class="cpp">
class MyPacket : public <a href="../api/classcPacket.html">cPacket</a> {
    ...
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    ...
};
</pre>
<p>
In your C++ files, you can use the <tt>MyPacket</tt> class by including the
generated header file:

<pre class="cpp">
#include "MyPacket_m.h"

...
MyPacket *pkt = new MyPacket("pkt");
pkt-&gt;setSrcAddress(localAddr);
...
</pre>
<p>
The <tt>MyPacket_m.cc</tt> file will contain implementation of the generated <tt>MyPacket</tt>
class as well as &#8220;reflection&#8221; code that allows you to inspect these data
structures in the Tkenv GUI. The <tt>MyPacket_m.cc</tt> file should be compiled and
linked into your simulation; this is normally taken care of automatically.

<p>The following sections describe the message syntax and features in detail.

<p>

<p><h2><a name="sec227"/>6.2 Messages and Packets</h2>
<a name="sec:ch-msg-defs:messages-and-packets"></a>

<p><h3><a name="sec228"/>6.2.1 Defining Messages and Packets</h3>
<a name="sec:ch-msg-defs:defining-messages-and-packets"></a>

<p>Message and packet contents can be defined in a syntax resembling C structs.
The keyword can be <b><tt>message</tt></b> or <b><tt>packet</tt></b>; they cause
the generated C++ class to be derived from <tt><a href="../api/classcMessage.html">cMessage</a></tt> and
<tt><a href="../api/classcPacket.html">cPacket</a></tt>, respectively. (Further keywords, <b><tt>class</tt></b> and
<b><tt>struct</tt></b>, will be covered later.)

<p>An example packet definition:

<pre class="msg">
packet FooPacket
{
    int sourceAddress;
    int destAddress;
    bool hasPayload;
};
</pre>
<p>
Saving the above code into a <tt>FooPacket.msg</tt> file and processing it
with the message compiler, <tt>opp_msgc</tt>, will produce the files
<tt>FooPacket_m.h</tt> and <tt>FooPacket_m.cc</tt>. The header file will
contain the declaration of the generated C++ class.

<p>The generated class will have a constructor that optionally accepts object
name and message kind, and also a copy constructor. An assignment operator
(<tt>operator=()</tt>) and cloning method (<tt>dup()</tt>) will also be
generated.

<pre class="cpp">
class FooPacket : public <a href="../api/classcPacket.html">cPacket</a>
{
  public:
    FooPacket(const char *name=NULL, int kind=0);
    FooPacket(const FooPacket& other);
    FooPacket& operator=(const FooPacket& other);
    virtual FooPacket *dup() const;
    ...
</pre>
<p>
For each field in the above description, the generated class will have a
protected data member, and a public getter and setter method. The names of
the methods will begin with <tt>get</tt> and <tt>set</tt>, followed by the field
name with its first letter converted to uppercase. Thus, <tt>FooPacket</tt>
will contain the following methods:

<pre class="cpp">
    virtual int getSourceAddress() const;
    virtual void setSourceAddress(int sourceAddress);
    virtual int getDestAddress() const;
    virtual void setDestAddress(int destAddress);
    virtual bool getHasPayload() const;
    virtual void setHasPayload(bool hasPayload);
</pre>
<p>
Note that the methods are all declared <b><tt>virtual</tt></b> to give you the possibility
of overriding them in subclasses.

<p>String fields can also be declared:

<pre class="msg">
packet HttpRequestMessage
{
    string method; // "GET", "POST", etc.
    string resource;
};
</pre>
<p>
The generated getter and setter methods will return and accept <tt>const char*</tt>
pointers:

<pre class="cpp">
virtual const char *getMethod() const;
virtual void setMethod(const char *method);
virtual const char *getResource() const;
virtual void setResource(const char *resource);
</pre>
<p>
The generated object will have its own copy of the string, so it not only stores
the <tt>const char*</tt> pointer.

<p>
<h3><a name="sec229"/>6.2.2 Field Data Types</h3>
<a name="sec:ch-msg-defs:field-data-types"></a>

<p>Data types for fields are not limited to <b><tt>int</tt></b> and
<b><tt>bool</tt></b>. You can use several C/C++ and other data types:

<p><ul>
   <li> logical: <b><tt>bool</tt></b>
   <li> integral types: <b><tt>char</tt></b>, <b><tt>short</tt></b>, <b><tt>int</tt></b>,
      <b><tt>long</tt></b>; and their unsigned versions <b><tt>unsigned char</tt></b>,
      <b><tt>unsigned short</tt></b>, <b><tt>unsigned int</tt></b>, <b><tt>unsigned long</tt></b>
   <li> floating-point types: <b><tt>float</tt></b>, <b><tt>double</tt></b>
   <li> C99-style fixed-size integral types: <b><tt>int8_t</tt></b>, <b><tt>int16_t</tt></b>,
      <b><tt>int32_t</tt></b>, <b><tt>int64_t</tt></b>; and their unsigned versions
      <b><tt>uint8_t</tt></b>, <b><tt>uint16_t</tt></b>, <b><tt>uint32_t</tt></b>, <b><tt>uint64_t</tt></b>;
      <br><ul><font size=-1>[These type names are accepted without the <tt>_t</tt> suffix as well,
      but you are responsible to ensure that the generated code compiles, i.e. the
      shortened type names must be defined in a header file you include.]</font></ul>
   <li> OMNeT++ simulation time: <b><tt>simtime_t</tt></b>
   <li> <b><tt>string</tt></b>. Getters and setters use the <tt>const char*</tt> data type;
      <tt>NULL</tt> is not allowed. The object will store a copy of the string,
      not just the pointer.
   <li> structs and classes, defined in message files or elsewhere (see
      in later sections <a href="#sec234">[6.2.7]</a>
      and <a href="#sec241">[6.6]</a>)
   <li> typedef'd names declared in C++ and announced to the message compiler
)
</ul>

<p>Numeric fields are initialized to zero, booleans to <tt>false</tt>, and string
fields to empty string.

<p>
<h3><a name="sec230"/>6.2.3 Initial Values</h3>
<a name="sec:ch-msg-defs:initial-values"></a>

<p>You can specify initial values for fields. Examples:

<pre class="msg">
packet RequestPacket
{
    int version = HTTP_VERSION;
    string method = "GET";
    string resource = "/";
    int maxBytes = 100*1024*1024; // 100MiB
    bool keepAlive = true;
};
</pre>
<p>
As you can see, macros and expressions are also accepted as initalizer
values. The message compiler does not check the syntax of the values, it
only copies them into the generated C++ file; so if there is an error in
them, it will be reported by the C++ compiler.

<p>Field initialization statements will be placed into the constructor of the
generated class.

<p>
<h3><a name="sec231"/>6.2.4 Enums</h3>
<a name="sec:ch-msg-defs:enums"></a>

<p>You can declare that an <b><tt>int</tt></b> (or other integral type) field
takes values from an enum. The message compiler can then generate code
that allows Tkenv display the symbolic value of the field.

<p>Example:

<pre class="msg">
packet FooPacket
{
    int payloadType @enum(PayloadType);
};
</pre>
<p>
The enum itself has to be declared separately. An enum is declared with
the <b><tt>enum</tt></b> keyword, using the following syntax:

<pre class="msg">
enum PayloadType
{
   NONE = 0;
   UDP = 1;
   TCP = 2;
   SCTP = 3;
};
</pre>
<p>
Enum values need to be unique.

<p>The message compiler translates an enum into a normal C++ enum, plus
creates an object which stores text representations of the constants. The
latter makes it possible to display symbolic names in Tkenv.

<p>If the enum to be associated with a field comes from a different message file,
then the enum must be announced and its generated header file be included.
An example:

<pre class="msg">
cplusplus {{
#include "PayloadType_m.h"
}}

enum PayloadType;

packet FooPacket
{
    int payloadType @enum(PayloadType);
};
</pre>
<p>

<p>
<h3><a name="sec232"/>6.2.5 Fixed-Size Arrays</h3>
<a name="sec:ch-msg-defs:fixed-size-arrays"></a>

<p>You can specify fixed size arrays:

<pre class="msg">
packet SourceRoutedPacket
{
    int route[4];
};
</pre>
<p>
The generated getter and setter methods will have an extra <tt>k</tt> argument,
the array index:

<pre class="cpp">
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
</pre>
<p>
If you call the methods with an index that is out of bounds, an exception
will be thrown.

<p>
<h3><a name="sec233"/>6.2.6 Variable-Size Arrays</h3>
<a name="sec:ch-msg-defs:variable-size-arrays"></a>

<p>If the array size is not known in advance, you can declare the field
to have a variable size:

<pre class="msg">
packet SourceRoutedPacket
{
    int route[];
};
</pre>
<p>
In this case, the generated class will have two extra methods in addition
to the getter and setter methods: one for setting the array size, and another
one for returning the current array size.

<pre class="cpp">
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
virtual unsigned getRouteArraySize() const;
virtual void setRouteArraySize(unsigned n);
</pre>
<p>
The <tt>set...ArraySize()</tt> method internally allocates a new array. Existing
values in the array will be preserved (copied over to the new array.)

<p>The default array size is zero. This means that you need to call
<tt>set...ArraySize()</tt> with a nonzero argument before you can
start filling array elements.

<p>
<h3><a name="sec234"/>6.2.7 Classes and Structs as Fields</h3>
<a name="sec:ch-msg-defs:other-types-as-fields"></a>

<p>In addition to primitive types, you can also use other types (classes,
structs, typedefs, etc.) as fields. For example, if you have a C++ type
called <tt>IPAddress</tt>, you can write the following:

<pre class="msg">
packet IPPacket
{
    int version = 4;
    IPAddress src;
    IPAddress dest;
};
</pre>
<p>
The <tt>IPAddress</tt> type must be known to the message compiler, and
also at compile time to the C++ compiler; section
<a href="#sec241">[6.6]</a> will describe how to achieve that.

<p>The generated class will contain <tt>IPAddress</tt> data members
(that is, not pointers to <tt>IPAddress</tt> objects), and
the following getter and setter methods will be generated for them:

<pre class="cpp">
virtual IPAddress& getSrc();
virtual const IPAddress& getSrc() const;
virtual void setSrc(const IPAddress& src);

virtual IPAddress& getDest();
virtual const IPAddress& getDest() const;
virtual void setDest(const IPAddress& dest);
</pre>
<p>

<p><h3><a name="sec235"/>6.2.8 Pointer Fields</h3>
<a name="sec:ch-msg-defs:pointers-fields"></a>

<p>Pointer fields where the setters and the destructor would delete the
previous value are not supported yet. However, there are workarounds, as
described below.

<p>You can create a typedef for the pointer and use the typedef name as field
type. Then you'll get a plain pointer field where neither the setter nor
the destructor deletes the old value (which is a likely memory leak).

<p>Example (section <a href="#sec241">[6.6]</a> will explain the
details):

<pre class="msg">
cplusplus {{ typedef Foo *FooPtr; }} // C++ typedef
class noncobject FooPtr; // announcement for the message compiler

packet Bar
{
    FooPtr fooPtr;  // leaky pointer field
};
</pre>
<p>
Then you can customize the class via C++ inheritance and reimplement
the setter methods in C++, inserting the missing <tt>delete</tt> statements.
Customization via C++ inheritance will be described in section
<a href="#sec247">[6.7.2]</a>.

<p>
<h3><a name="sec236"/>6.2.9 Inheritance</h3>
<a name="sec:ch-msg-defs:inheritance"></a>

<p>By default, messages are subclassed from <tt><a href="../api/classcMessage.html">cMessage</a></tt> or
<tt><a href="../api/classcPacket.html">cPacket</a></tt>. However, you can explicitly specify the base class using
the <b><tt>extends</tt></b> keyword (only single inheritance is supported):

<pre class="msg">
packet Ieee80211DataFrame extends Ieee80211Frame
{
    ...
};
</pre>
<p>
For the example above, the generated C++ code will look like this:

<pre class="cpp">
// generated C++
class Ieee80211DataFrame : public Ieee80211Frame {
    ...
};
</pre>
<p>

<p><h3><a name="sec237"/>6.2.10 Assignment of Inherited Fields</h3>
<a name="sec:ch-msg-defs:assignment-of-inherited-fields"></a>

<p>Message definitions allow you to change the initial value of a field
defined in an ancestor type. The syntax is similar to that of a field
definition with initial value, only the data type is missing.

<p>An example:

<pre class="msg">
packet Ieee80211Frame
{
    int frameType;
    ...
};

packet Ieee80211DataFrame extends Ieee80211Frame
{
    frameType = DATA_FRAME;  // assignment of inherited field
    ...
};
</pre>
<p>
It may seem like the message compiler would need the definition of the base
class to check the definition of the field being assigned. However, it is
not the case. The message compiler trusts that such field exists; or
rather, it leaves the check to the C++ compiler.

<p>What the message compiler actually does is derives a setter method name
from the field name, and generates a call to it into the constructor.
Thus, the generated constructor for the above packet type would be
something like this:

<pre class="cpp">
Ieee80211DataFrame::Ieee80211DataFrame(const char *name, int kind) :
    Ieee80211Frame(name, kind)
{
    this-&gt;setFrameType(DATA_FRAME);
    ...
}
</pre>
<p>
This implementation also lets you initialize <tt><a href="../api/classcMessage.html">cMessage</a></tt> /
<tt><a href="../api/classcPacket.html">cPacket</a></tt> fields such as message kind or packet length:

<pre class="msg">
packet UDPPacket
{
    byteLength = 16;  // results in 'setByteLength(16);' being placed into ctor
};
</pre>
<p>

<p>
<h2><a name="sec238"/>6.3 Classes</h2>
<a name="sec:ch-msg-defs:defining-classes"></a>

<p>Until now we have only seen message and packet descriptions, which generate
classes derived from <tt><a href="../api/classcMessage.html">cMessage</a></tt> or <tt><a href="../api/classcPacket.html">cPacket</a></tt>. However, it is
also useful to be able to generate classes and structs, for building blocks
for messages, as control info objects (see <tt><a href="../api/classcMessage.html">cMessage</a></tt>'s
<tt>setControlInfo()</tt> and for other purposes. This section covers
classes; structs will be described in the next section.

<p>The syntax for defining classes is almost the same as defining messages,
only the <b><tt>class</tt></b> keyword is used instead of <b><tt>message</tt></b> /
<b><tt>packet</tt></b>. The base class can be specified with the <b><tt>extends</tt></b>
keyword, and defaults to <tt><a href="../api/classcObject.html">cObject</a></tt>.

<p><ul class="note"><b>NOTE</b><br>
<tt><a href="../api/classcObject.html">cObject</a></tt> has no data members. It only defines virtual methods, so
the only overhead would be the <i>vptr</i>; however, the generated class already has
a vptr because the generated methods are also virtual. In other words,
<tt><a href="../api/classcObject.html">cObject</a></tt> adds zero overhead to the generated class, and there is no
reason not to always use it as base class.
</ul>

<p>Examples:

<pre class="msg">
class TCPCommand  // same as "extends <a href="../api/classcObject.html">cObject</a>"
{
    ...
};

class TCPOpenCommand extends TCPCommand
{
    ...
};
</pre>
<p>
The generated code:

<pre class="cpp">
// generated C++
class TCPCommand : public <a href="../api/classcObject.html">cObject</a>
{
    ...
};

class TCPOpenCommand : public TCPCommand
{
    ...
};
</pre>
<p>

<p><h2><a name="sec239"/>6.4 Structs</h2>
<a name="sec:ch-msg-defs:defining-structs"></a>

<p>You can define C-style structs to be used as fields in message classes,
&#8220;C-style&#8221; meaning &#8220;containing only data and no methods&#8221; (in contrast to
C++ where a struct is just a class with a different default member
visibility.)

<p>The syntax is similar to that of defining messages:

<pre class="msg">
struct Place
{
    int type;
    string description;
    double coords[3];
};
</pre>
<p>
However, the generated code is different. The generated struct has
no getter or setter methods, instead the fields are represented
by public data members. The following code is generated from
the above definition:

<pre class="cpp">
// generated C++
struct Place
{
    int type;
    <a href="../api/classopp__string.html">opp_string</a> description; // minimal string class that wraps a const char*
    double coords[3];
};
</pre>
<p>
Note that <b><tt>string</tt></b> fields are generated with the <tt><a href="../api/classopp__string.html">opp_string</a></tt>
C++ type, which is a minimalistic string class that wraps <tt>const char*</tt>
and takes care of allocation/deallocation. It was chosen instead of
<tt>std::string</tt> because of its significantly smaller memory footprint
(the sizeof of <tt><a href="../api/classopp__string.html">opp_string</a></tt> is the same as that of a <tt>const char*</tt>
pointer).

<p>Inheritance is supported for structs:

<pre class="msg">
struct Base
{
    ...
};

struct Extended extends Base
{
    ...
};
</pre>
<p>
However, because a struct has no member functions, there are limitations:

<p><ul>
   <li> variable-size arrays are not supported;
   <li> customization via inheritance and <b><tt>abstract</tt></b> fields
      (see later in <a href="#sec247">[6.7.2]</a>)
      cannot be used;
   <li> cannot have classes subclassed from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> as fields,
      because structs cannot be owners.
</ul>

<p>

<p><h2><a name="sec240"/>6.5 Literal C++ Blocks</h2>
<a name="sec:ch-msg-defs:cplusplus-blocks"></a>

<p>It is possible to have C++ code placed directly into the generated code,
more precisely, into the generated header file. This is done with the
<b><tt>cplusplus</tt></b> keyword and a double curly braces. As we'll see in
later sections, <b><tt>cplusplus</tt></b> blocks are customarily used to insert
<tt>#include</tt> directives, typedefs, <tt>#define</tt> macros and other
elements into the generated header.

<p>Example:

<pre class="msg">
cplusplus {{
#include &lt;vector&gt;
#include "foo.h"
#define FOO_VERSION 4
typedef std::vector&lt;int&gt; IntVector;
}}
</pre>
<p>
The message compiler does not try to make sense of the text in the body of
the <tt>cplusplus</tt> block, it just simply copies it into the generated
header file.

<p>
<h2><a name="sec241"/>6.6 Using C++ Types</h2>
<a name="sec:ch-msg-defs:using-cpp-types"></a>

<p>The message compile only knows about the types defined within the same msg
file, and the built-in types. To be able to use other types, for example
for fields or as base class, you need to do two things:

<p><ol>
   <li> Let the message compiler know about the type by announcing it; and
   <li> Make sure its C++ declaration will be available at compile time
</ol>

<p>The next two sections describe how to do each.

<p>
<h3><a name="sec242"/>6.6.1 Announcing Types to the Message Compiler</h3>
<a name="sec:ch-msg-defs:announcing-types"></a>

<p>If you want to use a C++ type (a class, struct or typedef) not
declared with the message syntax in the same file, you have to
announce those types to the message compiler.

<p>Type annoucements have a similar syntax to those in C++:

<pre class="msg">
struct Point;
class PrioQueue;  // implies it is derived from <a href="../api/classcOwnedObject.html">cOwnedObject</a>! see below
message TimeoutMessage;
packet TCPSegment;
</pre>
<p>
However, with the <b><tt>class</tt></b> keyword, the message compiler needs to
know the whether the class is derived (directly or indirectly) from
<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>, <tt><a href="../api/classcNamedObject.html">cNamedObject</a></tt>, <tt><a href="../api/classcObject.html">cObject</a></tt> or none of
the above, because it affects code generation. The ancestor class can be
declared with the <b><tt>extends</tt></b> keyword, like this:

<pre class="msg">
class IPAddress extends void;  // does not extend any "interesting" class
class ModulePtr extends void;  // ditto
class IntVector extends void;  // ditto
class IPCtlInfo extends <a href="../api/classcObject.html">cObject</a>;
class FooOption extends <a href="../api/classcNamedObject.html">cNamedObject</a>;
class PrioQueue extends <a href="../api/classcOwnedObject.html">cOwnedObject</a>;
class IPAddrExt extends IPAddress;  // also OK: IPAddress has been announced
</pre>
<p>
An alternative to <tt>extends void</tt> is the <b><tt>noncobject</tt></b> modifier:

<pre class="msg">
class noncobject IPAddress; // same as "extends void"
</pre>
<p>
By default, that is, when <b><tt>extends</tt></b> is missing, it is assumed
that the class is derived from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>. Thus, the following
two announcements are equivalent:

<pre class="msg">
class PrioQueue;
class PrioQueue extends <a href="../api/classcOwnedObject.html">cOwnedObject</a>;
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
Notice that this default is inconsistent with the default base class for
generating classes, which is <tt><a href="../api/classcObject.html">cObject</a></tt> (see
<a href="#sec238">[6.3]</a>). The reason why type announcements
assume <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> is that it is safer: a mistake will surface in
the form of a compile error and will not remain hidden until it causes some
obscure runtime error.
</ul>

<p>
<h3><a name="sec243"/>6.6.2 Making the C++ Declarations Available</h3>

<p>In addition to announcing types to the message compiler, you also have to make
sure their C++ declarations will be available at compile time so that the
generated code will actually compile. This can be achieved with
<b><tt>cplusplus</tt></b> blocks that let you inject includes, typedefs,
class/struct declarations, etc. into the generated header file:

<pre class="msg">
cplusplus {{
#include "IPAddress.h"
typedef std::vector&lt;int&gt; IntVector;
}}
</pre>
<p>
You need a <b><tt>cplusplus</tt></b> block even if the desired types are defined
in a (different) message file, to include the generated header file.
It is currently not supported to import types from other message files directly.
Example:

<pre class="msg">
cplusplus {{
#include "TCPSegment_m.h"  // make types defined in TCPSegment.msg available
                           // for the C++ compiler
}}
</pre>
<p>

<p><h3><a name="sec244"/>6.6.3 Putting it Together</h3>

<p>Suppose you have header files and message files that define various types:

<pre class="cpp">
// IPAddress.h
class IPAddress {
   ...
};
</pre>
<p>
<pre class="cpp">
// Location.h
struct Location {
    double lon;
    double lat;
};
</pre>

<pre class="msg">
// AppPacket.msg
packet AppPacket {
   ...
}
</pre>
<p>
To be able to use the above types in a message definition (and two more,
an <tt>IntVector</tt> and a module pointer), the message file should contain
the following lines:

<pre class="msg">
cplusplus {{
#include &lt;vector&gt;
#include "IPAddress.h"
#include "Location.h"
#include "AppPacket_m.h"
typedef std::vector&lt;int&gt; IntVector;
typedef <a href="../api/classcModule.html">cModule</a> *ModulePtr;
}};

class noncobject IPAddress;
struct Location;
packet AppPacket;
class noncobject IntVector;
class noncobject ModulePtr;

packet AppPacketExt extends AppPacket {
    IPAddress destAddress;
    Location senderLocation;
    IntVector data;
    ModulePtr originatingModule;
}
</pre>
<p>

<p><h2><a name="sec245"/>6.7 Customizing the Generated Class</h2>
<a name="sec:ch-msg-defs:customizing-generated-class"></a>

<p>
<h3><a name="sec246"/>6.7.1 Customizing Method Names</h3>
<a name="sec:ch-msg-defs:customizing-method-names"></a>

<p>The names and some other properties of generated methods can be influenced
with metadata annotations (properties).

<p>The names of the getter and setter methods can be changed with the
<b><tt>@getter</tt></b> and <b><tt>@setter</tt></b> properties. For variable-size array
fields, the names of array size getter and setter methods can be changed
with <b><tt>@sizeGetter</tt></b> and <b><tt>@sizeSetter</tt></b>.

<p>In addition, the data type for the array size (by default <tt>unsigned
int</tt>) can be changed with <b><tt>@sizetype</tt></b> property.

<p>Consider the following example:

<pre class="msg">
packet IPPacket {
    int ttl @getter(getTTL) @setter(setTTL);
    Option options[] @sizeGetter(getNumOptions)
                     @sizeSetter(setNumOptions)
                     @sizetype(short);
}
</pre>
<p>
The generated class would have the following methods (note the differences
from the default names <tt>getTtl()</tt>, <tt>setTtl()</tt>, <tt>getOptions()</tt>,
<tt>setOptions()</tt>, <tt>getOptionsArraySize()</tt>, <tt>getOptionsArraySize()</tt>;
also note that indices and array sizes are now <tt>short</tt>):

<pre class="cpp">
virtual int getTTL() const;
virtual void setTTL(int ttl);
virtual const Option& getOption(short k) const;
virtual void setOption(short k, const Option& option);
virtual short getNumOptions() const;
virtual void setNumOptions(short n);
</pre>
<p>
In some older simulation models you may also see the use of the
<b><tt>@omitGetVerb</tt></b> class property. This property tells the message
compiler to generate getter methods without the &#8220;get&#8221; prefix, e.g. for a
<tt>sourceAddress</tt> field it would generate a <tt>sourceAddress()</tt> method
instead of the default <tt>getSourceAddress()</tt>. It is not recommended to
use <tt>@omitGetVerb</tt> in new models, because it is inconsistent with the
accepted naming convention.

<p>

<p><h3><a name="sec247"/>6.7.2 Customizing the Class via Inheritance</h3>
<a name="sec:ch-msg-defs:customizing-via-inheritance"></a>

<p>Sometimes you need the generated code to do something
more or do something differently than the version generated
by the message compiler.
For example, when setting an integer field named <tt>payloadLength</tt>,
you might also need to adjust the packet length. That is,
the following default (generated) version of the
<tt>setPayloadLength()</tt> method is not suitable:

<pre class="cpp">
void FooPacket::setPayloadLength(int payloadLength)
{
    this-&gt;payloadLength = payloadLength;
}
</pre>
<p>
Instead, it should look something like this:

<pre class="cpp">
void FooPacket::setPayloadLength(int payloadLength)
{
    addByteLength(payloadLength - this-&gt;payloadLength);
    this-&gt;payloadLength = payloadLength;
}
</pre>
<p>
According to common belief, the largest drawback of generated code
is that it is difficult or impossible to fulfill such wishes.
Hand-editing of the generated files is worthless, because
they will be overwritten and changes will be lost
in the code generation cycle.

<p>However, object oriented programming offers a solution.
A generated class can simply be customized by subclassing
from it and redefining whichever methods need to be
different from their generated versions. This practice
is known as the <i>Generation Gap</i> design pattern.
It is enabled with the <b><tt>@customize</tt></b> property set on the
message:

<pre class="msg">
packet FooPacket
{
   @customize(true);
   int payloadLength;
};
</pre>
<p>
If you process the above code with the message compiler,
the generated code will contain a <tt>FooPacket_Base</tt> class
instead of <tt>FooPacket</tt>. Then you would subclass
<tt>FooPacket_Base</tt> to produce <tt>FooPacket</tt>,
while doing your customizations by redefining the necessary methods.

<pre class="cpp">
class FooPacket_Base : public <a href="../api/classcPacket.html">cPacket</a>
{
  protected:
    int src;
    // make constructors protected to avoid instantiation
    FooPacket_Base(const char *name=NULL);
    FooPacket_Base(const FooPacket_Base& other);
  public:
    ...
    virtual int getSrc() const;
    virtual void setSrc(int src);
};
</pre>
<p>
There is a minimum amount of code you have to write
for <tt>FooPacket</tt>, because not everything can be
pre-generated as part of <tt>FooPacket_Base</tt>, e.g.
constructors cannot be inherited. This minimum
code is the following (you will find it the generated C++ header
too, as a comment):

<pre class="cpp">
class FooPacket : public FooPacket_Base
{
  public:
    FooPacket(const char *name=NULL) : FooPacket_Base(name) {}
    FooPacket(const FooPacket& other) : FooPacket_Base(other) {}
    FooPacket& operator=(const FooPacket& other)
        {FooPacket_Base::operator=(other); return *this;}
    virtual FooPacket *dup() const {return new FooPacket(*this);}
};

Register_Class(FooPacket);
</pre>
<p>
Note that it is important that you redefine <tt>dup()</tt> and
provide an assignment operator (<tt>operator=()</tt>).

<p>So, returning to our original example about payload length
affecting packet length, the code you'd write is the following:

<pre class="cpp">
class FooPacket : public FooPacket_Base
{
    // here come the mandatory methods: constructor,
    // copy constructor, operator=(), dup()
    // ...

    virtual void setPayloadLength(int newlength);
}

void FooPacket::setPayloadLength(int newlength)
{
    // adjust message length
    addByteLength(newlength - getPayloadLength());

    // set the new length
    FooPacket_Base::setPayloadLength(newlength);
}
</pre>
<p>

<p>
<h3><a name="sec248"/>6.7.3 Abstract Fields</h3>
<a name="sec:ch-msg-defs:abstract-fields"></a>

<p>The purpose of abstract fields is to let you to override
the way the value is stored inside the class,
and still benefit from inspectability in Tkenv.

<p>For example, this is the situation when you want to store a bitfield
in a single <b><tt>int</tt></b> or <b><tt>short</tt></b>, and yet you want
to present bits as individual packet fields.
It is also useful for implementing computed fields.

<p>You can declare any field to be abstract with the following syntax:

<pre class="msg">
packet FooPacket
{
   @customize(true);
   abstract bool urgentBit;
};
</pre>
<p>
For an <b><tt>abstract</tt></b> field, the message compiler generates
no data member, and generated getter/setter methods will be pure
virtual:

<pre class="cpp">
virtual bool getUrgentBit() const = 0;
virtual void setUrgentBit(bool urgentBit) = 0;
</pre>
<p>

<p>Usually you'll want to use abstract fields together with
the Generation Gap pattern, so that you can immediately
redefine the abstract (pure virtual) methods and
supply your implementation.

<p>

<p><h2><a name="sec249"/>6.8 Using Standard Container Classes for Fields</h2>
<a name="sec:ch-msg-defs:using-stl"></a>

<p>One often wants to use standard container classes (STL) as fields, such as
<tt>std::vector</tt>, <tt>std::stack</tt> or <tt>std::map</tt>. The following sections
describe two ways this can be done:

<p><ol>
  <li> via a typedef;
  <li> by defining the field as abstract, and customizing the generated class.
</ol>

<p><h3><a name="sec250"/>6.8.1 Typedefs</h3>

<p>The basic idea is that if we create a typedef for the desired type,
we can use it for fields just as any other type. Example:

<pre class="msg">
cplusplus {{
#include &lt;vector&gt;
typedef std::vector&lt;int&gt; IntVector;
}}

class noncobject IntVector;

packet FooPacket {
    IntVector addresses;
};
</pre>
<p>
The generated class will have the following methods:

<pre class="cpp">
virtual IntVector& getAddresses();
virtual const IntVector& getAddresses() const;
virtual void setAddresses(const IntVector& addresses);
</pre>
<p>
Thus, the underlying <tt>std::vector&lt;int&gt;</tt> is exposed and you can directly
manipulate it from C++ code, for example like this:

<pre class="cpp">
FooPacket *pk = new FooPacket();
pk-&gt;getAddresses().push_back(1);
pk-&gt;getAddresses().push_back(5);
pk-&gt;getAddresses().push_back(9);
// or:
IntVector& v = pk-&gt;getAddresses();
v.push_back(1);
v.push_back(5);
v.push_back(9);
</pre>
<p>
It is easy. However, there are also some drawbacks:

<p><ol>
  <li> The message compiler won't know that your field is actually
      a data structure, so the generated reflection code won't be able
      to look into it;
  <li> The fact that STL classes are directly exposed may be a mixed
      blessing; on one hand this makes it easier to manipulate its
      contents, but on the other hand it violates the encapsulation
      principle. Container classes work best when they are used as
      &#8220;nuts and bolts&#8221; for your C++ program, but they shouldn't really
      be used as public API.
</ol>

<p><h3><a name="sec251"/>6.8.2 Abstract Fields</h3>

<p>This approach uses abstract fields. We exploit the fact that
<tt>std::vector</tt> and <tt>std::stack</tt> are representations of
<i>sequence</i>, which is the same abstraction as fields' variable-size
array. That is, if you declare the field to be <tt>abstract fieldname[]</tt>,
the message compiler will only generate pure virtual functions and you can
implement the underlying data storage using standard container classes. You
can also write additional C++ methods that delegate to the container
object's <tt>push_back()</tt>, <tt>push()</tt>, <tt>pop()</tt>, etc. methods.

<p>Consider the following message declaration:

<pre class="msg">
packet FooPacket
{
    @customize(true);
    abstract int foo[]; // will use std::vector&lt;int&gt;
    abstract int bar[]; // will use std::stack&lt;int&gt;
}
</pre>
<p>
If you compile the above code, in the generated C++ code you will only find
abstract methods for <tt>foo</tt> and <tt>bar</tt>, but no underlying data
members or method implementations. You can implement everything as you
like. You can write the following C++ file then to implement <tt>foo</tt> and
<tt>bar</tt> with <tt>std::vector</tt> and <tt>std::stack</tt> (some details omitted
for brevity):

<pre class="cpp">
#include &lt;vector&gt;
#include &lt;stack&gt;
#include "FooPacket_m.h"

class FooPacket : public FooPacket_Base
{
  protected:
    std::vector&lt;int&gt; foo;
    std::stack&lt;int&gt; bar;

    // helper method
    void unsupported() {throw <a href="../api/classcRuntimeError.html">cRuntimeError</a>("unsupported method called");}

  public:
    ...
    // foo methods
    virtual int getFoo(unsigned int k) {return foo[k];}
    virtual void setFoo(unsigned int k, int x) {foo[k]=x;}
    virtual void addFoo(int x) {foo.push_back(x);}
    virtual void setFooArraySize(unsigned int size) {foo.resize(size);}
    virtual unsigned int getFooArraySize() const {return foo.size();}

    // bar methods
    virtual int getBar(unsigned int k) {...}
    virtual void setBar(unsigned int k, int x) {unsupported();}
    virtual void barPush(int x) {bar.push(x);}
    virtual void barPop() {bar.pop();}
    virtual int barTop() {return bar.top();}
    virtual void setBarArraySize(unsigned int size) {unsupported();}
    virtual unsigned int getBarArraySize() const {return bar.size();}
};

Register_Class(FooPacket);
</pre>
<p>
Some additional boilerplate code is needed so that the class conforms
to conventions, and duplication and copying works properly:

<pre class="cpp">
    FooPacket(const char *name=NULL, int kind=0) : FooPacket_Base(name,kind) {
    }
    FooPacket(const FooPacket& other) : FooPacket_Base(other.getName()) {
        operator=(other);
    }
    FooPacket& operator=(const FooPacket& other) {
        if (&other==this) return *this;
        FooPacket_Base::operator=(other);
        foo = other.foo;
        bar = other.bar;
        return *this;
    }
    virtual FooPacket *dup() {
        return new FooPacket(*this);
    }
</pre>
<p>
Some additional notes:

<p><ol>
  <li><tt>setFooArraySize()</tt>, <tt>setBarArraySize()</tt> are redundant.
  <li><tt>getBar(int k)</tt> cannot be implemented in a straightforward way
     (<tt>std::stack</tt> does not support accessing elements by index).
     It could still be implemented in a less efficient way using STL iterators,
     and efficiency does not seem to be major problem because only Tkenv
     is going to invoke this function.
  <li><tt>setBar(int k, int x)</tt> could not be implemented, but this
     is not particularly a problem. The exception will materialize in a
     Tkenv error dialog when you try to change the field value.
</ol>

<p>

<p><h2><a name="sec252"/>6.9 Namespaces</h2>
<a name="sec:ch-msg-defs:namespaces"></a>

<p>It is possible to place the generated classes into a C++ namespace,
and also to use types from other namespaces.

<p><h3><a name="sec253"/>6.9.1 Declaring a Namespace</h3>
<a name="sec:ch-msg-defs:declaring-a-namespace"></a>

<p>To place the generated types into a namespace, add a namespace declaration
near the top of the message file:

<pre class="msg">
namespace inet;
</pre>
<p>
If you are fond of hierarchical (nested) namespaces, you can declare one
with a straightforward syntax, using double colons in the namespace
declaration. There is no need for multiple nested <tt>namespace</tt>
declarations as in C++:

<pre class="msg">
namespace org::omnetpp::inet::ieee80211;
</pre>
<p>
The above code will be translated into nested namespaces in the C++ code:

<pre class="cpp">
namespace org { namespace omnetpp { namespace inet { namespace ieee80211 {
...
}}}}
</pre>
<p>
Conceptually, the namespace extends from the place of the namespace
declaration to the end of the message file. (A message file may contain
only one namespace declaration.) In other words, it <i>does</i> matter
whether you put something above the namespace declaration line or below it:

<p><ol>
<li> The contents of <b><tt>cplusplus</tt></b> blocks above the namespace
      declaration will be placed outside (i.e. above) the namespace block
      in the generated C++ header; blocks below the namespace declaration
      will placed inside the C++ namespace block.
<li> Type announcements are interpreted differently depending on whether
      they occur above or below the namespace declaration (this will be
      detailed later).
<li> Types defined with the message syntax are placed into the namespace
      of the message file; thus, definitions must always be <i>after</i>
      the namespace declaration. Type definitions above the namespace line
      will be rejected with an error message.
</ol>

<p><h3><a name="sec254"/>6.9.2 C++ Blocks and Namespace</h3>

<p>As described above, the contents of a <b><tt>cplusplus</tt></b> block will be
copied above or into the C++ namespace block in the generated header
depending on whether it occurs above or below the namespace declaration in
the message file.

<p>The placement of <b><tt>cplusplus</tt></b> blocks relative to the namespace
declaration is important because you don't want <tt>#include</tt> directives
to be placed inside the C++ namespace block. That would cause the
declarations in the header file to be interpreted as being part of the
namespace, which they are not. Includes should always be put into
<tt>cplusplus</tt> blocks <i>above</i> the namespace declaration. This is so
important that I repeat it:

<p><ul class="important"><b>IMPORTANT</b><br>
Includes should always be placed into a <b><tt>cplusplus</tt></b> block <b>above</b>
the namespace declaration.
</ul>

<p>As for typedefs and other C++ code, you need to place them above or below
the namespace declaration based on whether you want them to be in the C++
namespace or not.

<p><h3><a name="sec255"/>6.9.3 Type Announcements and Namespace</h3>

<p>The type announcement syntax allows one to specify the namespace of the type
as well, so the following lines are syntactically correct:

<pre class="msg">
packet foo::FooPacket;
packet nes::ted::name::space::BarPacket;
packet ::BazPacket;
</pre>
<p>
Announced type names are interpreted in the following way:

<p><ol>
<li> If the type name contains a double colon (<tt>::</tt>), it is interpreted
      as being fully qualified with an absolute namespace.
<li> If the name is just an identifier (no double colon), the interpretation
      depends on whether it is above or below the namespace declaration.
      If it is above, the name is interpreted as a global type; otherwise
      it is interpreted as part of the package file's namespace.
</ol>

<p>This also means that if you want to announce a global type, you either
have to put the announcement above the namespace declaration, or prefix
the type with &#8220;<tt>::</tt>&#8221; to declare that it is not part of a namespace.

<p>When the announced types are used later (as field type, base class, etc.),
they can be referred to just with their simple names (without namespace);
or alternatively with their fully qualified names. When a message compiler
encounters type name as field type or base class, it interprets the type
name in the following way:

<p><ol>
<li> If the type name contains a double colon (<tt>::</tt>), it is interpreted
      as being fully qualified with an absolute namespace.
<li> If the name is just an identifier (no double colon), and the message
      file's namespace contains that name, it is chosen; otherwise:
<li> It is looked up among all announced types in all namespaces (including
      the global namespace), and there must be exactly one match. That is,
      if the same name exists in multiple namespaces, it may only be
      referenced with fully qualified name.
</ol>

<p>The following code illustrates the above rules:

<pre class="msg">
cplusplus {{
// includes go above the namespace line
#include &lt;vector&gt;
#include "IPAddress.h"
}}

// the IPAddress type is in the global namespace
class noncobject IPAddress;

namespace foo;  // namespace begins with this line

// we could also have announced IPAddress here as "::IPAddress":
//class noncobject ::IPAddress;

cplusplus {{
// we want IPAddressVector to be part of the namespace
typedef std::vector&lt;IPAddress&gt; IPAddressVector;
}}

// type will be understood as foo::IPAddressVector
class noncobject IPAddressVector;

packet FooPacket {
    IPAddress source;
    IPAddressVector neighbors;
};
</pre>
<p>
Another example that uses a <tt>PacketData</tt> class and a <tt>NetworkPacket</tt> type
from a <tt>net</tt> namespace:

<pre class="msg">
// NetworkPacket.msg
namespace net;
class PacketData { }
packet NetworkPacket { }
</pre>
<p>
<pre class="msg">
// FooPacket.msg
cplusplus {{
#include "NetworkPacket_m.h"
}}
class net::PacketData;
packet net::NetworkPacket;

namespace foo;

packet FooPacket extends NetworkPacket
{
    PacketData data;
}
</pre>

<p>

<p><h2><a name="sec256"/>6.10 Descriptor Classes</h2>
<a name="sec:ch-msg-defs:descriptor-classes"></a>

<p>For each generated class and struct, the message compiler generates an
associated descriptor class. The descriptor class carries &#8220;reflection&#8221;
information about the new class, and makes it possible to inspect message
contents in Tkenv.

<p>The descriptor class encapsulates virtually all information that the
original message definition contains, and exposes it via member functions.
It has methods for enumerating fields (<tt>getFieldCount()</tt>,
<tt>getFieldName()</tt>, <tt>getFieldTypeString()</tt>, etc.), for getting
and setting a field's value in an instance of the class
(<tt>getFieldAsString()</tt>, <tt>setFieldAsString()</tt>), for exploring the
class hierarchy (<tt>getBaseClassDescriptor()</tt>, etc.), for accessing
class and field properties, and for similar tasks. When you inspect a
message or packet in the simulation, Tkenv can uses the associated
descriptor class to extract and display the field values.

<p>The <b><tt>@descriptor</tt></b> class property can be used to control the generation
of the descriptor class. <tt>@descriptor(readonly)</tt> instructs the message
compiler not to generate field setters for the descriptor, and
<tt>@descriptor(false)</tt> instructs it not to generate a description class
for the class at all.

<p>It is also possible to use (or abuse) the message compiler for generating a
descriptor class for an existing class. (This can be useful for making your
class inspectable in Tkenv.) To do that, write a message definition for
your existing class (for example, if it has <tt>int getFoo()</tt> and
<tt>setFoo(int)</tt> methods, add an <tt>int foo</tt> field to the message
definition), and mark it with <tt>@existingClass(true)</tt>. This will tell the
message compiler that it should not generate an actual class (as it already
exists), only a descriptor class.

<p>

<p><h2><a name="sec257"/>6.11 Summary</h2>
<a name="sec:ch-msg-defs:summary"></a>

<p>This section summarizes the possibilities offered by message definitions.

<p>Base functionality:

<p><ul>
  <li>  generation of classes and plain C structs from concise descriptions
  <li>  default base classes:
    <tt><a href="../api/classcPacket.html">cPacket</a></tt> (with the <b><tt>packet</tt></b> keyword),
    <tt><a href="../api/classcMessage.html">cMessage</a></tt> (with the <b><tt>message</tt></b> keyword), or
    <tt><a href="../api/classcObject.html">cObject</a></tt> (with the <b><tt>class</tt></b> keyword)
</ul>

<p>The following data types are supported for fields:

<p><ul>
  <li>  primitive types:
    <tt>bool</tt>, <tt>char</tt>, <tt>short</tt>, <tt>int</tt>, <tt>long</tt>;
    <tt>unsigned char</tt>, <tt>unsigned short</tt>, <tt>unsigned int</tt>, <tt>unsigned long</tt>;
    <tt>int8_t</tt>, <tt>int16_t</tt>, <tt>int32_t</tt>, <tt>int64_t</tt>;
    <tt>uint8_t</tt>, <tt>uint16_t</tt>, <tt>uint32_t</tt>, <tt>uint64_t</tt>;
    <tt>float</tt>, <tt>double</tt>; <tt>simtime_t</tt>
  <li>  <tt>string</tt>, a dynamically allocated string, presented as <tt>const char *</tt>
  <li>  structs and classes, declared with the message syntax or in C++ code
  <li>  typedef'd names declared in C++ and announced to the message compiler
  <li>  fixed-size arrays of the above types
  <li>  variable-size arrays of the above types (stored as a dynamically
    allocated array plus an integer for the array size)
</ul>

<p>Further features:

<p><ul>
  <li>  fields initialize to zero (except for struct/class fields)
  <li>  field initializers can be specified (except for struct/class fields)
  <li>  associating fields of integral types with enums
  <li>  inheritance
  <li>  namespaces
  <li>  customization of generated method names
  <li>  customization of the generated class via subclassing (<i>Generation Gap</i> pattern)
  <li>  abstract fields (for nonstandard storage and calculated fields)
  <li>  generation of descriptor objects that encapsulate reflection information
</ul>

<p>Generated code (all generated methods are <tt>virtual</tt>, although
this is not written out in the following table):

<p><table border>
<TR> <TD align=left>

<p>
<b>Field declaration</b>
    </TD> <TD align=left>
<b>Generated code</b>
</TD></TR>
<TR> <TD align=left> 
primitive types
<pre class="verbatim">
double field;
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
double getField();
void setField(double d);
</pre>
</TD></TR>
<TR> <TD align=left> 
string type
<pre class="verbatim">
string field;
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
const char *getField();
void setField(const char *);
</pre>
</TD></TR>
<TR> <TD align=left> 
fixed-size arrays
<pre class="verbatim">
double field[4];
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
double getField(unsigned k);
void setField(unsigned k, double d);
unsigned getFieldArraySize();
</pre>

<p></TD></TR>
<TR> <TD align=left> 
variable-size arrays
<pre class="verbatim">
double field[];
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
void setFieldArraySize(unsigned n);
unsigned getFieldArraySize();
double getField(unsigned k);
void setField(unsigned k, double d);
</pre>
</TD></TR>
<TR> <TD align=left> 
customized class
<pre class="verbatim">
class Foo {
  @customize(true);
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
class Foo_Base { ... };
</pre>
and you have to write:
<pre class="verbatim">
class Foo : public Foo_Base {
   ...
};
</pre>
</TD></TR>
<TR> <TD align=left> 
abstract fields
<pre class="verbatim">
abstract double field;
</pre>
     </TD> <TD align=left>
<pre class="verbatim">
double getField() = 0;
void setField(double d) = 0;
</pre>
</TD></TR>
<TR> <TD align=left> 
</table>

<p>

<hr class='pgbr'><h1><a name="sec258"/>7 The Simulation Library</h1>
<a name="cha:the-simulation-library"></a>

<p>OMNEST has an extensive C++ class library which you can use when implementing
simple modules. Parts of the class library have already been covered in the
previous chapters:

<p><ul>
  <li>the message class <tt><a href="../api/classcMessage.html">cMessage</a></tt> (chapter <a href="#sec202">[5]</a>)
  <li>sending and receiving messages, scheduling and canceling
    events, terminating the module or the simulation
    (section <a href="#sec165">[4.7]</a>)
  <li>access to module gates and parameters via <tt><a href="../api/classcModule.html">cModule</a></tt> member functions
    (sections <a href="#sec155">[4.5]</a> and <a href="#sec161">[4.6]</a>)
  <li>accessing other modules in the network (section <a href="#sec181">[4.11]</a>)
  <li>dynamic module creation (section <a href="#sec183">[4.13]</a>)
</ul>

<p>This chapter discusses the rest of the simulation library:

<p><ul>
  <li>random number generation: <tt>normal()</tt>,
    <tt>exponential()</tt>, etc.
  <li>module parameters: <tt><a href="../api/classcPar.html">cPar</a></tt> class
  <li>storing data in containers: the <tt><a href="../api/classcArray.html">cArray</a></tt> and <tt><a href="../api/classcQueue.html">cQueue</a></tt> classes
  <li>routing support and discovery of network topology: <tt><a href="../api/classcTopology.html">cTopology</a></tt> class
  <li>recording statistics into files: <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> class
  <li>collecting simple statistics: <tt><a href="../api/classcStdDev.html">cStdDev</a></tt> and <tt>cWeightedStddev</tt> classes
  <li>distribution estimation: <tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt>,
    <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>, <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>, <tt><a href="../api/classcPSquare.html">cPSquare</a></tt>,
    <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> classes
  <li>making variables inspectable in the graphical user interface (Tkenv):
        the <tt>WATCH()</tt> macros
  <li>sending debug output to and prompting for user input in the graphical
    user interface (Tkenv<!--Tkenv-->): the <tt>ev</tt><!--ev--> object (<tt><a href="../api/classcEnvir.html">cEnvir</a></tt> class)
</ul>

<p>

<p>

<p><h2><a name="sec259"/>7.1 Class Library Conventions</h2>

<p><h3><a name="sec260"/>7.1.1 Base Class</h3>
<a name="sec:ch-sim-lib:cobject"></a>

<p>
Classes in the OMNEST simulation library are derived from <tt><a href="../api/classcObject.html">cObject</a></tt>
or its subclass <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>. Functionality and conventions that
come from <tt><a href="../api/classcObject.html">cObject</a></tt>:
<ul>
  <li>name attribute
  <li><tt>getClassName()</tt> member and other member functions giving textual
    information about the object
  <li>conventions for assignment, copying, duplicating the object
  <li>ownership<!--ownership--> control for containers derived from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
  <li>support for traversing the object tree
  <li>support for inspecting the object in graphical user interfaces (Tkenv)
</ul>

<p>Classes inherit and redefine several <tt><a href="../api/classcObject.html">cObject</a></tt> member functions;
in the following we'll discuss some of the practically important
ones.

<p>
<h3><a name="sec261"/>7.1.2 Setting and Getting Attributes</h3>

<p>Member functions that set and query object attributes follow
a naming convention; the setter member function begins with
<tt>set</tt>, and the getter begins with <tt>get</tt> (or in the case of
boolean attributes, with <tt>is</tt> or <tt>has</tt>, whichever is more
appropriate). For example, the <i>length</i> attribute of the
<tt><a href="../api/classcPacket.html">cPacket</a></tt> class can be set and read like this:

<pre class="cpp">
pk-&gt;setBitLength(1024);
length = pk-&gt;getBitLength();
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
    OMNEST 3.x and earlier versions did not have the <tt>get</tt> verb
    in the name of getter methods. There are scripts to port old source
    code to OMNEST 4.0; these tools and the suggested porting produre
    are described in the <i>Migration Guide</i>.
</ul>

<p><h3><a name="sec262"/>7.1.3 getClassName()</h3>
<a name="sec:sim-lib:classname"></a>

<p>
For each class, the <tt>getClassName()</tt> member function returns the class
name as a string:

<pre class="cpp">
const char *className = msg-&gt;getClassName(); // returns "<a href="../api/classcMessage.html">cMessage</a>"
</pre>
<p>

<p><h3><a name="sec263"/>7.1.4 Object Names</h3>
<a name="sec:sim-lib:name"></a>

<p>Gates, parameters and modules all have names in the NED files. At runtime,
those names are stored in the corresponding C++ objects, and are available
for the code with the <tt>getName()</tt> method. Other objects such as messages,
queues, result collection objects, etc. may also have names.
  <br><ul><font size=-1>[Object name is inherited from <tt><a href="../api/classcObject.html">cObject</a></tt> (which defines
  <tt>getName()</tt>), and from its subclass <tt><a href="../api/classcNamedObject.html">cNamedObject</a></tt> (which
  defines <tt>setName()</tt> and actually stores the name string).]</font></ul>
Object names are generally very useful when you are tracing, debugging or
demonstrating a simulation model.

<p>For example, you can get the name of a message object like this:

<pre class="cpp">
const char *name = msg-&gt;getName();
</pre>
<p>
The <tt>getName()</tt> method will never return <tt>NULL</tt>, the absence
of name string is always returned as the empty string (<tt>""</tt>).

<p>By convention, the object name is the first argument to the constructor
of every class, and it defaults to the empty string. To create an object with
a name, pass the name string (a <tt>const char *</tt> pointer) as the first
argument of the constructor:

<pre class="cpp">
<a href="../api/classcMessage.html">cMessage</a> *timeoutMsg = new <a href="../api/classcMessage.html">cMessage</a>("timeout");
</pre>
<p>
You can also change the name of an existing object:

<pre class="cpp">
timeoutMsg-&gt;setName("timeout");
</pre>
<p>
Both the constructor and <tt>setName()</tt> make an internal copy of the string,
instead of just storing the pointer passed to them.
  <br><ul><font size=-1>[In a simulation, there are usually many objects with the same name:
  modules, parameters, gates, etc. To conserve memory, several classes
  keep names in a shared, reference-counted <i>name pool</i> instead of
  making separate copies for each object. The runtime cost of looking up an
  existing string in the name pool and incrementing its reference count
  also compares favorably to the cost of allocation and copying.]</font></ul>

<p>For convenience and efficiency reasons, the empty string <tt>""</tt>
and <tt>NULL</tt> are treated as interchangeable by library objects.
That is, <tt>""</tt> is stored as <tt>NULL</tt> but returned as <tt>""</tt>.
If you create a message object with either <tt>NULL</tt>
or <tt>""</tt> as its name string, it will be stored as <tt>NULL</tt>
and <tt>getName()</tt> will return a pointer to a static <tt>""</tt>.

<pre class="cpp">
<a href="../api/classcMessage.html">cMessage</a> *msg = new <a href="../api/classcMessage.html">cMessage</a>(NULL, &lt;additional args&gt;);
const char *str = msg-&gt;getName(); // --&gt; returns ""
</pre>
<p>

<p><h3><a name="sec264"/>7.1.5 Object Full Name and Full Path</h3>
<a name="sec:sim-lib:fullname-and-fullpath"></a>

<p>
Objects have two additional member functions that return strings
based on the object name: <tt>getFullName()</tt> and <tt>getFullPath()</tt>.
For gates and modules which are part of gate or module vectors,
<tt>getFullName()</tt> returns the name with the index in brackets.
That is, for a module <tt>node[3]</tt> in the submodule vector <tt>node[10]</tt>
<tt>getName()</tt> returns <tt>"node"</tt>, and <tt>getFullName()</tt> returns <tt>"node[3]"</tt>.
For other objects, <tt>getFullName()</tt> is the same as <tt>getName()</tt>.

<p><tt>getFullPath()</tt> returns <tt>getFullName()</tt>, prepended with the
parent or owner object's <tt>getFullPath()</tt> and separated by a dot.
That is, if the <tt>node[3]</tt> module above is in the compound module
<tt>"net.subnet1"</tt>, its <tt>getFullPath()</tt> method will return
<tt>"net.subnet1.node[3]"</tt>.

<pre class="cpp">
ev &lt;&lt; this-&gt;getName();     // --&gt; "node"
ev &lt;&lt; this-&gt;getFullName(); // --&gt; "node[3]"
ev &lt;&lt; this-&gt;getFullPath(); // --&gt; "net.subnet1.node[3]"
</pre>
<p>
<tt>getClassName()</tt>, <tt>getFullName()</tt> and <tt>getFullPath()</tt>
are extensively used on the graphical runtime environment Tkenv,
and also appear in error messages.

<p><tt>getName()</tt> and <tt>getFullName()</tt> return <tt>const char *</tt> pointers,
and <tt>getFullPath()</tt> returns <tt>std::string</tt>. This makes no difference
with <tt>ev&lt;&lt;</tt>, but when <tt>getFullPath()</tt> is used as a <tt>"%s"</tt> argument
to <tt>sprintf()</tt> you have to write <tt>getFullPath().c_str()</tt>.

<pre class="cpp">
char buf[100];
sprintf("msg is '%80s'", msg-&gt;getFullPath().c_str()); // note c_str()
</pre>
<p>

<p><h3><a name="sec265"/>7.1.6 Copying and Duplicating Objects</h3>

<p>
The <tt>dup()</tt> member function creates an exact copy of the
object<!--object!copy-->, duplicating<!--object!duplication-->
contained objects also if necessary. This is especially useful in the
case of message objects.

<pre class="cpp">
<a href="../api/classcMessage.html">cMessage</a> *copy = msg-&gt;dup();
</pre>
<p>
<tt>dup()</tt> delegates to the copy constructor. Classes also declare
an assignment operator (<tt>operator=()</tt>) which can be used to copy contents
of an object into another object of the same type. <tt>dup()</tt>, the copy
constructor and the assignment operator all perform deep coping: objects
contained in the copied object will also be duplicated if necessary.

<p><tt>operator=()</tt> differs from the other two in that it does <i>not</i>
copy the object's name string, i.e. does not invoke <tt>setName()</tt>.
The rationale is that the name string is often used for identifying the particular
object instance, as opposed to being considered as part of its contents.

<p><ul class="note"><b>NOTE</b><br>
    Since the OMNEST 4.0 version, <tt>dup()</tt> returns a pointer to
    the same type as the object itself, and not a <tt><a href="../api/classcObject.html">cObject</a>*</tt>.
    This is made possible by a relatively new C++ feature called
    <i>covariant return types</i>.
</ul>

<p><h3><a name="sec266"/>7.1.7 Iterators</h3>

<p>
There are several container classes in the library (<tt><a href="../api/classcQueue.html">cQueue</a></tt>,
<tt><a href="../api/classcArray.html">cArray</a></tt> etc.) For many of them, there is a corresponding
iterator class that you can use to loop through the objects stored in
the container.

<p>For example:

<pre class="cpp">
<a href="../api/classcQueue.html">cQueue</a> queue;

//..
for (<a href="../api/classcQueue.html">cQueue</a>::Iterator queueIter(queue); !queueIter.end(); queueIter++)
{
    <a href="../api/classcOwnedObject.html">cOwnedObject</a> *containedObject = queueIter();
}
</pre>
<p>

<p>
<h3><a name="sec267"/>7.1.8 Error Handling</h3>

<p>
When library objects detect an error condition, they throw a C++ exception.
This exception is then caught by the simulation environment which pops up
an error dialog or displays the error message.

<p>At times it can be useful to be able stop the simulation at the place of the error
(just before the exception is thrown) and use a C++ debugger to look
at the stack trace and examine variables. Enabling the <tt>debug-on-errors</tt>
configuration option lets you do that -- check it in section
<a href="#sec334">[9.2]</a>  .

<p>If you detect an error condition in your code, you can stop the
simulation with an error message using the <tt>opp_error()</tt> function.
<tt>opp_error()</tt>'s argument list works like <tt>printf()</tt>: the
first argument is a format string which can contain <tt>"%s"</tt>, <tt>"%d"</tt> etc,
filled in using subsequent arguments.

<p>An example:

<pre class="cpp">
if (msg-&gt;getControlInfo()==NULL)
    opp_error("message (%s)%s has no control info attached",
              msg-&gt;getClassName(), msg-&gt;getName());
</pre>
<p>

<p>
<h2><a name="sec268"/>7.2 Logging from Modules</h2>

<p>The logging feature will be used extensively in the code examples, so
we introduce it here.

<p>The <tt>ev</tt><!--ev--> object represents the user interface of the
simulation.  You can send debugging output to <tt>ev</tt> with the C++-style
output operators:

<pre class="cpp">
ev &lt;&lt; "packet received, sequence number is " &lt;&lt; seqNum &lt;&lt; endl;
ev &lt;&lt; "queue full, discarding packet\n";
</pre>
<p>
An alternative solution is <tt>ev.printf()</tt>:

<pre class="cpp">
ev.printf("packet received, sequence number is %d\n", seqNum);
</pre>
<p>
The exact way messages are displayed to the user depends on the user
interface. In the command-line user interface (Cmdenv<!--Cmdenv-->),
the message is simply dumped to the standard output. (This output can also be
disabled from <tt>omnetpp.ini</tt> so that it doesn't slow down simulation
when it is not needed.) In Tkenv, the runtime GUI, you can open
a text output window for every module.
It is not recommended that you use <tt>printf()</tt> or <tt>cout</tt>
to print messages -- <tt>ev</tt> output can be controlled more easily
from <tt>omnetpp.ini</tt> and it is more convenient to view, using Tkenv.

<p>One can save CPU cycles by making logging statements conditional
on whether the output is actually being displayed or recorded anywhere.
The <tt>ev.isDisabled()</tt> call returns true when <tt>ev&lt;&lt;</tt> output is disabled,
such as in Tkenv or Cmdenv &#8220;express&#8221; mode. Thus, one can write code like
this:

<pre class="cpp">
if (!ev.isDisabled())
    ev &lt;&lt; "Packet " &lt;&lt; msg-&gt;getName() &lt;&lt; " received\n";
</pre>
<p>
A more sophisticated implementation of the same idea is to the <tt>EV</tt>
macro which can be used in logging statements instead of <tt>ev</tt>.
One would simply write <tt>EV&lt;&lt;</tt> instead of <tt>ev&lt;&lt;</tt>:

<pre class="cpp">
EV &lt;&lt; "Packet " &lt;&lt; msg-&gt;getName() &lt;&lt; " received\n";
</pre>
<p>
<tt>EV</tt>'s implementation makes use of the fact that the <tt>&lt;&lt;</tt> operator
is bound more loosely than the conditional operator (<tt>?:</tt>).

<p>

<p><h2><a name="sec269"/>7.3 Simulation Time Conversion</h2>

<p>Simulation time is represented by the type <tt>simtime_t</tt>
which is a typedef to a class that stores simulation time in a 64-bit integer, using
decimal ﬁxed-point representation.
OMNEST provides utility functions, which convert <tt>simtime_t</tt>
to a printable string (<tt>"3s 130ms 230us"</tt>) and vica versa.

<p>The <tt>simtimeToStr()</tt> function converts a <tt>simtime_t</tt>
(passed in the first argument) to textual form. The result is placed into
the <tt>char</tt> array pointed to by the second argument. If the second argument is omitted
or it is <tt>NULL</tt>, <tt>simtimeToStr()</tt> will place the result into a
static buffer which is overwritten with each call. An example:

<pre class="cpp">
char buf[32];
ev.printf("t1=%s, t2=%s\n", simtimeToStr(t1), simTimeToStr(t2,buf));
</pre>
<p>
The <tt>simtimeToStrShort()</tt> is similar to <tt>simtimeToStr()</tt>,
but its output is more concise.

<p>The <tt>strToSimtime()</tt> function parses a time specification passed
in a string, and returns a <tt>simtime_t</tt>. If the string cannot
be entirely interpreted, -1 is returned.

<pre class="cpp">
simtime_t t = strToSimtime("30s 152ms");
</pre>
<p>
Another variant, <tt>strToSimtime0()</tt> can be used if the time
string is a substring in a larger string. Instead of taking a <tt>char*</tt>,
it takes a reference to <tt>char*</tt> (<tt>char*&amp;</tt>) as the first argument.  The
function sets the pointer to the first character that could not be
interpreted as part of the time string, and returns the value. It
never returns -1; if nothing at the beginning of the string looked
like simulation time, it returns 0.

<pre class="cpp">
const char *s = "30s 152ms and something extra";

simtime_t t = strToSimtime0(s); // now s points to "and something extra"
</pre>
<p>

<p><h2><a name="sec270"/>7.4 Generating Random Numbers</h2>
<a name="cha:sim-lib:generating-random-numbers"></a>

<p>Random numbers in simulation are never random. Rather, they are
produced using deterministic algorithms. Algorithms take a <i>seed</i> value
and perform some deterministic calculations on them to produce
a &#8220;random&#8221; number and the next seed. Such algorithms and their
implementations are called <i>random number generators</i> or RNGs,
or sometimes pseudo random number generators or PRNGs to highlight
their deterministic nature.
  <br><ul><font size=-1>[There are real random numbers as well, see e.g.
  http://www.random.org/, http://www.comscire.com, or the Linux
  <i>/dev/random</i> device. For non-random numbers, try www.noentropy.net.]</font></ul>

<p>Starting from the same seed, RNGs always produce the same sequence
of random numbers. This is a useful property and of great importance,
because it makes simulation runs repeatable.

<p>RNGs produce uniformly distributed integers in some range,
usually between 0 or 1 and <i>2<sup>32</sup></i> or so. Mathematical transformations
are used to produce random variates from them that correspond to
specific distributions.

<p><h3><a name="sec271"/>7.4.1 Random Number Generators</h3>
<a name="sec:sim-lib:rngs"></a>
<!--random number generator-->

<p><p class="subheading">Mersenne Twister</p>

<p>By default, OMNEST uses the Mersenne Twister RNG (MT) by M. Matsumoto and
T. Nishimura [<a href="#bib-Matsumoto98">Matsumoto98</a>]. MT has a period of <i>2<sup>19937</sup>-1</i>,
and 623-dimensional equidistribution property is assured. MT is
also very fast: as fast or faster than ANSI C's <tt>rand()</tt>.

<p><p class="subheading">The "Minimal Standard" RNG</p>

<p>OMNEST releases prior to 3.0 used a linear congruential generator
(LCG) with a cycle length of <i>2<sup>31</sup>-2</i>, described in
[<a href="#bib-Jain91">Jain91</a>], pp. 441-444,455. This RNG is still available
and can be selected from <tt>omnetpp.ini</tt> (Chapter <a href="#sec355">[10]</a>).
This RNG is only suitable for small-scale simulation studies.
As shown by Karl Entacher et al. in [<a href="#bib-Entacher02">Entacher02</a>],
the cycle length of about <i>2<sup>31</sup></i> is too small (on todays
fast computers it is easy to exhaust all random numbers), and
the structure of the generated &#8220;random&#8221; points is too regular.
The [<a href="#bib-Hellekalek98">Hellekalek98</a>] paper provides a broader overview of issues
associated with RNGs used for simulation, and it is well worth reading.
It also contains useful links and references on the topic.

<p><p class="subheading">The Akaroa RNG</p>

<p>When you execute simulations under Akaroa control (see section
<a href="#sec371">[10.5]</a>), you can also select Akaroa's
RNG as the RNG underlying for the OMNEST random number functions.
The Akaroa RNG also has to be selected from <tt>omnetpp.ini</tt>
(section <a href="#sec349">[9.5]</a>).

<p><p class="subheading">Other RNGs</p>

<p>OMNEST allows plugging in your own RNGs as well. This mechanism,
based on the <tt><a href="../api/classcRNG.html">cRNG</a></tt> interface, is described in section
<a href="#sec488">[17.1]</a>.
For example, one candidate to include could be L'Ecuyer's CMRG [<a href="#bib-LEcuyer02">LEcuyer02</a>]
which has a period of about <i>2<sup>191</sup></i> and can provide a large
number of <i>guaranteed</i> independent streams.

<p>
<h3><a name="sec272"/>7.4.2 Random Number Streams, RNG Mapping</h3>

<p>Simulation programs may consume random numbers from several streams,
that is, from several independent RNG instances. For example, if a
network simulation uses random numbers for generating packets and
for simulating bit errors in the transmission, it might be a good
idea to use different random streams for both. Since the seeds
for each stream can be configured independently, this arrangement
would allow you to perform several simulation runs with the same traffic
but with bit errors occurring in different places.
A simulation technique called <i>variance reduction</i> is
also related to the use of different random number streams.

<p>It is also important that different streams and also different
simulation runs use non-overlapping series of random numbers.
Overlap in the generated random number sequences can introduce
unwanted correlation in your results.

<p>The number of random number streams as well as seeds for the individual
streams can be configured in <tt>omnetpp.ini</tt>
(section <a href="#sec349">[9.5]</a>).
For the "minimal standard RNG", the <tt>seedtool</tt> program can be
used for selecting good seeds (section <a href="#sec354">[9.5.5]</a>).

<p>In OMNEST, streams are identified with RNG numbers. The RNG numbers
used in simple modules may be <i>arbitrarily mapped</i> to the actual
random number streams (actual RNG instances) from <tt>omnetpp.ini</tt>
(section <a href="#sec349">[9.5]</a>). The mapping allows
for great flexibility in RNG usage and random number streams
configuration -- even for simulation models which were not written
with RNG awareness.

<p>
<h3><a name="sec273"/>7.4.3 Accessing The RNGs</h3>

<p>The <tt>intrand(n)</tt> function generates random integers in the range <i>[0, n-1]</i>, and
<tt>dblrand()</tt> generates a random double on <i>[0,1)</i>. These functions
simply wrap the underlying RNG objects. Examples:

<pre class="cpp">
int dice = 1 + intrand(6); // result of intrand(6) is in the range 0..5
double p = dblrand();      // dblrand() produces numbers in [0,1)
</pre>
<p>
They also have a counterparts that use generator <i>k</i>:

<pre class="cpp">
int dice = 1 + intrand(k,6); // uses generator k
double prob = dblrand(k);    // ""
</pre>
<p>
The underlying RNG objects are subclassed from <tt><a href="../api/classcRNG.html">cRNG</a></tt>,
and they can be accessed via <tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>getRNG()</tt> method.
The argument to <tt>getRNG()</tt> is a local RNG number which will undergo
RNG mapping.

<pre class="cpp">
<a href="../api/classcRNG.html">cRNG</a> *rng1 = getRNG(1);
</pre>
<p>
<tt><a href="../api/classcRNG.html">cRNG</a></tt> contains the methods implementing the above <tt>intrand()</tt>
and <tt>dblrand()</tt> functions. The <tt><a href="../api/classcRNG.html">cRNG</a></tt> interface also allows
you to access the &#8220;raw&#8221; 32-bit random numbers generated by the RNG
and to learn their ranges (<tt>intRand()</tt>, <tt>intRandMax()</tt>) as well as
to query the number of random numbers generated (<tt>getNumbersDrawn()</tt>).

<p>
<h3><a name="sec274"/>7.4.4 Random Variates</h3>

<p>The following functions are based on <tt>dblrand()</tt> and return
random variables of different distributions<!--distribution!random variables--><!--random!numbers from distributions-->:

<p>Random variate functions use one of the random number generators (RNGs)
provided by OMNEST. By default this is generator 0, but you can specify
which one to be used.

<p>OMNEST has the following predefined distributions<!--distribution!predefined-->:

<p><table border>
<TR> <TD align=left>
<b>Function</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>Continuous distributions</b></TD></TR>
<TR> <TD align=left> <tt>uniform(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> uniform distribution in the range [a,b) </TD></TR>
<TR> <TD align=left> <tt>exponential(mean, <i>rng=0</tt>)</i> </TD> <TD align=left> exponential distribution with the given mean </TD></TR>
<TR> <TD align=left> <tt>normal(mean, stddev, <i>rng=0</tt>)</i> </TD> <TD align=left> normal distribution with the given mean and standard deviation </TD></TR>
<TR> <TD align=left> <tt>truncnormal(mean, stddev, <i>rng=0</tt>)</i> </TD> <TD align=left> normal distribution truncated to nonnegative values </TD></TR>
<TR> <TD align=left> <tt>gamma_d(alpha, beta, <i>rng=0</tt>)</i> </TD> <TD align=left> gamma distribution with parameters alpha&gt;0, beta&gt;0 </TD></TR>
<TR> <TD align=left> <tt>beta(alpha1, alpha2, <i>rng=0</tt>)</i> </TD> <TD align=left> beta distribution with parameters alpha1&gt;0, alpha2&gt;0 </TD></TR>
<TR> <TD align=left> <tt>erlang_k(k, mean, <i>rng=0</tt>)</i> </TD> <TD align=left> Erlang distribution with k&gt;0 phases and the given mean </TD></TR>
<TR> <TD align=left> <tt>chi_square(k, <i>rng=0</tt>)</i> </TD> <TD align=left> chi-square distribution with k&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>student_t(i, <i>rng=0</tt>)</i> </TD> <TD align=left> student-t distribution with i&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>cauchy(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> Cauchy distribution with parameters a,b where b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>triang(a, b, c, <i>rng=0</tt>)</i> </TD> <TD align=left> triangular distribution with parameters a&lt;=b&lt;=c, a!=c </TD></TR>
<TR> <TD align=left> <tt>lognormal(m, s, rng=0)</tt> </TD> <TD align=left> lognormal distribution with mean m and variance s&gt;0 </TD></TR>
<TR> <TD align=left> <tt>weibull(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> Weibull distribution with parameters a&gt;0, b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>pareto_shifted(a, b, c, <i>rng=0</tt>)</i> </TD> <TD align=left> generalized Pareto distribution with parameters a, b and shift c </TD></TR>
<TR> <TD align=center colspan=2><b>Discrete distributions</b> </TD></TR>
<TR> <TD align=left> <tt>intuniform(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> uniform integer from a..b </TD></TR>
<TR> <TD align=left> <tt>bernoulli(p, <i>rng=0</tt>)</i> </TD> <TD align=left> result of a Bernoulli trial with probability 0&lt;=p&lt;=1 (1 with probability p and 0 with probability (1-p)) </TD></TR>
<TR> <TD align=left> <tt>binomial(n, p, <i>rng=0</tt>)</i> </TD> <TD align=left> binomial distribution with parameters n&gt;=0 and 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>geometric(p, <i>rng=0</tt>)</i> </TD> <TD align=left> geometric distribution with parameter 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>negbinomial(n, p, <i>rng=0</tt>)</i> </TD> <TD align=left> negative binomial distribution with parameters n&gt;0 and 0&lt;=p&lt;=1</TD></TR>
<TR> <TD align=left> <tt>poisson(lambda, <i>rng=0</tt>)</i> </TD> <TD align=left> Poisson distribution with parameter lambda </TD></TR>
<TR> <TD align=left> 
</table>

<p>
They are the same functions that can be used in NED files.
<tt>intuniform()</tt> generates integers including both the lower and
upper limit, so for example the outcome of tossing a coin could be
written as intuniform(1,2).  <tt>truncnormal()</tt> is the normal
distribution truncated to nonnegative values; its implementation
generates a number with normal distribution and if the result is
negative, it keeps generating other numbers until the outcome is
nonnegative.

<p>If the above distributions don't suffice, you can write your own
functions<!--distribution!custom-->. If you register your functions
with the <tt>Define_NED_Function()</tt> macro, you can use them in NED
files and ini files too.

<p>
<h3><a name="sec275"/>7.4.5 Random Numbers from Histograms</h3>

<p>You can also specify your distribution as a
histogram<!--distribution!as histogram-->. The
<tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt>, <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>,
<tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>, <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> or <tt><a href="../api/classcPSquare.html">cPSquare</a></tt> classes
are there to generate random numbers from equidistant-cell or
equiprobable-cell histograms.  This feature is documented later, with
the statistical classes.

<p>

<p>

<p><h2><a name="sec276"/>7.5 Container Classes</h2>

<p><h3><a name="sec277"/>7.5.1 Queue class: <a href="../api/classcQueue.html">cQueue</a></h3>

<p><p class="subheading">Basic Usage</p>

<p>
<tt><a href="../api/classcQueue.html">cQueue</a></tt> is a container class that acts as a queue.
<tt><a href="../api/classcQueue.html">cQueue</a></tt> can hold objects of type derived from <tt><a href="../api/classcObject.html">cObject</a></tt>
(almost all classes from the OMNEST library), such as
<tt><a href="../api/classcMessage.html">cMessage</a></tt>, <tt><a href="../api/classcPar.html">cPar</a></tt>, etc. Internally, <tt><a href="../api/classcQueue.html">cQueue</a></tt>
uses a double-linked list to store the elements.

<p>A queue object has a head and a tail. Normally, new elements
are inserted at its head and elements are removed at its tail.

<p>

<p>  <center>
    <img src="simlib-queue.png">
    <center><i>Figure: <a href="../api/classcQueue.html">cQueue</a>: insertion and removal</i></center>
    <a name="fig:ch-sim-lib:cqueue"></a>
  </center>

<p>
The basic <tt><a href="../api/classcQueue.html">cQueue</a></tt> member functions dealing with insertion and removal
are <tt>insert()</tt> and <tt>pop()</tt>. They are used
like this:

<pre class="cpp">
<a href="../api/classcQueue.html">cQueue</a> queue("my-queue");
<a href="../api/classcMessage.html">cMessage</a> *msg;

// insert messages
for (int i=0; i&lt;10; i++)
{
  msg = new <a href="../api/classcMessage.html">cMessage</a>;
  queue.insert(msg);
}

// remove messages
while(!queue.empty())
{
  msg = (<a href="../api/classcMessage.html">cMessage</a> *)queue.pop();
  delete msg;
}
</pre>
<p>

<p>The <tt>length()</tt> member function returns the number of items in the
queue, and <tt>empty()</tt> tells whether there is anything in the queue.

<p>There are other functions dealing with insertion and removal.  The
<tt>insertBefore()</tt> and <tt>insertAfter()</tt> functions insert a
new item exactly before or after a specified one, regardless of the
ordering function.

<p>The <tt>front()</tt> and <tt>back()</tt> functions return pointers to the objects
at the front and back of the queue, without affecting queue contents.

<p>The <tt>pop()</tt> function can be used to remove items from the
tail of the queue, and the <tt>remove()</tt> function can be
used to remove any item known by its pointer from the queue:

<pre class="cpp">
queue.remove(msg);
</pre>
<p>

<p>
<p class="subheading">Priority Queue</p>

<p>
By default, <tt><a href="../api/classcQueue.html">cQueue</a></tt> implements a FIFO, but it can also act as
a priority queue, that is, it can keep the inserted objects
ordered<!--queue!order-->.  If you want to use this feature, you have
to provide a function that takes two <tt><a href="../api/classcObject.html">cObject</a></tt> pointers,
compares the two objects and returns -1, 0 or 1 as the result (see the
reference for details).  An example of setting up an ordered
<tt><a href="../api/classcQueue.html">cQueue</a></tt>:

<pre class="cpp">
<a href="../api/classcQueue.html">cQueue</a> queue("queue", someCompareFunc);
</pre>
<p>

<p>If the queue object is set up as an ordered queue, the <tt>insert()</tt>
function uses the ordering function: it searches the queue contents
from the head until it reaches the position where the new item
needs to be inserted, and inserts it there.

<p>
<p class="subheading">Iterators</p>

<p>
Normally, you can only access the objects at the head or tail of the
queue. However, if you use an iterator class, <tt><a href="../api/classcQueue.html">cQueue</a>::Iterator</tt>,
you can examine each object in the queue<!--queue!iteration-->.

<p>The <tt><a href="../api/classcQueue.html">cQueue</a>::Iterator</tt> constructor takes two arguments; the first
is the queue object and the second argument specifies the initial position
of the iterator: 0=tail, 1=head. Otherwise it acts as any other
OMNEST iterator class: you can use the <tt>++</tt> and <tt>--</tt> operators to advance
it, the () operator to get a pointer to the current item, and the
<tt>end()</tt> member function to examine if you are at the end (or the
beginning) of the queue.

<p>
An example:

<pre class="cpp">
for( <a href="../api/classcQueue.html">cQueue</a>::Iterator iter(queue,1); !iter.end(), iter++)
{
  <a href="../api/classcMessage.html">cMessage</a> *msg = (<a href="../api/classcMessage.html">cMessage</a> *) iter();
  //...
}
</pre>
<p>

<p>

<p><h3><a name="sec278"/>7.5.2 Expandable Array: <a href="../api/classcArray.html">cArray</a></h3>

<p><p class="subheading">Basic Usage</p>

<p>
<tt><a href="../api/classcArray.html">cArray</a></tt> is a container class that holds objects derived from
<tt><a href="../api/classcObject.html">cObject</a></tt>. <tt><a href="../api/classcArray.html">cArray</a></tt> stores the pointers of the objects
inserted instead of making copies. <tt><a href="../api/classcArray.html">cArray</a></tt> works as an array,
but it grows automatically when it becomes full. Internally,
<tt><a href="../api/classcArray.html">cArray</a></tt> is implemented with an array of pointers; when the array
fills up, it is reallocated.

<p><tt><a href="../api/classcArray.html">cArray</a></tt> objects are used in OMNEST to store parameters
attached to messages, and internally, for storing module parameters
and gates.

<p>
Creating an array:

<pre class="cpp">
<a href="../api/classcArray.html">cArray</a> array("array");
</pre>
<p>
Adding an object at the first free index:

<pre class="cpp">
<a href="../api/classcPar.html">cPar</a> *p = new <a href="../api/classcMsgPar.html">cMsgPar</a>("par");
int index = array.add( p );
</pre>
<p>

<p>Adding an object at a given index (if the index is occupied,
you will get an error message):

<pre class="cpp">
<a href="../api/classcPar.html">cPar</a> *p = new <a href="../api/classcMsgPar.html">cMsgPar</a>("par");
int index = array.addAt(5,p);
</pre>
<p>

<p>Finding an object in the array:

<pre class="cpp">
int index = array.find(p);
</pre>
<p>
Getting a pointer to an object at a given index:

<pre class="cpp">
<a href="../api/classcPar.html">cPar</a> *p = (<a href="../api/classcPar.html">cPar</a> *) array[index];
</pre>
<p>
You can also search the array or get a pointer to an object by
the object's name:

<pre class="cpp">
int index = array.find("par");
Par *p = (<a href="../api/classcPar.html">cPar</a> *) array["par"];
</pre>
<p>

<p>You can remove an object from the array by calling <tt>remove()</tt>
with the object name, the index position or the object pointer:

<pre class="cpp">
array.remove("par");
array.remove(index);
array.remove( p );
</pre>
<p>

<p>The <tt>remove()</tt> function doesn't deallocate the object, but it
returns the object pointer. If you also want to deallocate it, you can
write:

<pre class="cpp">
delete array.remove( index );
</pre>
<p>
<p class="subheading">Iteration</p>

<p>
<tt><a href="../api/classcArray.html">cArray</a></tt> has no iterator, but it is easy to loop through all the
indices with an integer variable. The <tt>size()</tt> member function
returns the largest index plus one.

<pre class="cpp">
for (int i=0; i&lt;array.size(); i++)
{
    if (array[i]) // is this position used?
    {
        <a href="../api/classcObject.html">cObject</a> *obj = array[i];
        ev &lt;&lt; obj-&gt;getName() &lt;&lt; endl;
    }
}
</pre>
<p>





<p><h2><a name="sec279"/>7.6 Routing Support: <a href="../api/classcTopology.html">cTopology</a></h2>

<p><h3><a name="sec280"/>7.6.1 Overview</h3>

<p>The <tt><a href="../api/classcTopology.html">cTopology</a></tt> class was designed primarily to support
routing<!--routing support--> in telecommunication or multiprocessor
networks.

<p>A <tt><a href="../api/classcTopology.html">cTopology</a></tt> object stores an abstract representation of the
network in graph form:
<ul>
  <li>each <tt><a href="../api/classcTopology.html">cTopology</a></tt> node corresponds to a <i>module</i>
    (simple or compound), and
  <li>each <tt><a href="../api/classcTopology.html">cTopology</a></tt> edge corresponds to a <i>link</i> or
    <i>series of connecting links</i>.
</ul>

<p>You can specify which modules (either simple or compound) you want to
include in the graph. The graph will include all connections among the
selected modules. In the graph, all nodes are at the same level;
there is no submodule nesting.  Connections which span across compound
module boundaries are also represented as one graph edge. Graph edges
are directed, just as module gates are.

<p>
If you are writing a router or switch model, the <tt><a href="../api/classcTopology.html">cTopology</a></tt>
graph can help you determine what nodes are available through which
gate and also to find optimal routes<!--optimal routes-->. The
<tt><a href="../api/classcTopology.html">cTopology</a></tt> object can calculate shortest paths<!--shortest
  path--> between nodes for you.

<p>The mapping between the graph (nodes, edges) and network model
(modules, gates, connections) is preserved: you can easily find
the corresponding module for a <tt><a href="../api/classcTopology.html">cTopology</a></tt> node and vica versa.

<p>

<p>

<p><h3><a name="sec281"/>7.6.2 Basic Usage</h3>

<p>You can extract the network topology into a <tt><a href="../api/classcTopology.html">cTopology</a></tt>
object by a single function call. You have several ways to select
which modules you want to include in the topology:
<ul>
  <li>by module type
  <li>by a parameter's presence and its value
  <li>with a user-supplied boolean function
</ul>

<p>First, you can specify which node types you want to include. The
following code extracts all modules of type <tt>Router</tt> or <tt>Host</tt>.
(<tt>Router</tt> and <tt>Host</tt> can be either simple or compound module types.)

<pre class="cpp">
<a href="../api/classcTopology.html">cTopology</a> topo;
topo.extractByModuleType("Router", "Host", NULL);
</pre>
<p>
Any number of module types can be supplied; the list must be terminated by <tt>NULL</tt>.

<p>A dynamically assembled list of module types can be passed as a
<tt>NULL</tt>-terminated array of <tt>const char*</tt> pointers, or
in an STL string vector <tt>std::vector&lt;std::string&gt;</tt>.
An example for the former:

<pre class="cpp">
<a href="../api/classcTopology.html">cTopology</a> topo;
const char *typeNames[3];
typeNames[0] = "Router";
typeNames[1] = "Host";
typeNames[2] = NULL;
topo.extractByModuleType(typeNames);
</pre>
<p>
Second, you can extract all modules which have a certain parameter:

<pre class="cpp">
topo.extractByParameter( "ipAddress" );
</pre>
<p>
You can also specify that the parameter must have a certain value
for the module to be included in the graph:

<pre class="cpp">
<a href="../api/classcMsgPar.html">cMsgPar</a> yes = "yes";
topo.extractByParameter( "includeInTopo", &yes );
</pre>
<p>
The third form allows you to pass a function which can determine for
each module whether it should or should not be included.  You can have
<tt><a href="../api/classcTopology.html">cTopology</a></tt> pass supplemental data to the function through a
<tt>void*</tt> pointer. An example which selects all top-level modules (and
does not use the <tt>void*</tt> pointer):

<pre class="cpp">
int selectFunction(<a href="../api/classcModule.html">cModule</a> *mod, void *)
{
  return mod-&gt;getParentModule() == simulation.getSystemModule();
}

topo.extractFromNetwork( selectFunction, NULL );
</pre>
<p>

A <tt><a href="../api/classcTopology.html">cTopology</a></tt> object uses two types: <tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt> for
nodes and <tt><a href="../api/classcTopology.html">cTopology</a>::Link</tt> for edges. (<tt>sTopoLinkIn</tt> and
<tt><a href="../api/classcTopology.html">cTopology</a>::LinkOut</tt> are `aliases' for <tt><a href="../api/classcTopology.html">cTopology</a>::Link</tt>; we'll
talk about them later.)

<p>Once you have the topology extracted, you can start exploring
it. Consider the following code (we'll explain it shortly):

<pre class="cpp">
for (int i=0; i&lt;topo.getNumNodes(); i++)
{
  <a href="../api/classcTopology.html">cTopology</a>::Node *node = topo.getNode(i);
  ev &lt;&lt; "Node i=" &lt;&lt; i &lt;&lt; " is " &lt;&lt; node-&gt;getModule()-&gt;getFullPath() &lt;&lt; endl;
  ev &lt;&lt; " It has " &lt;&lt; node-&gt;getNumOutLinks() &lt;&lt; " conns to other nodes\n";
  ev &lt;&lt; " and " &lt;&lt; node-&gt;getNumInLinks() &lt;&lt; " conns from other nodes\n";

  ev &lt;&lt; " Connections to other modules are:\n";
  for (int j=0; j&lt;node-&gt;getNumOutLinks(); j++)
  {
    <a href="../api/classcTopology.html">cTopology</a>::Node *neighbour = node-&gt;getLinkOut(j)-&gt;getRemoteNode();
    <a href="../api/classcGate.html">cGate</a> *gate = node-&gt;getLinkOut(j)-&gt;getLocalGate();
    ev &lt;&lt; " " &lt;&lt; neighbour-&gt;getModule()-&gt;getFullPath()
       &lt;&lt; " through gate " &lt;&lt; gate-&gt;getFullName() &lt;&lt; endl;
  }
}
</pre>
<p>
The <tt>getNumNodes()</tt> member function (1st line) returns the number of
nodes in the graph, and getNode(i) returns a pointer to the <i>i</i>th
node, an <tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt> structure.

<p>
The correspondence between a graph node and a module can be obtained
by:

<pre class="cpp">
<a href="../api/classcTopology.html">cTopology</a>::Node *node = topo.getNodeFor( module );
<a href="../api/classcModule.html">cModule</a> *module = node-&gt;getModule();
</pre>
<p>

<p>The <tt>getNodeFor()</tt> member function returns a pointer to the graph
node for a given module. (If the module is not in the graph, it
returns <tt>NULL</tt>). <tt>getNodeFor()</tt> uses binary search within the
<tt><a href="../api/classcTopology.html">cTopology</a></tt> object so it is relatively fast.

<p>
<tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt>'s other member functions let you determine the
connections of this node: <tt>getNumInLinks()</tt>, <tt>getNumOutLinks()</tt> return
the number of connections, <tt>in(i)</tt> and
<tt>out(i)</tt> return pointers to graph edge objects.

<p>
By calling member functions of the graph edge object, you can
determine the modules and gates involved. The <tt>getRemoteNode()</tt>
function returns the other end of the connection, and
<tt>getLocalGate()</tt>, <tt>getRemoteGate()</tt>, <tt>getLocalGateId()</tt> and
<tt>getRemoteGateId()</tt> return the gate pointers and ids of the gates
involved. (Actually, the implementation is a bit tricky here: the same
graph edge object <tt><a href="../api/classcTopology.html">cTopology</a>::Link</tt> is returned either as
<tt><a href="../api/classcTopology.html">cTopology</a>::LinkIn</tt> or as <tt><a href="../api/classcTopology.html">cTopology</a>::LinkOut</tt> so that &#8220;remote&#8221;
and &#8220;local&#8221; can be correctly interpreted for edges of both
directions.)

<p>

<p>

<p><h3><a name="sec282"/>7.6.3 Shortest Paths</h3>

<p>The real power of <tt><a href="../api/classcTopology.html">cTopology</a></tt> is in finding shortest
paths<!--topology!shortest path--> in the network to support optimal
routing<!--optimal routing-->. <tt><a href="../api/classcTopology.html">cTopology</a></tt> finds shortest paths
from <i>all</i> nodes <i>to</i> a target node. The algorithm is
computationally inexpensive. In the simplest case, all edges are
assumed to have the same weight.

<p>A real-life example assumes we have the target module pointer; finding
the shortest path to the target looks like this:

<pre class="cpp">
<a href="../api/classcModule.html">cModule</a> *targetmodulep =...;
<a href="../api/classcTopology.html">cTopology</a>::Node *targetnode = topo.getNodeFor( targetmodulep );
topo.calculateUnweightedSingleShortestPathsTo( targetnode );
</pre>
<p>

<p>This performs the Dijkstra algorithm<!--Dijkstra algorithm--> and
stores the result in the <tt><a href="../api/classcTopology.html">cTopology</a></tt> object. The result can
then be extracted using <tt><a href="../api/classcTopology.html">cTopology</a></tt> and
<tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt><!--<a href="../api/classcTopology.html">cTopology</a>::Node--> methods.  Naturally, each call to
<tt>calculateUnweightedSingleShortestPathsTo()</tt> overwrites the results of
the previous call.

<p>Walking along the path from our module to the target node:

<pre class="cpp">
<a href="../api/classcTopology.html">cTopology</a>::Node *node = topo.getNodeFor( this );

if (node == NULL)
{
  ev &lt; "We (" &lt;&lt; getFullPath() &lt;&lt; ") are not included in the topology.\n";
}
else if (node-&gt;getNumPaths()==0)
{
  ev &lt;&lt; "No path to destination.\n";
}
else
{
  while (node != topo.getTargetNode())
  {
    ev &lt;&lt; "We are in " &lt;&lt; node-&gt;getModule()-&gt;getFullPath() &lt;&lt; endl;
    ev &lt;&lt; node-&gt;getDistanceToTarget() &lt;&lt; " hops to go\n";
    ev &lt;&lt; "There are " &lt;&lt; node-&gt;getNumPaths()
       &lt;&lt; " equally good directions, taking the first one\n";
    <a href="../api/classcTopology.html">cTopology</a>::LinkOut *path = node-&gt;getPath(0);
    ev &lt;&lt; "Taking gate " &lt;&lt; path-&gt;getLocalGate()-&gt;getFullName()
       &lt;&lt; " we arrive in " &lt;&lt; path-&gt;getRemoteNode()-&gt;getModule()-&gt;getFullPath()
       &lt;&lt; " on its gate " &lt;&lt; path-&gt;getRemoteGate()-&gt;getFullName() &lt;&lt; endl;
    node = path-&gt;getRemoteNode();
  }
}
</pre>
<p>

<p>The purpose of the <tt>getDistanceToTarget()</tt> member function of a
node is self-explanatory. In the unweighted case, it returns the
number of hops. The <tt>getNumPaths()</tt> member function returns the number
of edges which are part of a shortest path, and
<tt>path(i)</tt> returns the <i>i</i>th edge of them as
<tt><a href="../api/classcTopology.html">cTopology</a>::LinkOut</tt>. If the shortest paths were created by the
<tt>...SingleShortestPaths()</tt> function,
<tt>getNumPaths()</tt> will always return 1 (or 0 if the target is not
reachable), that is, only one of the several possible shortest paths
are found.  The
<tt>...MultiShortestPathsTo()</tt> functions
find all paths, at increased run-time cost. The <tt><a href="../api/classcTopology.html">cTopology</a></tt>'s
<tt>getTargetNode()</tt> function returns the target node of the last
shortest path search.

<p>You can enable/disable nodes or edges in the graph. This is done by
calling their <tt>enable()</tt> or <tt>disable()</tt> member functions.
Disabled nodes or edges are ignored by the shortest paths calculation
algorithm. The <tt>isEnabled()</tt> member function returns the state of
a node or edge in the topology graph.

<p>One usage of <tt>disable()</tt> is when you want to determine in how many
hops the target node can be reached from our node <i>through
a particular output gate</i>. To compute this, you compute the
shortest paths to the target <i>from the neighbor node</i> while
disabling the current node to prevent the shortest paths
from going through it:

<pre class="cpp">
<a href="../api/classcTopology.html">cTopology</a>::Node *thisnode = topo.getNodeFor( this );
thisnode-&gt;disable();
topo.calculateUnweightedSingleShortestPathsTo( targetnode );
thisnode-&gt;enable();

for (int j=0; j&lt;thisnode-&gt;getNumOutLinks(); j++)
{
  <a href="../api/classcTopology.html">cTopology</a>::LinkOut *link = thisnode-&gt;getLinkOut(i);
  ev &lt;&lt; "Through gate " &lt;&lt; link-&gt;getLocalGate()-&gt;getFullName() &lt;&lt; " : "
     &lt;&lt; 1 + link-&gt;getRemoteNode()-&gt;getDistanceToTarget() &lt;&lt; " hops" &lt;&lt; endl;
}
</pre>
<p>
In the future, other shortest path algorithms will also be implemented:

<pre class="cpp">
unweightedMultiShortestPathsTo(<a href="../api/classcTopology.html">cTopology</a>::Node *target);
weightedSingleShortestPathsTo(<a href="../api/classcTopology.html">cTopology</a>::Node *target);
weightedMultiShortestPathsTo(<a href="../api/classcTopology.html">cTopology</a>::Node *target);
</pre>
<p>

<p>
<h2><a name="sec283"/>7.7 Pattern Matching</h2>

<p>Since version 4.3, OMNEST contains two utility classes for pattern
matching, <tt><a href="../api/classcPatternMatcher.html">cPatternMatcher</a></tt> and <tt><a href="../api/classcMatchExpression.html">cMatchExpression</a></tt>.

<p><tt><a href="../api/classcPatternMatcher.html">cPatternMatcher</a></tt> is a glob-style pattern matching class, adopted to
special OMNEST requirements. It recognizes wildcards, character ranges and
numeric ranges, and supports options such as case sensitive and whole
string matching. <tt><a href="../api/classcMatchExpression.html">cMatchExpression</a></tt> builds on top of
<tt><a href="../api/classcPatternMatcher.html">cPatternMatcher</a></tt> and extends it in two ways: first, it lets you
combine patterns with AND, OR, NOT into boolean expressions, and second, it
applies the pattern expressions to <i>objects</i> instead of text. These
classes are especially useful for making model-specific configuration files
more concise or more powerful by introducing patterns.

<p>

<p><h3><a name="sec284"/>7.7.1 <a href="../api/classcPatternMatcher.html">cPatternMatcher</a></h3>

<p><tt><a href="../api/classcPatternMatcher.html">cPatternMatcher</a></tt> holds a pattern string and several option flags, and has
a boolean <tt>matches()</tt> function that lets you check whether the string passed as argument
matches the pattern with the given flags. The pattern and the flags can be set
via the constructor or by calling the <tt>setPattern()</tt> member function.

<p>The pattern syntax is a variation on Unix <i>glob</i>-style patterns. The
most apparent differences to globbing rules are the distinction between
<tt>*</tt> and <tt>**</tt>, and that character ranges should be written with
curly braces instead of square brackets; that is, <i>any-letter</i> is
expressed as <tt>{a-zA-Z}</tt> and not as <tt>[a-zA-Z]</tt>, because square
brackets are reserved for the notation of module vector indices.

<p>The following option flags are supported:

<p><ul>
  <li> <i>dottedpath</i>: controls whether some wildcards (<tt>?</tt>, <tt>*</tt>) will match dots
  <li> <i>fullstring</i>: controls whether to do full string or substring match.
  <li> <i>casesensitive</i>: whether matching is case sensitive or case insensitive
</ul>

<p>Patterns may contain the following elements:

<p><ul>
  <li> <i>question mark</i>, <tt>?</tt> : matches any character (except dot if <i>dottedpath</i>=true)
  <li> <i>asterisk</i>, <tt>*</tt> : matches zero or more characters (except dots if <i>dottedpath</i>=true)
  <li> <i>double asterisk</i>, <tt>**</tt> : matches zero or more characters, including dots
  <li> <i>set</i>, e.g. <tt>{a-zA-Z}</tt> : matches any character that is contained in the set
  <li> <i>negated set</i>, e.g. <tt>{^a-z}</tt>: matches any character that is NOT contained in the set
  <li> <i>numeric range</i>, e.g. <tt>{38..150}</tt> : matches any number (i.e. sequence of digits) in the given range
  <li> <i>numeric index range</i>, e.g. <tt>[38..150]</tt> : matches any number in square brackets in the given range
  <li> <i>backslash</i>, \ : takes away the special meaning of the subsequent character
</ul>

<p><ul class="note"><b>NOTE</b><br>
The <i>dottedpath</i> option was introduced to make matching OMNEST
module paths more powerful. When it is off (<i>dottedpath</i>=false),
there is no difference between <tt>*</tt> and <tt>**</tt>, they both match any
character sequence. However, when matching OMNEST module paths or other
strings where dot is a separator character, it is useful to turn on the
dottedpath mode (<i>dottedpath</i>=true). In that mode, <tt>*</tt>, not
being able to cross a dot, can match only a single path component (or part
of it), and <tt>**</tt> can match multiple path components.
</ul>

<p>Sets and negated sets can contain several character ranges and also
enumeration of characters, for example <tt>{_a-zA-Z0-9}</tt> or
<tt>{xyzc-f}</tt>. To include a hyphen in the set, place it at a position
where it cannot be interpreted as character range, for example
<tt>{a-z-}</tt> or <tt>{-a-z}</tt>. If you want to include a close brace in
the set, it must be the first character: <tt>{}a-z}</tt>, or for a negated
set: <tt>{^}a-z}</tt>. A backslash is always taken as
literal backslash (and NOT as escape character) within set definitions.
When doing case-insensitive match, avoid ranges that include both alpha and
non-alpha characters, because they might cause funny results.

<p>For numeric ranges and numeric index ranges, ranges are inclusive, and both
the start and the end of the range are optional; that is, <tt>{10..}</tt>,
<tt>{..99}</tt> and <tt>{..}</tt> are all valid numeric ranges (the last one
matches any number). Only nonnegative integers can be matched. Caveat:
<tt>{17..19}</tt> will match <tt>"a17"</tt>, <tt>"117"</tt> and also <tt>"963217"</tt>!

<p>The <tt><a href="../api/classcPatternMatcher.html">cPatternMatcher</a></tt> constructor and the <tt>setPattern()</tt> member
function have similar signatures:

<pre class="cpp">
<a href="../api/classcPatternMatcher.html">cPatternMatcher</a>(const char *pattern, bool dottedpath, bool fullstring,
                bool casesensitive);
void setPattern(const char *pattern, bool dottedpath, bool fullstring,
                bool casesensitive);
</pre>
<p>
The matcher function:

<pre class="cpp">
bool matches(const char *text);
</pre>
<p>
There are also some more utility functions for printing the pattern,
determining whether a pattern contains wildcards, etc.

<p>Example:

<pre class="cpp">
<a href="../api/classcPatternMatcher.html">cPatternMatcher</a> matcher("**.host[*]", true, true, true);
ev &lt;&lt; matcher.matches("Net.host[0]") &lt;&lt; endl;  // -&gt; true
ev &lt;&lt; matcher.matches("Net.area1.host[0]") &lt;&lt; endl;  // -&gt; true
ev &lt;&lt; matcher.matches("Net.host") &lt;&lt; endl;  // -&gt; false
ev &lt;&lt; matcher.matches("Net.host[0].tcp") &lt;&lt; endl;  // -&gt; false
</pre>
<p>

<p><h3><a name="sec285"/>7.7.2 <a href="../api/classcMatchExpression.html">cMatchExpression</a></h3>

<p>The <tt><a href="../api/classcMatchExpression.html">cMatchExpression</a></tt> class builds on top of <tt><a href="../api/classcPatternMatcher.html">cPatternMatcher</a></tt>,
and lets you determine whether an <i>object</i> matches a given pattern
expression.

<p>A pattern expression consists of elements in the
<i>fieldname(pattern)</i> syntax; they check whether the string
representation of the given field of the object matches the pattern. For
example, <tt>srcAddr(192.168.0.*)</tt> will match if the <i>srcAddr</i>
field of the object starts with <tt>192.168.0.</tt> A naked pattern (without
field name and parens) is also accepted, and it will be matched against the
<i>default field</i> of the object, which will usually be its name.

<p>These elements can be combined with the AND, OR, NOT operators, accepted in
both lowercase and uppercase. AND has higher precedence than OR, but
parentheses can be used to change the evaluation order.

<p>Pattern examples:

<p><ul>
 <li> <tt>"node*"</tt>
 <li> <tt>"node* or host*"</tt>
 <li> <tt>"packet-* and className(PPPFrame)"</tt>
 <li> <tt>"className(TCPSegment) and byteLength({4096..})"</tt>
 <li> <tt>"className(TCPSegment) and (SYN or DATA-*) and not kind({0..2})"</tt>
</ul>

<p>The <tt><a href="../api/classcMatchExpression.html">cMatchExpression</a></tt> class has a constructor and <tt>setPattern()</tt>
method similar to those of <tt><a href="../api/classcPatternMatcher.html">cPatternMatcher</a></tt>:

<pre class="cpp">
<a href="../api/classcMatchExpression.html">cMatchExpression</a>(const char *pattern, bool dottedpath, bool fullstring,
                bool casesensitive);
void setPattern(const char *pattern, bool dottedpath, bool fullstring,
                bool casesensitive);
</pre>
<p>
However, the matcher function takes a <tt><a href="../api/classcMatchExpression.html">cMatchExpression</a>::Matchable</tt>
instead of string:

<pre class="cpp">
bool matches(const Matchable *object);
</pre>
<p>
This means that objects to be matched must either be subclassed from
<tt><a href="../api/classcMatchExpression.html">cMatchExpression</a>::Matchable</tt>, or be wrapped into some adapter class
that does. <tt><a href="../api/classcMatchExpression.html">cMatchExpression</a>::Matchable</tt> is a small abstract class
with only a few pure virtual functions:

<pre class="cpp">
/**
 * Objects to be matched must implement this interface
 */
class SIM_API Matchable
{
  public:
    /**
     * Return the default string to match. The returned pointer will not be
     * cached by the caller, so it is OK to return a pointer to a static buffer.
     */
    virtual const char *getAsString() const = 0;

    /**
     * Return the string value of the given attribute, or NULL if the object
     * doesn't have an attribute with that name. The returned pointer will not
     * be cached by the caller, so it is OK to return a pointer to a static buffer.
     */
    virtual const char *getAsString(const char *attribute) const = 0;

    /**
     * Virtual destructor.
     */
    virtual ~Matchable() {}
};
</pre>
<p>
To be able to match instances of an existing class that is not already a
<tt>Matchable</tt>, you need to write an adapter class. An adapter class that
we can look at as an example is <tt><a href="../api/classcMatchableString.html">cMatchableString</a></tt>. <tt><a href="../api/classcMatchableString.html">cMatchableString</a></tt>
makes it possible to match strings with a <tt><a href="../api/classcMatchExpression.html">cMatchExpression</a></tt>, and is part
of OMNEST:

<pre class="cpp">
/**
 * Wrapper to make a string matchable with <a href="../api/classcMatchExpression.html">cMatchExpression</a>.
 */
class <a href="../api/classcMatchableString.html">cMatchableString</a> : public <a href="../api/classcMatchExpression.html">cMatchExpression</a>::Matchable
{
  private:
    std::string str;
  public:
    <a href="../api/classcMatchableString.html">cMatchableString</a>(const char *s) {str = s;}
    virtual const char *getAsString() const {return str.c_str();}
    virtual const char *getAsString(const char *name) const {return NULL;}
};
</pre>
<p>
An example:

<pre class="cpp">
<a href="../api/classcMatchExpression.html">cMatchExpression</a> expr("foo* or bar*", true, true, true);
<a href="../api/classcMatchableString.html">cMatchableString</a> str1("this is a foo");
<a href="../api/classcMatchableString.html">cMatchableString</a> str2("something else");
ev &lt;&lt; expr.matches(&str1) &lt;&lt; endl; // -&gt; true
ev &lt;&lt; expr.matches(&str2) &lt;&lt; endl; // -&gt; false
</pre>
<p>
Or, by using temporaries:

<pre class="cpp">
ev &lt;&lt; expr.matches(&<a href="../api/classcMatchableString.html">cMatchableString</a>("this is a foo")) &lt;&lt; endl; // -&gt; true
ev &lt;&lt; expr.matches(&<a href="../api/classcMatchableString.html">cMatchableString</a>("something else")) &lt;&lt; endl; // -&gt; false
</pre>
<p>

<p>
<h2><a name="sec286"/>7.8 Statistics and Distribution Estimation</h2>
<a name="sec:ch-sim-lib:statistics"></a>

<p><h3><a name="sec287"/>7.8.1 <a href="../api/classcStatistic.html">cStatistic</a> and Descendants</h3>

<p>There are several statistic and result collection classes:
<tt><a href="../api/classcStdDev.html">cStdDev</a></tt>, <tt><a href="../api/classcWeightedStdDev.html">cWeightedStdDev</a></tt>, <tt>LongHistogram</tt>,
<tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>, <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>, <tt><a href="../api/classcPSquare.html">cPSquare</a></tt> and
<tt><a href="../api/classcKSplit.html">cKSplit</a></tt>. They are all derived from the abstract base class
<tt><a href="../api/classcStatistic.html">cStatistic</a></tt>.

<p><ul>
  <li><tt><a href="../api/classcStdDev.html">cStdDev</a></tt> keeps the count, mean, standard
    deviation, minimum and maximum value etc of the observations.
  <li><tt><a href="../api/classcWeightedStdDev.html">cWeightedStdDev</a></tt> is similar to <tt><a href="../api/classcStdDev.html">cStdDev</a></tt>, but
    accepts weighted observations. <tt><a href="../api/classcWeightedStdDev.html">cWeightedStdDev</a></tt> can be used
    for example to calculate time average. It is the only weighted
    statistics class.
  <li><tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt> and <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt> are
    descendants of <tt><a href="../api/classcStdDev.html">cStdDev</a></tt> and also keep an approximation of
    the distribution of the observations using equidistant
    (equal-sized) cell histograms<!--histogram!equal-sized-->.
  <li><tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt> implements a histogram where cells do not
    need to be the same size. You can manually add the cell (bin)
    boundaries, or alternatively, automatically have a partitioning
    created where each bin has the same number of observations (or as
    close to that as possible).
  <li><tt><a href="../api/classcPSquare.html">cPSquare</a></tt> is a class that uses the <i>P<sup>2</sup></i> algorithm
    described in [<a href="#bib-JCh85">JCh85</a>]. The algorithm calculates quantiles without
    storing the observations; one can also think of it as a histogram
    with equiprobable cells<!--histogram!equiprobable-cells-->.
  <li><tt><a href="../api/classcKSplit.html">cKSplit</a></tt> uses a novel, experimental method, based on an
    adaptive histogram-like algorithm.
</ul>

<p><p class="subheading">Basic Usage</p>

<p>One can insert an observation into a statistic object with the
<tt>collect()</tt> function or the <tt>+=</tt> operator (they are
equivalent).  <tt><a href="../api/classcStdDev.html">cStdDev</a></tt> has the following methods for getting
statistics from the object: <tt>getCount()</tt>, <tt>getMin()</tt>,
<tt>getMax()</tt>, <tt>getMean()</tt>, <tt>getStddev()</tt>, <tt>getVariance()</tt>,
<tt>getSum()</tt>, <tt>getSqrSum()</tt> with the obvious meanings. An example
usage for <tt><a href="../api/classcStdDev.html">cStdDev</a></tt>:

<pre class="cpp">
<a href="../api/classcStdDev.html">cStdDev</a> stat("stat");

for (int i=0; i&lt;10; i++)
  stat.collect( normal(0,1) );

long numSamples = stat.getCount();
double smallest = stat.getMin(),
       largest = stat.getMax();
double mean = stat.getMean(),
       standardDeviation = stat.getStddev(),
       variance = stat.getVariance();
</pre>
<p>

<p>

<p>
<h3><a name="sec288"/>7.8.2 Distribution Estimation</h3>

<p><p class="subheading">Initialization and Usage</p>

<p>
The distribution estimation<!--distribution!estimation--> classes
(<tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt>, <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>, <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>,
<tt><a href="../api/classcPSquare.html">cPSquare</a></tt> and <tt><a href="../api/classcKSplit.html">cKSplit</a></tt>) are derived from
<tt><a href="../api/classcDensityEstBase.html">cDensityEstBase</a></tt>. Distribution estimation classes (except for
<tt><a href="../api/classcPSquare.html">cPSquare</a></tt>) assume that the observations are within a range.
You may specify the range explicitly (based on some a-priori info
about the distribution), or you may let the object collect the first
few observations and determine the range from them.

<p>The following member functions exist for setting up the range
and to specify how many observations should be used for automatically
determining the range (these methods are part of <tt><a href="../api/classcDensityEstBase.html">cDensityEstBase</a></tt>):

<pre class="cpp">
setRange(lower,upper);
setRangeAuto(numFirstvals, rangeExtFactor);
setRangeAutoLower(upper, numFirstvals, rangeExtFactor);
setRangeAutoUpper(lower, numFirstvals, rangeExtFactor);
</pre>
<p>
<pre class="cpp">
setNumFirstVals(numFirstvals);
</pre>

<p>The following example creates a histogram with 20 cells and automatic
range estimation<!--histogram!range estimation-->:

<pre class="cpp">
<a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a> histogram("histogram", 20);
histogram.setRangeAuto(100,1.5);
</pre>
<p>

<p>Here, 20 is the number of cells (not including the underflow/overflow
cells, see later), and 100 is the number of observations to be
collected before setting up the cells. 1.5 is the range extension
factor. It means that the actual range of the initial observations
will be expanded 1.5 times and this expanded range will be used to lay
out the cells. This method increases the chance that further
observations fall in one of the cells and not outside the histogram
range.

<p>
  <center>
    <img src="simlib-histogramrange.png">
    <center><i>Figure: Setting up a histogram's range</i></center>
  </center>

<p>
The <tt>isTransformed()</tt> function returns <i>true</i> when the cells have
already been set up. You can force range estimation and setting
up the cells by calling the <tt>transform()</tt> function.

<p>The observations that fall outside the histogram range will be counted
as underflows and overflows. The number of underflows and overflows
are returned by the <tt>getUnderflowCell()</tt> and <tt>getOverflowCell()</tt>
member functions.

<p>
<center>
  <img src="simlib-histogramsetup.png">
  <center><i>Figure: Histogram structure after setting up the cells</i></center>
</center>

<p>
You create a <i>P<sup>2</sup></i> object by specifying the number of cells:

<pre class="cpp">
<a href="../api/classcPSquare.html">cPSquare</a> psquare("interarrival-times", 20);
</pre>
<p>
Afterwards, a <tt><a href="../api/classcPSquare.html">cPSquare</a></tt> can be used with the same member functions
as a histogram.

<p>
<p class="subheading">Getting Histogram Data</p>

<p>
There are three member functions to explicitly return cell boundaries
and the number of observations in each cell. <tt>getNumCells()</tt> returns
the number of cells, <tt>getBasepoint(int k)</tt> returns the
<i>k</i>th base point, <tt>getCellValue(int k)</tt> returns the
number of observations in cell <i>k</i>, and
<tt>getCellPDF(int k)</tt> returns the PDF value in the cell
(i.e. between <tt>getBasepoint(k)</tt> and
<tt>getBasepoint(k+1)</tt>).
The <tt>getCellInfo(k)</tt> method returns multiple data
(cell bounds, counter, relative frequency) packed together in a struct.
These functions work for all histogram types, plus <tt><a href="../api/classcPSquare.html">cPSquare</a></tt>
and <tt><a href="../api/classcKSplit.html">cKSplit</a></tt>.

<p>
  <center>
    <img src="simlib-histogramcells.png">
    <center><i>Figure: base points and cells</i></center>
  </center>

<p>
An example:

<pre class="cpp">
long n = histogram.getCount();
for (int i=0; i&lt;histogram.getNumCells(); i++)
{
  double cellWidth = histogram.getBasepoint(i+1)-histogram.getBasepoint(i);
  int count = histogram.getCellValue(i);
  double pdf = histogram.getCellPDF(i);
  //...
}
</pre>
<p>

<p>The <tt>getPDF(x)</tt> and <tt>getCDF(x)</tt> member functions
return the value of the Probability Density Function and the Cumulated
Density Function at a given <i>x</i>, respectively.

<p>
<p class="subheading">Random Number Generation from Distributions</p>

<p>
The <tt>random()</tt> member function generates random
numbers<!--random!numbers--> from the distribution stored by the
object:

<pre class="cpp">
double rnd = histogram.random();
</pre>
<p>

<p><tt><a href="../api/classcStdDev.html">cStdDev</a></tt> assumes normal distribution.

<p>The <tt><a href="../api/classcPar.html">cPar</a></tt> object stores the pointer to the histogram (or <i>P<sup>2</sup></i> object),
and whenever it is asked for the value, calls the histogram object's <tt>random()</tt>
function:

<pre class="cpp">
double rnd = (double)rndPar; // random number from the <a href="../api/classcPSquare.html">cPSquare</a>
</pre>
<p>
<p class="subheading">Storing and Loading Distributions</p>

<p>
The statistic classes have <tt>loadFromFile()</tt> member functions
that read the histogram data from a text file. If you need a custom
distribution<!--distribution!custom--> that cannot be written (or it
is inefficient) as a C function, you can describe it in histogram form
stored in a text file, and use a histogram object with
<tt>loadFromFile()</tt>.

<p>You can also use <tt>saveToFile()</tt>that writes out the distribution
collected by the histogram object:

<pre class="cpp">
FILE *f = fopen("histogram.dat","w");
histogram.saveToFile(f); // save the distribution
fclose(f);

<a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a> hist2("Hist-from-file");
FILE *f2 = fopen("histogram.dat","r");
hist2.loadFromFile(f2); // load stored distribution
fclose(f2);
</pre>
<p>

<p><p class="subheading">Histogram with Custom Cells</p>

<p>
The <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt> class can be used to create
histograms with arbitrary (non-equidistant) cells.
It can operate in two modes:

<p><ul>
  <li> <i>manual</i>, where you specify cell boundaries explicitly
     before starting collecting
  <li> <i>automatic</i>, where <tt>transform()</tt> will set up the cells
     after collecting a certain number of initial observations. The cells
     will be set up so that as far as possible, an equal number of observations
     fall into each cell (equi-probable cells).
</ul>

<p>Modes are selected with a <i>transform-type</i> parameter:
<ul>
  <li><tt>HIST_TR_NO_TRANSFORM</tt>: no transformation; uses bin boundaries
    previously defined by <tt>addBinBound()</tt>
  <li><tt>HIST_TR_AUTO_EPC_DBL</tt>: automatically creates equiprobable cells
  <li><tt>HIST_TR_AUTO_EPC_INT</tt>: like the above, but for integers
</ul>

<p>Creating an object:

<pre class="cpp">
<a href="../api/classcVarHistogram.html">cVarHistogram</a>(const char *s=NULL,
              int numcells=11,
              int transformtype=HIST_TR_AUTO_EPC_DBL);
</pre>
<p>
Manually adding a cell boundary:

<pre class="cpp">
void addBinBound(double x);
</pre>
<p>
Rangemin and rangemax is chosen after collecting the
<tt>numFirstVals</tt> initial observations. One cannot add cell
boundaries when the histogram has already been transformed.

<p>

<p>

<p><h3><a name="sec289"/>7.8.3 The k-split Algorithm</h3>

<p><p class="subheading">Purpose</p>

<p>
The <i>k</i>-split algorithm is an on-line distribution
estimation<!--distribution!online estimation--> method.  It was
designed for on-line result collection in simulation programs.  The
method was proposed by Varga and Fakhamzadeh in 1997. The primary
advantage of <i>k</i>-split is that without having to store the
observations, it gives a good estimate without requiring a-priori
information about the distribution, including the sample size. The
<i>k</i>-split algorithm can be extended to multi-dimensional
distributions<!--distribution!multi-dimensional-->, but here we deal
with the one-dimensional version only.

<p>
<p class="subheading">The Algorithm</p>

<p>
The <i>k-split</i> algorithm is an adaptive histogram-type estimate which
maintains a good partitioning by doing cell splits. We start out with
a histogram range <i>[x<sub>lo</sub>, x<sub>hi</sub>)</i> with <i>k</i> equal-sized histogram
cells with observation counts <i>n<sub>1</sub>,n<sub>2</sub>, .. n<sub>k</sub></i>.  Each collected
observation increments the corresponding observation count. When an
observation count <i>n<sub>i</sub></i> reaches a <i>split threshold</i>, the cell
is split into <i>k</i> smaller, equal-sized cells with observation counts
<i>n<sub>i,1</sub>, n<sub>i,2</sub>, .. n<sub>i,k</sub></i> initialized to zero. The <i>n<sub>i</sub></i>
observation count is remembered and is called the <i>mother
  observation count</i> to the newly created cells. Further observations
may cause cells to be split further (e.g. <i>n<sub>i,1,1</sub>,...n<sub>i,1,k</sub></i>
etc.), thus creating a <i>k</i>-order tree of observation counts where
leaves contain live counters that are actually incremented by new
observations, and intermediate nodes contain mother observation counts
for their children. If an observation falls outside the histogram
range, the range is extended in a natural manner by inserting new
level(s) at the top of the tree. The fundamental parameter to the
algorithm is the split factor <i>k</i>. Experience has shown that <i>k=2</i>
works best.

<p>
  <center>
    <img src="simlib-ksplit1.png">
    <center><i>Figure: Illustration of the k-split algorithm, <i>k=2</i>. The
      numbers in boxes represent the observation count values</i></center>
  </center>

<p>

<p>For density estimation, the total number of observations that
fell into each cell of the partition has to be determined. For
this purpose, mother observations in each internal node of the
tree must be distributed among its child cells and propagated
up to the leaves.

<p>
Let <i>n<sub>...,i</sub></i> be the (mother) observation count for a cell,
<i>s<sub>...,i</sub></i> be the total observation count in a cell <i>n<sub>...,i</sub></i> plus
the observation counts in all its sub-, sub-sub-, etc. cells), and
<i>m<sub>...,i</sub></i> the mother observations propagated to the cell. We are
interested in the <i>&ntilde;<sub>...,i</sub> = n<sub>...,i</sub> + m<sub>...,i</sub></i>
estimated amount of observations in the tree nodes, especially in the
leaves. In other words, if we have <i>&ntilde;<sub>...,i</sub></i> estimated
observation amount in a cell, how to divide it to obtain
<i>m<sub>...,i,1</sub>, m<sub>...,i,2</sub> .. m<sub>...,i,k</sub></i>
that can be propagated to child cells. Naturally,
<i>m<sub>...,i,1</sub> + m<sub>...,i,2</sub> + .. + m<sub>...,i,k</sub> = &ntilde;<sub>...,i</sub></i>.

<p>
Two natural distribution methods are even
distribution<!--distribution!even--> (when
<i>m<sub>...,i,1</sub> = m<sub>...,i,2</sub> = .. = m<sub>...,i,k</sub></i>) and proportional
distribution<!--distribution!proportional--> (when
<i>m<sub>...,i,1</sub> : m<sub>...,i,2</sub> : .. : m<sub>...,i,k</sub> = s<sub>...,i,1</sub> : s<sub>...,i,2</sub> : .. : s<sub>...,i,k</sub></i>).
Even distribution is optimal when the
<i>s<sub>...,i,j</sub></i> values are very small, and proportional distribution is
good when the <i>s<sub>...,i,j</sub></i> values are large compared to
<i>m<sub>...,i,j</sub></i>. In practice, a linear combination of them seems
appropriate, where <i>&lambda;=0</i> means even and <i>&lambda;=1</i> means
proportional distribution:

<p>
<i>m<sub>..,i,j</sub> = (1-&lambda;)&ntilde;<sub>..,i</sub>/k + &lambda; &ntilde;<sub>..,i</sub> s<sub>...,i,j</sub> / s<sub>..,i</sub></i>
where <i>&lambda; is in [0,1]</i>

<p>
  <center>
    <img src="simlib-ksplit2.png">
    <center><i>Figure: Density estimation from the k-split cell tree. We
      assume <i>&lambda;=0</i>, i.e. we distribute mother observations
      evenly.</i></center>
  </center>

<p>

Note that while <i>n<sub>...,i</sub></i> are integers, <i>m<sub>...,i</sub></i> and thus
<i>&ntilde;<sub>...,i</sub></i> are typically real numbers. The histogram estimate
calculated from <i>k</i>-split is not exact, because the frequency
counts calculated in the above manner contain a degree of estimation
themselves. This introduces a certain <i>cell division error</i>;
the <i>&lambda;</i> parameter should be selected so that it minimizes that
error. It has been shown that the cell division error can
be reduced to a more-than-acceptable small value.<br>
Strictly speaking, the <i>k</i>-split algorithm is semi-online,
because its needs some observations to set up the initial histogram
range.  Because of the range extension and cell split
capabilities, the algorithm is not very sensitive to the choice of the
initial range, so very few observations are sufficient for range
estimation (say <i>N<sub>pre</sub>=10</i>). Thus we can regard <i>k</i>-split as
an on-line method.

<p><i>K</i>-split can also be used in semi-online mode, when the
algorithm is only used to create an optimal partition from a larger
number of <i>N<sub>pre</sub></i> observations. When the partition has been created,
the observation counts are cleared and the <i>N<sub>pre</sub></i> observations are
fed into <i>k</i>-split once again. This way all mother (non-leaf)
observation counts will be zero and the cell division error is
eliminated. It has been shown that the partition created by
<i>k</i>-split can be better than both the equi-distant and the
equal-frequency partition.

<p>
OMNEST contains an implementation of the <i>k</i>-split algorithm,
the <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> class.

<p><p class="subheading">The <a href="../api/classcKSplit.html">cKSplit</a> Class</p>

<p>The <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> class is an implementation of the <i>k-split</i> method.
Member functions:


<pre class="cpp">
void setCritFunc(KSplitCritFunc critfunc, double *critdata);
void setDivFunc(KSplitDivFunc divfunc, double *divdata);
void rangeExtension( bool enabled );
</pre>
<p>

<pre class="cpp">
int getTreeDepth();
int getTreeDepth(<a href="../api/classcKSplit.html">cKSplit</a>::Grid& grid);
</pre>
<p>
<pre class="cpp">
double getRealCellValue(<a href="../api/classcKSplit.html">cKSplit</a>::Grid& grid, int cell);
void printGrids();
</pre>

<pre class="cpp">
<a href="../api/classcKSplit.html">cKSplit</a>::Grid& getGrid(int k);
<a href="../api/classcKSplit.html">cKSplit</a>::Grid& getRootGrid();
</pre>
<p>
<pre class="cpp">
struct <a href="../api/classcKSplit.html">cKSplit</a>::Grid
{
  int parent;   // index of parent grid
  int reldepth; // depth = (reldepth - rootgrid's reldepth)
  long total;   // sum of cells & all subgrids (includes "mother")
  int mother;   // observations "inherited" from mother cell
  int cells[K]; // cell values
};
</pre>

<p>

<p><h3><a name="sec290"/>7.8.4 Transient Detection and Result Accuracy</h3>

<p>In many simulations, only the steady state performance (i.e.
the performance after the system has reached a stable state)
is of interest. The initial part of the simulation is called
the transient period. After the model has entered steady state,
simulation must proceed until enough statistical data has been
collected to compute a result with the required accuracy.

<p>
Detection of the end of the transient period and a certain result
accuracy is supported by OMNEST. The user can attach transient
detection<!--transient detection--> and result accuracy<!--result
  accuracy--> objects to a result object (<tt><a href="../api/classcStatistic.html">cStatistic</a></tt>'s
descendants). The transient detection and result accuracy objects will
perform the specific algorithms on the data fed into the result object and
determine if the transient period is over or the result accuracy has been
reached.

<p>The base classes for classes implementing specific transient
detection and result accuracy detection algorithms are:
<ul>
<li><tt><a href="../api/classcTransientDetection.html">cTransientDetection</a></tt>: base class for transient detection
<li><tt><a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a></tt>: base class for result accuracy detection
</ul>

<p>
<p class="subheading">Basic Usage</p>


Attaching detection objects to a <tt><a href="../api/classcStatistic.html">cStatistic</a></tt> and getting pointers
to the attached objects:

<pre class="cpp">
addTransientDetection(<a href="../api/classcTransientDetection.html">cTransientDetection</a> *object);
addAccuracyDetection(<a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a> *object);
<a href="../api/classcTransientDetection.html">cTransientDetection</a> *getTransientDetectionObject();
<a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a> *getAccuracyDetectionObject();
</pre>
<p>

<p>Detecting the end of the period:
<ul>
<li>polling the <tt>detect()</tt> function of the object
<li>installing a post-detect function
</ul>

<p>
<p class="subheading">Transient Detection</p>

<p>
Currently one transient detection<!--transient detection--> algorithm
is implemented, i.e.  there is one class derived from
<tt><a href="../api/classcTransientDetection.html">cTransientDetection</a></tt>. The <tt><a href="../api/classcTDExpandingWindows.html">cTDExpandingWindows</a></tt> class
uses the sliding window approach with two windows, and checks the
difference of the two averages to see if the transient period is over.

<pre class="cpp">
void setParameters(int reps=3,
                   int minw=4,
                   double wind=1.3,
                   double acc=0.3);
</pre>
<p>
<p class="subheading">Accuracy Detection</p>

<p>
Currently one accuracy detection<!--accuracy detection--> algorithm
is implemented, i.e.  there is one class derived from
<tt><a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a></tt>. The algorithm implemented in the
<tt><a href="../api/classcADByStddev.html">cADByStddev</a></tt> class is: divide the standard deviation by the
square of the number of values and check if this is small enough.

<pre class="cpp">
void setParameters(double acc=0.1, int reps=3);
</pre>
<p>

<p>

<p><h2><a name="sec291"/>7.9 Recording Simulation Results</h2>
<a name="sec:ch-sim-lib:result-recording"></a>

<p><h3><a name="sec292"/>7.9.1 Output Vectors: <a href="../api/classcOutVector.html">cOutVector</a></h3>
<a name="sec:ch-sim-lib:coutvector"></a>

<p>Objects of type <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> are responsible for writing time series
data (referred to as <i>output vectors</i>) to a file. The <tt>record()</tt>
method is used to output a value (or a value pair) with a timestamp.
The object name will serve as the name of the output vector.

<p>The vector name can be passed in the constructor,

<pre class="cpp">
<a href="../api/classcOutVector.html">cOutVector</a> responseTimeVec("response time");
</pre>
<p>
but in the usual arrangement you'd make the <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> a member
of the module class and set the name in <tt>initialize()</tt>. You'd
record values from <tt>handleMessage()</tt> or from a function called from
<tt>handleMessage()</tt>.

<p>The following example is a <tt>Sink</tt> module which records the lifetime
of every message that arrives to it.

<pre class="cpp">
class Sink : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    <a href="../api/classcOutVector.html">cOutVector</a> endToEndDelayVec;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(Sink);

void Sink::initialize()
{
    endToEndDelayVec.setName("End-to-End Delay");
}

void Sink::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    simtime_t eed = simTime() - msg-&gt;getCreationTime();
    endToEndDelayVec.record(eed);
    delete msg;
}
</pre>
<p>
There is also a <tt>recordWithTimestamp()</tt> method, to make it
possible to record values into output vectors with a timestamp other than
<tt>simTime()</tt>. Increasing timestamp order is still enforced though.

<p>All <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects write to a single <i>output vector file</i>
that has a file extension <tt>.vec</tt>.
  <br><ul><font size=-1>[A <tt>.vci</tt> file is also created, but it is just an index for
  the <tt>.vec</tt> file and does not contain any new information. The IDE
  re-creates the <tt>.vci</tt> file if it gets lost.]</font></ul>
The format and processing of output vector files is described in section
<a href="#sec401">[12]</a>.

<p>You can configure output vectors from <tt>omnetpp.ini</tt>:
you can disable individual vectors, or limit recording to certain
simulation time intervals (section <a href="#sec410">[12.2.5]</a>).

<p>If the output vector object is disabled or the simulation time is
outside the specified interval, <tt>record()</tt> doesn't write
anything to the output file. However, if you have a Tkenv inspector
window open for the output vector object<!--output!vector object-->,
the values will be displayed there, regardless of the state of the
output vector object.

<p>

<p><h3><a name="sec293"/>7.9.2 Output Scalars</h3>

<p>While output vectors are to record time series data and thus they
typically record a large volume of data during a simulation run,
output scalars<!--output!scalars--> are supposed to record a single
value per simulation run. You can use output scalars

<p><ul>
<li>to record summary data at the end of the simulation run
<li>to do several runs with different parameter settings/random seed
    and determine the dependence of some measures on the parameter
    settings. For example, multiple runs and output scalars are the
    way to produce <i>Throughput vs. Offered Load</i> plots.
</ul>

<p>Output scalars are recorded with the <tt>record()</tt> method of
<tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, and you will usually want to insert this code
into the <tt>finish()</tt> function. An example:

<pre class="cpp">
void Transmitter::finish()
{
    double avgThroughput = totalBits / simTime();
    recordScalar("Average throughput", avgThroughput);
}
</pre>
<p>
You can record whole statistic objects by calling their <tt>record()</tt>
methods, declared as part of <tt><a href="../api/classcStatistic.html">cStatistic</a></tt>. In the following example
we create a <tt>Sink</tt> module which calculates the mean, standard
deviation, minimum and maximum values of a variable, and records them at the
end of the simulation.

<pre class="cpp">
class Sink : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    <a href="../api/classcStdDev.html">cStdDev</a> eedStats;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
    virtual void finish();
};

Define_Module(Sink);

void Sink::initialize()
{
    eedStats.setName("End-to-End Delay");
}

void Sink::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    simtime_t eed = simTime() - msg-&gt;getCreationTime();
    eedStats.collect(eed);
    delete msg;
}

void Sink::finish()
{
    recordScalar("Simulation duration", simTime());
    eedStats.record();
}
</pre>
<p>
The above calls record the data into an <i>output scalar file</i>,
a line-oriented text file that has the file extension <tt>.sca</tt>.
The format and processing of output vector files is described in chapter
<a href="#sec401">[12]</a>.

<p>

<p><h2><a name="sec294"/>7.10 Watches and Snapshots</h2>

<p><h3><a name="sec295"/>7.10.1 Basic Watches</h3>

<p>Unfortunately, variables of type <tt>int</tt>, <tt>long</tt>, <tt>double</tt>
do not show up by default in Tkenv; neither do STL classes
(<tt>std::string</tt>, <tt>std::vector</tt>, etc.) or your own structs and
classes. This is because the simulation kernel, being a library, knows
nothing about types and variables in your source code.

<p>OMNEST provides <tt>WATCH()</tt> and a set of other macros to
allow variables to be inspectable in Tkenv and to be output into the snapshot
file<!--snapshot file-->. <tt>WATCH()</tt> macros are usually placed into
<tt>initialize()</tt> (to watch instance variables) or to the top of the
<tt>activity()</tt> function (to watch its local variables); the point being
that they should only be executed once.

<pre class="cpp">
long packetsSent;
double idleTime;

WATCH(packetsSent);
WATCH(idleTime);
</pre>
<p>
Of course, members of classes and structs can also be watched:

<pre class="cpp">
WATCH(config.maxRetries);
</pre>
<p>
When you open an inspector for the simple module in Tkenv and click
the Objects/Watches tab in it, you will see your watched variables
and their values there. Tkenv also lets you change the value of a
watched variable.

<p>The <tt>WATCH()</tt> macro can be used with any type that has a
stream output operator (<tt>operator&lt;&lt;</tt>) defined. By default,
this includes all primitive types and <tt>std::string</tt>, but since
you can write <tt>operator&lt;&lt;</tt> for your classes/structs and basically
any type, <tt>WATCH()</tt> can be used with anything. The only limitation
is that since the output should more or less fit on single line, the
amount of information that can be conveniently displayed is limited.

<p>An example stream output operator:

<pre class="cpp">
std::ostream& operator&lt;&lt;(std::ostream& os, const ClientInfo& cli)
{
    os &lt;&lt; "addr=" &lt;&lt; cli.clientAddr &lt;&lt; "  port=" &lt;&lt; cli.clientPort; // no endl!
    return os;
}
</pre>
<p>
And the <tt>WATCH()</tt> line:

<pre class="cpp">
WATCH(currentClientInfo);
</pre>
<p>

<p><h3><a name="sec296"/>7.10.2 Read-write Watches</h3>

<p>Watches for primitive types and <tt>std::string</tt> allow for changing
the value from the GUI as well, but for other types you need to explicitly
add support for that. What you need to do is define a stream input
operator (<tt>operator&gt;&gt;</tt>) and use the <tt>WATCH_RW()</tt> macro instead of
<tt>WATCH()</tt>.

<p>The stream input operator:

<pre class="cpp">
std::ostream& operator&gt;&gt;(std::istream& is, ClientInfo& cli)
{
    // read a line from "is" and parse its contents into "cli"
    return is;
}
</pre>
<p>
And the <tt>WATCH_RW()</tt> line:

<pre class="cpp">
WATCH_RW(currentClientInfo);
</pre>
<p>

<p><h3><a name="sec297"/>7.10.3 Structured Watches</h3>

<p><tt>WATCH()</tt> and <tt>WATCH_RW()</tt> are basic watches; they allow one
line of (unstructured) text to be displayed. However, if you have a
data structure generated from message definitions (see Chapter <a href="#sec202">[5]</a>),
then there is a better approach. The message compiler automatically generates
meta-information describing individual fields of the class or struct,
which makes it possible to display the contents on field level.

<p>The <tt>WATCH</tt> macros to be used for this purpose are <tt>WATCH_OBJ()</tt>
and <tt>WATCH_PTR()</tt>. Both expect the object to be subclassed from
<tt><a href="../api/classcObject.html">cObject</a></tt>; <tt>WATCH_OBJ()</tt> expects a reference to such class,
and <tt>WATCH_PTR()</tt> expects a pointer variable.

<pre class="cpp">
ExtensionHeader hdr;
ExtensionHeader *hdrPtr;
...
WATCH_OBJ(hdr);
WATCH_PTR(hdrPtr);
</pre>
<p>
CAUTION: With <tt>WATCH_PTR()</tt>, the pointer variable must point to a valid
object or be <tt>NULL</tt> at all times, otherwise the GUI may crash
while trying to display the object. This practically means that
the pointer should be initialized to <tt>NULL</tt> even if not used, and
should be set to <tt>NULL</tt> when the object to which it points is deleted.

<pre class="cpp">
delete watchedPtr;
watchedPtr = NULL;  // set to NULL when object gets deleted
</pre>
<p>

<p><h3><a name="sec298"/>7.10.4 STL Watches</h3>

<p>The standard C++ container classes (<tt>vector</tt>, <tt>map</tt>, <tt>set</tt>, etc)
also have structured watches, available via the following macros:

<p><tt>WATCH_VECTOR()</tt>, <tt>WATCH_PTRVECTOR()</tt>,
<tt>WATCH_LIST()</tt>, <tt>WATCH_PTRLIST()</tt>,
<tt>WATCH_SET()</tt>, <tt>WATCH_PTRSET()</tt>,
<tt>WATCH_MAP()</tt>, <tt>WATCH_PTRMAP()</tt>.

<p>The <tt>PTR</tt>-less versions expect the data items ("T") to have
stream output operators (<tt>operator &lt;&lt;</tt>), because that is how
they will display them. The <tt>PTR</tt> versions assume that
data items are pointers to some type which has <tt>operator &lt;&lt;</tt>.
<tt>WATCH_PTRMAP()</tt> assumes that only the value type (&#8220;second&#8221;)
is a pointer, the key type (&#8220;first&#8221;) is not. (If you happen to use
pointers as key, then define <tt>operator &lt;&lt;</tt> for the pointer type
itself.)

<p>Examples:

<pre class="cpp">
std::vector&lt;int&gt; intvec;
WATCH_VECTOR(intvec);

std::map&lt;std::string,Command*&gt; commandMap;
WATCH_PTRMAP(commandMap);
</pre>
<p>

<p>
<h3><a name="sec299"/>7.10.5 Snapshots</h3>
<a name="sec:ch-sim-lib:snapshots"></a>

<p>The <tt>snapshot()</tt> function outputs textual information about all
or selected objects of the simulation (including the objects created
in module functions by the user) into the snapshot file<!--snapshot file-->.

<pre class="cpp">
bool snapshot(<a href="../api/classcObject.html">cObject</a> *obj = &simulation, const char *label = NULL);
</pre>
<p>
The function can be called from module functions, like this:

<pre class="cpp">
snapshot();     // dump the whole network
snapshot(this); // dump this simple module and all its objects
snapshot(&simulation.msgQueue); // dump future events
</pre>
<p>
This will append snapshot information to the end of the snapshot file.
(The snapshot file name has an extension of <tt>.sna</tt>, default is
<tt>omnetpp.sna</tt><!--omnetpp.sna-->. The actual file name can be set in the
config file.)

<p>The snapshot file output is detailed enough to be used for debugging
the simulation: by regularly calling <tt>snapshot()</tt>, one can trace
how the values of variables, objects changed over the simulation.
The arguments: label is a string that will appear in the output
file; obj is the object whose inside is of interest. By default,
the whole simulation (all modules etc) will be written out.

<p>If you run the simulation with Tkenv, you can also create a snapshot
from the menu.

<p>An example snapshot file (some abbreviations have been applied):

<pre class="filelisting">
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;snapshot object="simulation" label="Long queue" simtime="9.038229311343"
network="FifoNet"&gt;
  &lt;object class="<a href="../api/classcSimulation.html">cSimulation</a>" fullpath="simulation"&gt;
    &lt;info&gt;&lt;/info&gt;
    &lt;object class="<a href="../api/classcModule.html">cModule</a>" fullpath="FifoNet"&gt;
      &lt;info&gt;id=1&lt;/info&gt;
      &lt;object class="fifo::Source" fullpath="FifoNet.gen"&gt;
        &lt;info&gt;id=2&lt;/info&gt;
        &lt;object class="<a href="../api/classcPar.html">cPar</a>" fullpath="FifoNet.gen.sendIaTime"&gt;
          &lt;info&gt;exponential(0.01s)&lt;/info&gt;
          &lt;detailedinfo&gt;double sendIaTime = exponential(0.01s) @unit(s)
          &lt;/detailedinfo&gt;
        &lt;/object&gt;
        &lt;object class="<a href="../api/classcGate.html">cGate</a>" fullpath="FifoNet.gen.out"&gt;
          &lt;info&gt;--&gt; fifo.in&lt;/info&gt;
        &lt;/object&gt;
      &lt;/object&gt;
      &lt;object class="fifo::Fifo" fullpath="FifoNet.fifo"&gt;
        &lt;info&gt;id=3&lt;/info&gt;
        &lt;object class="<a href="../api/classcPar.html">cPar</a>" fullpath="FifoNet.fifo.serviceTime"&gt;
          &lt;info&gt;0.01&lt;/info&gt;
          &lt;detailedinfo&gt;double serviceTime = 0.01@unit(s)&lt;/detailedinfo&gt;
        &lt;/object&gt;
        &lt;object class="<a href="../api/classcGate.html">cGate</a>" fullpath="FifoNet.fifo.in"&gt;
          &lt;info&gt;&lt;-- gen.out&lt;/info&gt;
        &lt;/object&gt;
        &lt;object class="<a href="../api/classcGate.html">cGate</a>" fullpath="FifoNet.fifo.out"&gt;
          &lt;info&gt;--&gt; sink.in&lt;/info&gt;
        &lt;/object&gt;
        &lt;object class="<a href="../api/classcQueue.html">cQueue</a>" fullpath="FifoNet.fifo.queue"&gt;
          &lt;info&gt;length=13&lt;/info&gt;
          &lt;object class="<a href="../api/classcMessage.html">cMessage</a>" fullpath="FifoNet.fifo.queue.job"&gt;
            &lt;info&gt;src=FifoNet.gen (id=2)  dest=FifoNet.fifo (id=3)&lt;/info&gt;
          &lt;/object&gt;
          &lt;object class="<a href="../api/classcMessage.html">cMessage</a>" fullpath="FifoNet.fifo.queue.job"&gt;
            &lt;info&gt;src=FifoNet.gen (id=2)  dest=FifoNet.fifo (id=3)&lt;/info&gt;
          &lt;/object&gt;
        &lt;/object&gt;
      &lt;object class="fifo::Sink" fullpath="FifoNet.sink"&gt;
        &lt;info&gt;id=4&lt;/info&gt;
        &lt;object class="<a href="../api/classcGate.html">cGate</a>" fullpath="FifoNet.sink.in"&gt;
          &lt;info&gt;&lt;-- fifo.out&lt;/info&gt;
        &lt;/object&gt;
      &lt;/object&gt;
    &lt;/object&gt;
    &lt;object class="<a href="../api/classcMessageHeap.html">cMessageHeap</a>" fullpath="simulation.scheduled-events"&gt;
      &lt;info&gt;length=3&lt;/info&gt;
      &lt;object class="<a href="../api/classcMessage.html">cMessage</a>" fullpath="simulation.scheduled-events.job"&gt;
        &lt;info&gt;src=FifoNet.fifo (id=3)  dest=FifoNet.sink (id=4)&lt;/info&gt;
      &lt;/object&gt;
      &lt;object class="<a href="../api/classcMessage.html">cMessage</a>" fullpath="...sendMessageEvent"&gt;
        &lt;info&gt;at T=9.0464.., in dt=0.00817..; selfmsg for FifoNet.gen (id=2)&lt;/info&gt;
      &lt;/object&gt;
      &lt;object class="<a href="../api/classcMessage.html">cMessage</a>" fullpath="...end-service"&gt;
        &lt;info&gt;at T=9.0482.., in dt=0.01; selfmsg for FifoNet.fifo (id=3)&lt;/info&gt;
      &lt;/object&gt;
    &lt;/object&gt;
  &lt;/object&gt;
&lt;/snapshot&gt;

</pre>
<p>

<p>


<p>

<p>
<h3><a name="sec300"/>7.10.6 Getting Coroutine Stack Usage</h3>

<p>It is important to choose the correct stack size for
modules<!--module!stack size--><!--stack!size-->.  If the stack is
too large, it unnecessarily consumes memory; if it is too small, stack
violation occurs.

<p>OMNEST contains a mechanism that detects stack
overflows<!--stack!overflow-->. It checks the intactness of a
predefined byte pattern (<tt>0xdeadbeef</tt>) at the stack boundary,
and reports &#8220;stack violation&#8221;<!--stack!violation--> if it was
overwritten. The mechanism usually works fine, but occasionally it can
be fooled by large -- and not fully used -- local variables (e.g. char
buffer[256]): if the byte pattern happens to fall in the middle of
such a local variable, it may be preserved intact and OMNEST does not
detect the stack violation.

<p>To be able to make a good guess about stack size, you can use
the <tt>getStackUsage()</tt> call which tells you how much stack the module
actually uses. It is most conveniently called from <tt>finish()</tt>:

<pre class="cpp">
void FooModule::finish()
{
  ev &lt;&lt; getStackUsage() &lt;&lt; " bytes of stack used\n";
}
</pre>
<p>

<p>The value includes the extra stack added by the user interface library
(see <i>extraStackforEnvir</i><!--extraStackforEnvir--> in
envir/omnetapp.h), which is currently 8K for Cmdenv and at least 16K
for Tkenv.
  <br><ul><font size=-1>[The actual value is platform-dependent.]</font></ul>

<p><tt>getStackUsage()</tt> also works by checking the existence of predefined
byte patterns in the stack area, so it is also subject to the above
effect with local variables.

<p>
<h2><a name="sec301"/>7.11 Defining New NED Functions</h2>
<a name="sec:ch-sim-lib:defining-ned-functions"></a>

<p>It is possible to extend the NED language with new functions beyond the
built-in ones. New functions are implemented in C++, and then compiled into
the simulation model. When a simulation program starts up, the new
functions are registered in the NED runtime, and become available for use
in NED and ini files.

<p>There are two methods to define NED functions. The
<tt>Define_NED_Function()</tt> macro is the more flexible, preferred method
of the two. <tt>Define_NED_Math_Function()</tt> is the older one, and it
supports only certain cases. Both macros have several variants.
  <br><ul><font size=-1>[Before OMNEST 4.2, <tt>Define_NED_Math_Function()</tt> was
  called <tt>Define_Function()</tt>.]</font></ul>

<p><h3><a name="sec302"/>7.11.1 Define_NED_Function()</h3>

<p>The <tt>Define_NED_Function()</tt> macro lets you define new functions that
can accept arguments of various data types (<tt>bool</tt>, <tt>double</tt>,
<tt>string</tt>, etc.), supports optional arguments and also variable
argument lists (variadic functions).

<p>The macro has two variants:

<pre class="cpp">
Define_NED_Function(FUNCTION,SIGNATURE);
Define_NED_Function2(FUNCTION,SIGNATURE,CATEGORY,DESCRIPTION);
</pre>
<p>
The two variants are basically equivalent; the only difference is that the
second one allows you to specify two more parameters, <tt>CATEGORY</tt> and
<tt>DESCRIPTION</tt>. These two parameters expect human-readable strings that
are displayed when listing the available NED functions.

<p>The common parameters, <tt>FUNCTION</tt> and <tt>SIGNATURE</tt> are the important
ones. <tt>FUNCTION</tt> is the name of (or pointer to) the C++ function that
implements the NED function, and <tt>SIGNATURE</tt> is the function signature
as a string; it defines the name, argument types and return type of the NED
function.

<p>You can list the available NED functions by running <tt>opp_run</tt> or
any simulation executable with the <tt>-h nedfunctions</tt> option.
The result will be similar to what you can see in Appendix
<a href="#sec561">[22]</a>.

<pre class="commandline">
$ opp_run -h nedfunctions
OMNeT++ Discrete Event Simulation...
Functions that can be used in NED expressions and in omnetpp.ini:

 Category "conversion":
  double : double double(any x)
    Converts x to double, and returns the result. A boolean argument becomes
    0 or 1; a string is interpreted as number; an XML argument causes an error.
 ...
</pre>
<p>
Seeing the above output, it should now be obvious what the <tt>CATEGORY</tt>
and <tt>DESCRIPTION</tt> macro arguments are for. OMNEST uses the following
category names: <tt>"conversion"</tt>, <tt>"math"</tt>, <tt>"misc"</tt>,
<tt>"ned"</tt>, <tt>"random/continuous"</tt>, <tt>"random/discrete"</tt>,
<tt>"strings"</tt>, <tt>"units"</tt>, <tt>"xml"</tt>. You can use these category names
for your own functions as well, when appropriate.

<p>
<p class="subheading">The Signature</p>

<p>The signature string has the following syntax:

<p><pre class="verbatim">
<i>returntype functionname(argtype1 argname1, argtype2 argname2, ...)</i>
</pre>

<p>The <i>functionname</i> part defines the name of the NED function, and it
must meet the syntactical requirements for NED identifiers (start with a
letter or underscore, not be a reserved NED keyword, etc.)

<p>The argument types and return type can be one of the following:
<b><tt>bool</tt></b>, <b><tt>int</tt></b> (maps to C/C++ <tt>long</tt>),
<b><tt>double</tt></b>, <b><tt>quantity</tt></b>, <b><tt>string</tt></b>, <b><tt>xml</tt></b>
or <b><tt>any</tt></b>; that is, any NED parameter type plus <b><tt>quantity</tt></b>
and <b><tt>any</tt></b>. <b><tt>quantity</tt></b> means <i>double with an
optional measurement unit</i> (<b><tt>double</tt></b> and <b><tt>int</tt></b> only
accept dimensionless numbers), and <b><tt>any</tt></b> stands for any type. The
argument names are presently ignored.

<p>To make arguments optional, append a question mark to the argument name.
Like in C++, optional arguments may only occur at the end of the argument
list, i.e. all arguments after an optional argument must also be optional.
The signature string does not have syntax for supplying default values for
optional arguments; that is, default values have to be built into the C++
code that implements the NED function. To let the NED function accept any
number of additional arguments of arbitrary types, add an ellipsis
(<tt>...</tt>) to the signature as the last argument.

<p>Some examples:

<pre class="cpp">
"int factorial(int n)"
"bool isprime(int n)"
"double sin(double x)"
"string repeat(string what, int times)"
"quantity uniform(quantity a, quantity b, long rng?)"
"any choose(int index, ...)"
</pre>
<p>
The first three examples define NED functions with the names <tt>factorial</tt>,
<tt>isprime</tt> and <tt>sin</tt>, with the obvious meanings. The fourth example
can be the signature for a function that repeats a string <i>n</i> times, and
returns the concatenated result. The fifth example is the signature of the
existing <tt>uniform()</tt> NED function; it accepts numbers both with and without
measurement units (of course, when invoked with measurement units, both <tt>a</tt>
and <tt>b</tt> must have one, and the two must be compatible -- this should be checked
by the C++ implementation). <tt>uniform()</tt> also accepts an optional third argument,
an RNG index. The sixth example can be the signature of a <tt>choose()</tt>
NED function that accepts an integer plus any number of additional arguments
of any type, and returns the <i>index</i>th one among them.

<p><p class="subheading">Implementing the NED Function</p>

<p>The C++ function that implements the NED function must have the following
signature, as defined by the <tt>NEDFunction</tt> typedef:

<pre class="cpp">
<a href="../api/classcNEDValue.html">cNEDValue</a> function(<a href="../api/classcComponent.html">cComponent</a> *context, <a href="../api/classcNEDValue.html">cNEDValue</a> argv[], int argc);
</pre>
<p>
As you can see, the function accepts an array of <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt>
objects, and returns a <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt>; the <i>argc-argv</i> style
argument list should be familiar to you from the declaration of the C/C++
<tt>main()</tt> function. <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> is a class that is used during
the evaluation of NED expressions, and represents a value together with its
type.  The <tt>context</tt> argument contains the module or channel in the
context of which the NED expression is being evaluated; it is useful for
implementing NED functions like <tt>getParentModuleIndex()</tt>.

<p>The function implementation does not need to worry too much about checking
the number and types of the incoming arguments, because the NED expression
evaluator already does that: inside the function you can be sure that the
number and types of arguments correspond to the function signature string.
Thus, <tt>argc</tt> is mostly useful only if you have optional arguments or a
variable argument list. The NED expression evaluator also checks that the
value you return from the function corresponds to the signature.

<p><tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> can store all the needed data types (<tt>bool</tt>,
<tt>double</tt>, <tt>string</tt>, etc.), and is equipped with the functions
necessary to conveniently read and manipulate the stored value. The value can
be read via functions like <tt>boolValue()</tt>, <tt>longValue()</tt>,
<tt>doubleValue()</tt>, <tt>stringValue()</tt> (returns <tt>const char *</tt>),
<tt>stdstringValue()</tt> (returns <tt>const std::string&amp;</tt>) and
<tt>xmlValue()</tt> (returns <tt><a href="../api/classcXMLElement.html">cXMLElement</a>*</tt>), or by simply casting the
object to the desired data type, making use of the provided typecast
operators. Invoking a getter or typecast operator that does not match the
stored data type will result in a runtime error. For setting the stored
value, <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> provides a number of overloaded <tt>set()</tt>
functions, assignment operators and constructors.

<p>Further <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> member functions provide access to the stored
data type; yet other functions are associated with handling quantities,
i.e. doubles with measurement units. There are member functions for getting
and setting the number part and the measurement unit part separately; for
setting the two components together; and for performing unit conversion.

<p>Equipped with the above information, we can already write a simple NED function
that returns the length of a string:

<pre class="cpp">
static <a href="../api/classcNEDValue.html">cNEDValue</a> ned_strlen(<a href="../api/classcComponent.html">cComponent</a> *context, <a href="../api/classcNEDValue.html">cNEDValue</a> argv[], int argc)
{
    return (long)argv[0].stdstringValue().size();
}

Define_NED_Function(ned_strlen, "int length(string s)");
</pre>
<p>
Note that since <tt>Define_NED_Function()</tt> expects the C++ function to
be already declared, we place the function implementation in front of the
<tt>Define_NED_Function()</tt> line. We also declare the function to be
<tt>static</tt>, because its name doesn't need to be visible for the linker.
In the function body, we use <tt>std::string</tt>'s <tt>size()</tt> method to
obtain the length of the string, and cast the result to <tt>long</tt>; the C++
compiler will convert that into a <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> using <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt>'s
<tt>long</tt> constructor. Note that the <b><tt>int</tt></b> keyword in the signature
maps to the C++ type <tt>long</tt>.

<p>The following example defines a <tt>choose()</tt> NED function that returns
its <i>k</i>th argument that follows the <tt>index</tt> (<i>k</i>) argument.

<pre class="cpp">
static <a href="../api/classcNEDValue.html">cNEDValue</a> ned_choose(<a href="../api/classcComponent.html">cComponent</a> *context, <a href="../api/classcNEDValue.html">cNEDValue</a> argv[], int argc)
{
    int index = (int)argv[0];
    if (index &lt; 0 || index &gt;= argc-1)
        throw <a href="../api/classcRuntimeError.html">cRuntimeError</a>("choose(): index %d is out of range", index);
    return argv[index+1];
}

Define_NED_Function(ned_choose, "any choose(int index, ...)");
</pre>
<p>
Here, the value of <tt>argv[0]</tt> is read using the typecast operator that
maps to <tt>longValue()</tt>. (Note that if the value of the <tt>index</tt>
argument does not fit into an <tt>int</tt>, the conversion will result
in data loss!) The code also shows how to report errors (by throwing a
<tt><a href="../api/classcRuntimeError.html">cRuntimeError</a></tt>.)

<p>The third example shows how the built-in <tt>uniform()</tt> NED function could
be reimplemented by the user:

<pre class="cpp">
static <a href="../api/classcNEDValue.html">cNEDValue</a> ned_uniform(<a href="../api/classcComponent.html">cComponent</a> *context, <a href="../api/classcNEDValue.html">cNEDValue</a> argv[], int argc)
{
    int rng = argc==3 ? (int)argv[2] : 0;
    double argv1converted = argv[1].doubleValueInUnit(argv[0].getUnit());
    double result = uniform((double)argv[0], argv1converted, rng);
    return <a href="../api/classcNEDValue.html">cNEDValue</a>(result, argv[0].getUnit());
    // or: argv[0].setPreservingUnit(result); return argv[0];
}

Define_NED_Function(ned_uniform, "quantity uniform(quantity a, quantity b, int rng?)");
</pre>
<p>
The first line of the function body shows how to supply default values for
optional arguments; for the <tt>rng</tt> argument in this case. The next line
deals with unit conversion. This is necessary because the <tt>a</tt> and
<tt>b</tt> arguments are both quantities and may come in with different
measurement units. We use the <tt>doubleValueInUnit()</tt> function to
obtain the numeric value of <tt>b</tt> in <tt>a</tt>'s measurement unit. If the
two units are incompatible or only one of the parameters have a unit, an
error will be raised. If neither parameters have a unit,
<tt>doubleValueInUnit()</tt> simply returns the stored <tt>double</tt>. Then we
call the <tt>uniform()</tt> C++ function to actually generate a random number,
and return it in a temporary object with <tt>a</tt>'s measurement unit.
Alternatively, we could have overwritten the numeric part of <tt>a</tt> with
the result using <tt>setPreservingUnit()</tt>, and returned just that. If
there is no measurement unit, <tt>getUnit()</tt> will return <tt>NULL</tt>,
which is understood by both <tt>doubleValueInUnit()</tt> and the
<tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> constructor.

<p><ul class="note"><b>NOTE</b><br>
Note that it is OK to change the elements of the <tt>argv[]</tt> vector: they
will be discarded (popped off the evaluation stack) by the NED expression
evaluator anyway when your function returns.
</ul>

<p>
<p class="subheading"><a href="../api/classcNEDValue.html">cNEDValue</a> In More Detail</p>

<p>In the previous section we have given an overview and demonstrated the basic
use of the <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> class; here we go into further details.

<p>The stored data type can be obtained with the <tt>getType()</tt> function.
It returns an enum (<tt><a href="../api/classcNEDValue.html">cNEDValue</a>::Type</tt>) that has the following values:
<tt>UNDEF</tt>, <tt>BOOL</tt>, <tt>DBL</tt>, <tt>STR</tt>, <tt>XML</tt>. <tt>UNDEF</tt> is
synonymous with <i>unset</i>; the others have the obvious meanings. There
is no separate <tt>QUANTITY</tt> type: quantities are also represented with
the <tt>DBL</tt> type, which has an optional associated measurement unit. Note
that <tt>LONG</tt> is also missing; the reason is that the NED expression
evaluator currently (as of OMNEST 4.2) stores all numbers as <tt>double</tt>s.
  <br><ul><font size=-1>[The IEEE <i>double</i>'s mantissa is 53 bits, so <tt>double</tt>
  can accurately represent 32-bit integers, the usual size of <tt>long</tt> on
  32-bit architectures. On 64-bit architectures the usual size of <tt>long</tt>
  is 64 bits, so precision loss will occur when converting very large integers
  to <tt>double</tt>. Note, however, that simulations that trigger this precision
  loss would not be able to run on 32-bit architectures at all!]</font></ul>

<p>The <tt>getTypeName()</tt> static function returns the string equivalent of
a <tt><a href="../api/classcNEDValue.html">cNEDValue</a>::Type</tt>. The utility functions <tt>isSet()</tt> and
<tt>isNumeric()</tt> check that the type is (not) <tt>UNDEF</tt> and <tt>DBL</tt>,
respectively.

<pre class="cpp">
<a href="../api/classcNEDValue.html">cNEDValue</a> value = 5.0;
<a href="../api/classcNEDValue.html">cNEDValue</a>::Type type = value.getType(); // ==&gt; DBL
ev &lt;&lt; <a href="../api/classcNEDValue.html">cNEDValue</a>::getTypeName(type) &lt;&lt; endl; // ==&gt; "double"
</pre>
<p>
We have already seen that the <tt>DBL</tt> type serves both the
<b><tt>double</tt></b> and <b><tt>quantity</tt></b> types of the NED function
signature, by storing an optional measurement unit (a string)
in addition to the <tt>double</tt> variable. A <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> can be set
to a quantity by creating it with a two-argument constructor that accepts
a <tt>double</tt> and a <tt>const char *</tt> for unit, or by invoking a similar
two-argument <tt>set()</tt> function. The measurement unit can be read with
<tt>getUnit()</tt>, and overwritten with <tt>setUnit()</tt>. If you assign a
<tt>double</tt> to a <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> or invoke the one-argument
<tt>set(double)</tt> method on it, that will clear the measurement unit. If you
want to overwrite the number part but preserve the original unit, you need
to use the <tt>setPreservingUnit(double)</tt> method.

<p>There are several functions that perform unit conversion. The
<tt>doubleValueInUnit()</tt> method accepts a measurement unit, and attempts
to return the number in that unit. The <tt>convertTo()</tt> method also
accepts a measurement unit, and tries to permanently convert the value to
that unit; that is, if successful, it changes both the number and the
measurement unit part of the object. The <tt>convertUnit()</tt> static
<tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> member function accepts three arguments: a quantity as a
<tt>double</tt> and a unit, and a target unit; and returns the number in the
target unit. A <tt>parseQuantity()</tt> static member function parses
a string that contains a quantity (e.g. <tt>"5min 48s"</tt>), and return
both the numeric value and the measurement unit. Another version of
<tt>parseQuantity()</tt> tries to return the value in a unit you specify.
All functions raise an error if the unit conversion is not possible, e.g.
due to incompatible units.

<p>For performance reasons, <tt>setUnit()</tt>, <tt>convertTo()</tt> and all other
functions that accept and store a measurement unit will only store the
<tt>const char*</tt> pointer, but do <i>not</i> copy the string itself.
Consequently, the passed measurement unit pointers must stay valid for at
least the lifetime of the <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> object, or even longer if the
same pointer propagates to other <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt> objects. It is
recommended that you only pass pointers that stay valid during the entire
simulation. It is safe to use: (1) string constants from the code; (2) unit
strings from other <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt>s; and (3) pooled strings e.g. from a
<tt><a href="../api/classcStringPool.html">cStringPool</a></tt> or from <tt><a href="../api/classcNEDValue.html">cNEDValue</a></tt>'s static <tt>getPooled()</tt>
function.

<p>Example code:

<pre class="cpp">
// manipulating the number and the measurement unit
<a href="../api/classcNEDValue.html">cNEDValue</a> value(250,"ms");    // initialize to 250ms
value = 300.0;                // ==&gt; 300 (clears the unit!)
value.set(500,"ms");          // ==&gt; 500ms
value.setUnit("s");           // ==&gt; 500s (overwrites the unit)
value.setPreservingUnit(180); // ==&gt; 180s (overwrites the number)
value.setUnit(NULL);          // ==&gt; 180 (clears the unit)

// unit conversion
value.set(500, "ms");         // ==&gt; 500ms
value.convertTo("s");         // ==&gt; 0.5s
double us = value.doubleValueInUnit("us"); // ==&gt; 500000 (value is unchanged)
double bps = <a href="../api/classcNEDValue.html">cNEDValue</a>::convertUnit(128, "kbps", "bps"); // ==&gt; 128000
double ms = <a href="../api/classcNEDValue.html">cNEDValue</a>::convertUnit("2min 15.1s", "ms"); // ==&gt; 135100

// getting persistent measurement unit strings
const char *unit = argv[0].stringValue(); // cannot be trusted to persist
value.setUnit(<a href="../api/classcNEDValue.html">cNEDValue</a>::getPooled(unit)); // use a persistent copy for setUnit()
</pre>
<p>

<p><h3><a name="sec303"/>7.11.2 Define_NED_Math_Function()</h3>

<p>The <tt>Define_NED_Math_Function()</tt> macro lets you register a C/C++
&#8220;mathematical&#8221; function as a NED function. The registered C/C++ function
may take up to four <tt>double</tt> arguments, and must return a <tt>double</tt>;
the NED signature will be the same. In other words, functions registered
this way cannot accept any NED data type other than <tt>double</tt>; cannot
return anything else than <tt>double</tt>; cannot accept or return values with
measurement units; cannot have optional arguments or variable argument
lists; and are restricted to four arguments at most. In exchange for these
restrictions, the C++ implementation of the functions is a lot simpler.

<p>Accepted function signatures for <tt>Define_NED_Math_Function()</tt>:

<pre class="cpp">
double f();
double f(double);
double f(double, double);
double f(double, double, double);
double f(double, double, double, double);
</pre>
<p>
The simulation kernel uses <tt>Define_NED_Math_Function()</tt> to expose
commonly used <tt>&lt;math.h&gt;</tt> functions in the NED language. Most <tt>&lt;math.h&gt;</tt>
functions (<tt>sin()</tt>, <tt>cos()</tt>, <tt>fabs()</tt>, <tt>fmod()</tt>, etc.)
can be directly registered without any need for wrapper code, because their
signatures is already one of the accepted ones listed above.

<p>The macro has the following variants:

<pre class="cpp">
Define_NED_Math_Function(NAME,ARGCOUNT);
Define_NED_Math_Function2(NAME,FUNCTION,ARGCOUNT);
Define_NED_Math_Function3(NAME,ARGCOUNT,CATEGORY,DESCRIPTION);
Define_NED_Math_Function4(NAME,FUNCTION,ARGCOUNT,CATEGORY,DESCRIPTION);
</pre>
<p>
All macros accept the <tt>NAME</tt> and <tt>ARGCOUNT</tt> parameters; they are
the intended name of the NED function and the number of <tt>double</tt>
arguments the function takes (0..3). <tt>NAME</tt> should be provided without
quotation marks (they will be added inside the macro.) Two macros also
accept a <tt>FUNCTION</tt> parameter, which is the name of (or pointer to) the
implementation C/C++ function. The macros that don't have a <tt>FUNCTION</tt>
parameter simply use the <tt>NAME</tt> parameter for that as well. The last
two macros accept <tt>CATEGORY</tt> and <tt>DESCRIPTION</tt>, which have exactly
the same role as with <tt>Define_NED_Function()</tt>.

<p>Examples:

<pre class="cpp">
Define_NED_Math_Function3(sin, 1, "math", "Trigonometric function; see &lt;math.h&gt;");
Define_NED_Math_Function3(cos, 1, "math", "Trigonometric function; see &lt;math.h&gt;");
Define_NED_Math_Function3(pow, 2, "math", "Power-of function; see &lt;math.h&gt;");
</pre>
<p>

<p>
<h2><a name="sec304"/>7.12 Deriving New Classes</h2>
<a name="sec:ch-sim-lib:deriving-new-classes"></a>

<p><h3><a name="sec305"/>7.12.1 <a href="../api/classcOwnedObject.html">cOwnedObject</a> or Not?</h3>

<p>If you plan to implement a completely new class (as opposed to
subclassing something already present in OMNEST), you have
to ask yourself whether you want the new class to be based
on <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> or not.
Note that we are <i>not</i> saying you should always
subclass from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>.
Both solutions have advantages and disadvantages, which you
have to consider individually for each class.

<p><tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> already carries (or provides a framework for)
significant functionality that is either relevant to
your particular purpose or not. Subclassing <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
generally means you have more code to write (as you <i>have to</i>
redefine certain virtual functions and adhere to conventions)
and your class will be a bit more heavy-weight.
However, if you need to store your objects in OMNEST objects like <tt><a href="../api/classcQueue.html">cQueue</a></tt>
or you want to store OMNEST classes in your object,
then you <i>must</i> subclass from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>.
  <br><ul><font size=-1>[For simplicity, in these sections &#8220;OMNEST object&#8221;
  should be understood as &#8220;object of a class subclassed from
  <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>&#8221;]</font></ul>

<p>The most significant features of <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> are
the name string (which has to be stored somewhere, so it has
its overhead) and ownership management (see section
<a href="#sec309">[7.13]</a>), which
also provides advantages at some cost.

<p>As a general rule, small <tt>struct</tt>-like classes like <tt>IPAddress</tt>,
<tt>MACAddress</tt>, <tt>RoutingTableEntry</tt>, <tt>TCPConnectionDescriptor</tt>, etc.
are better <i>not</i> subclassed from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>.
If your class has at least one virtual member function, consider
subclassing from <tt><a href="../api/classcObject.html">cObject</a></tt>, which does not impose any
extra cost because it doesn't have data members at all, only
virtual functions.

<p>
<h3><a name="sec306"/>7.12.2 <a href="../api/classcOwnedObject.html">cOwnedObject</a> Virtual Methods</h3>

<p>Most classes in the simulation class library are descendants of
<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>. If you want to derive a new class from
<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> or a <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> descendant, you must redefine
some member functions so that objects of the new type can fully
co-operate with other parts of the simulation system. A more or less
complete list of these functions is presented here. You don't need to
worry about the length of the list: most functions are not
absolutely necessary to implement. For example, you do not need to
redefine <tt>forEachChild()</tt> unless your class is a container class.

<p>The following methods <b>must</b> be implemented:

<p><ul>
  <li><i>Constructor</i>. At least two constructors should be provided:
        one that takes the object name string as <tt>const char *</tt>
        (recommended by convention), and another one with no arguments
        (must be present). The two are usually implemented as a single
        method, with <tt>NULL</tt> as default name string.
  <li><i>Copy constructor</i>, which must have the following signature
        for a class <tt>X</tt>: <tt>X(const X&amp;)</tt>.
  <li><i>Destructor</i>.
  <li><i>Duplication function,</i> <tt>X *dup() const</tt>.
        It should create and return an exact duplicate of the object.
        It is usually a one-line function that delegates to the copy constructor.
  <li><i>Assignment operator</i>, that is, <tt>X&amp; operator=(const X&amp;)</tt>
        for a class <tt>X</tt>. It should copy the contents of the other
        object into this one, <i>except</i> the name string. See later what to do
        if the object contains pointers to other objects.
</ul>

<p>If your class contains other objects subclassed from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>,
either via pointers or as a data member, the following function <b>should</b>
be implemented:

<p><ul>
  <li><i>Iteration function,</i> <tt>void forEachChild(<a href="../api/classcVisitor.html">cVisitor</a> *v)</tt>.
        The implementation should call the function passed
        for each object it contains via pointer or as a data member;
        see the API Reference on <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> on how to implement
        <tt>forEachChild()</tt>. <tt>forEachChild()</tt> makes it possible
        for Tkenv to display the object tree to you, to perform searches on it, etc.
        It is also used by <tt>snapshot()</tt> and some other library functions.
</ul>

<p>Implementation of the following methods is <b>recommended</b>:

<p><ul>
  <li><i>Object info,</i> <tt>std::string info()</tt>. The <tt>info()</tt> function
        should return a one-line string describing the object's contents or state.
        <tt>info()</tt> is displayed at several places in Tkenv.
  <li><i>Detailed object info,</i> <tt>std::string detailedInfo()</tt>.
        This method may potentially be implemented in addition to <tt>info()</tt>;
        it can return a multi-line description. <tt>detailedInfo()</tt> is also
        displayed by Tkenv in the object's inspector.
  <li><i>Serialization</i>, <tt>parsimPack()</tt> and <tt>parsimUnpack()</tt> methods.
        These methods are needed for parallel simulation, if you want
        objects of this type to be transmitted across partitions.
</ul>

<p>It is customary to implement the copy constructor and the assignment operator
so that they delegate to the same function of the base class, and invoke a common
private <tt>copy()</tt> function to copy the local members.

<p><h3><a name="sec307"/>7.12.3 Class Registration</h3>

<p>You should also use the <tt>Register_Class()</tt> macro to register the
new class. It is used by the <tt>createOne()</tt> factory function, which can
create any object given the class name as a string. <tt>createOne()</tt>
is used by the Envir library to implement <tt>omnetpp.ini</tt> options
such as <tt>rng-class="..."</tt> or <tt>scheduler-class="..."</tt>.
(see Chapter <a href="#sec487">[17]</a>)

<p>For example, an <tt>omnetpp.ini</tt> entry such as

<pre class="inifile">
rng-class = "<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>"
</pre>
<p>
would result in something like the following code to be executed
for creating the RNG objects:

<pre class="cpp">
<a href="../api/classcRNG.html">cRNG</a> *rng = check_and_cast&lt;<a href="../api/classcRNG.html">cRNG</a>*&gt;(createOne("<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>"));
</pre>
<p>
But for that to work, we needed to have the following line somewhere in the code:

<pre class="cpp">
Register_Class(<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>);
</pre>
<p>
<tt>createOne()</tt> is also needed by the parallel distributed simulation feature
(Chapter <a href="#sec478">[16]</a>) to create blank objects to unmarshal into
on the receiving side.

<p>
<h3><a name="sec308"/>7.12.4 Details</h3>

<p>We'll go through the details using an example. We create a new
class <tt>NewClass</tt>, redefine all above mentioned <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
member functions, and explain the conventions, rules and tips
associated with them.
To demonstrate as much as possible, the class will contain
an <tt>int</tt> data member, dynamically allocated non-<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> data
(an array of <tt>double</tt>s),
an OMNEST object as data member (a <tt><a href="../api/classcQueue.html">cQueue</a></tt>), and
a dynamically allocated OMNEST object (a <tt><a href="../api/classcMessage.html">cMessage</a></tt>).

<p>The class declaration is the following. It contains the declarations
of all methods discussed in the previous section.

<pre class="cpp">
//
// file: NewClass.h
//
#include &lt;omnetpp.h&gt;

class NewClass : public <a href="../api/classcOwnedObject.html">cOwnedObject</a>
{
  protected:
    int size;
    double *array;
    <a href="../api/classcQueue.html">cQueue</a> queue;
    <a href="../api/classcMessage.html">cMessage</a> *msg;
    ...
  private:
    void copy(const NewClass& other); // local utility function
  public:
    NewClass(const char *name=NULL, int d=0);
    NewClass(const NewClass& other);
    virtual ~NewClass();
    virtual NewClass *dup() const;
    NewClass& operator=(const NewClass& other);

    virtual void forEachChild(<a href="../api/classcVisitor.html">cVisitor</a> *v);
    virtual std::string info();
};
</pre>
<p>
We'll discuss the implementation method by method.
Here is the top of the <tt>.cc</tt> file:

<pre class="cpp">
//
// file: NewClass.cc
//
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream.h&gt;
#include "newclass.h"

Register_Class( NewClass );


NewClass::NewClass(const char *name, int sz) : <a href="../api/classcOwnedObject.html">cOwnedObject</a>(name)
{
    size = sz;
    array = new double[size];
    take(&queue);
    msg = NULL;
}
</pre>
<p>
The constructor (above) calls the base class constructor with
the name of the object, then initializes its own data members.
You need to call <tt>take()</tt> for <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based data members.

<pre class="cpp">
NewClass::NewClass(const NewClass& other) : <a href="../api/classcOwnedObject.html">cOwnedObject</a>(other)
{
    size = -1; // needed by copy()
    array = NULL;
    msg = NULL;
    take(&queue);
    copy(other);
}
</pre>
<p>
The copy constructor relies on the private <tt>copy()</tt> function.
Note that pointer members have to be initialized (to <tt>NULL</tt> or to an
allocated object/memory) before calling the <tt>copy()</tt> function.

<p>You need to call <tt>take()</tt> for <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based data members.

<pre class="cpp">
NewClass::~NewClass()
{
    delete [] array;
    if (msg-&gt;getOwner()==this)
        delete msg;
}
</pre>
<p>
The destructor should delete all data structures the object allocated.
<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based objects should <i>only</i> be deleted if they
are owned by the object -- details will be covered in section
<a href="#sec309">[7.13]</a>.

<pre class="cpp">
NewClass *NewClass::dup() const
{
    return new NewClass(*this);
}
</pre>
<p>
The <tt>dup()</tt> function  is usually just one line, like the one above.

<pre class="cpp">
NewClass& NewClass::operator=(const NewClass& other)
{
    if (&other==this)
        return *this;

    <a href="../api/classcOwnedObject.html">cOwnedObject</a>::operator=(other);
    copy(other);
    return *this;
}
</pre>
<p>
The assignment operator (above) first makes sure that will not try to copy
the object to itself, because that can be disastrous. If so (that is,
<tt>&amp;other==this</tt>), the function returns immediately without doing anything.

<p>The base class part is copied via invoking the assignment operator of
the base class. Then the method copies over the local members using the
<tt>copy()</tt> private utility function.

<pre class="cpp">
void NewClass::copy(const NewClass& other)
{
    if (size != other.size) {
        size = other.size;
        delete array;
        array = new double[size];
    }
    for (int i = 0; i &lt; size; i++)
        array[i] = other.array[i];

    queue = other.queue;
    queue.setName(other.queue.getName());

    if (msg && msg-&gt;getOwner()==this)
        delete msg;

    if (other.msg && other.msg-&gt;getOwner()==const_cast&lt;<a href="../api/classcMessage.html">cMessage</a>*&gt;(&other))
        take(msg = other.msg-&gt;dup());
    else
        msg = other.msg;
}
</pre>
<p>
Complexity associated with copying and duplicating the object
is concentrated in the <tt>copy()</tt> utility function.

<p>Data members are copied in the normal C++ way. If the class
contains pointers, you will most probably want to make a deep copy of
the data where they point, and not just copy the pointer values.

<p>If the class contains pointers to OMNEST objects, you need
to take ownership into account. If the contained object is <i>not owned</i>
then we assume it is a pointer to an &#8220;external&#8221; object, consequently
we only copy the pointer. If it is <i>owned</i>, we duplicate
it and become the owner of the new object. Details of ownership
management will be covered in section <a href="#sec309">[7.13]</a>.

<p>
<pre class="cpp">
void NewClass::forEachChild(<a href="../api/classcVisitor.html">cVisitor</a> *v)
{
    v-&gt;visit(queue);
    if (msg)
        v-&gt;visit(msg);
}
</pre>

<p>The <tt>forEachChild()</tt> function should call <tt>v-&gt;visit(obj)</tt>
for each <tt>obj</tt> member of the class. See the API Reference for more
information about <tt>forEachChild()</tt>.

<pre class="cpp">
std::string NewClass::info()
{
    std::stringstream out;
    out &lt;&lt; "data=" &lt;&lt; data &lt;&lt; ", array[0]=" &lt;&lt; array[0];
    return out.str();

}
</pre>
<p>
The <tt>info()</tt> method should produce a concise, one-line string
about the object. You should try not to exceed 40-80 characters, since the
string will be shown in tooltips and listboxes.

<p>See the virtual functions of <tt><a href="../api/classcObject.html">cObject</a></tt> and <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
in the class library reference for more information. The sources of the
Sim library (<tt>include/</tt>, <tt>src/sim/</tt>) can serve as further examples.

<p>

<p><h2><a name="sec309"/>7.13 Object Ownership Management</h2>
<a name="sec:ch-sim-lib:ownership-management"></a>

<p><h3><a name="sec310"/>7.13.1 The Ownership Tree</h3>

<p>OMNEST has a built-in ownership management mechanism which
is used for sanity checks, and as part of the infrastructure
supporting Tkenv inspectors.

<p>Container classes like <tt><a href="../api/classcQueue.html">cQueue</a></tt> own the objects inserted
into them, but this is not limited to objects inserted into a container:
<i>every <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based object has an owner all the time</i>.
From the user's point of view, ownership is managed transparently.
For example, when you create a new <tt><a href="../api/classcMessage.html">cMessage</a></tt>,
it will be owned by the simple module. When you send it, it will
first be handed over to (i.e. change ownership to) the FES<!--FES-->, and,
upon arrival, to the destination simple module. When you encapsulate
the message in another one, the encapsulating message will become
the owner. When you decapsulate it again, the currently active
simple module becomes the owner.

<p>The <tt>getOwner()</tt> method, defined in <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>, returns the
owner of the object:

<pre class="cpp">
<a href="../api/classcOwnedObject.html">cOwnedObject</a> *o = msg-&gt;getOwner();
ev &lt;&lt; "Owner of " &lt;&lt; msg-&gt;getName() &lt;&lt; " is: " &lt;&lt;
   &lt;&lt; "(" &lt;&lt; o-&gt;getClassName() &lt;&lt; ") " &lt;&lt; o-&gt;getFullPath() &lt;&lt; endl;
</pre>
<p>
The other direction, enumerating the objects owned can be implemented with
the <tt>forEachChild()</tt> method by it looping through all
contained objects and checking the owner of each object.

<p><p class="subheading">Why Do We Need This?</p>

<p>The traditional concept of object ownership is associated with
the &#8220;right to delete&#8221; objects. In addition to that,
keeping track of the owner and the list of objects owned also
serves other purposes in OMNEST:

<p><ul>
    <li>enables methods like <tt>getFullPath()</tt> to be implemented.

<p>    <li>prevents certain types of programming errors, namely,
    those associated with wrong ownership handling.

<p>    <li>enables Tkenv to display the list of simulation objects
    present within a simple module. This is extremely useful for finding
    memory leaks caused by forgetting to delete messages that are
    no longer needed.
</ul>

<p>Some examples of programming errors that can be caught
by the ownership facility:

<p><ul>
    <li>attempts to send a message while it is still in a queue,
    encapsulated in another message, etc.

<p>    <li>attempts to send/schedule a message while it is still owned
    by the simulation kernel (i.e. scheduled as a future event)

<p>    <li>attempts to send the very same message object to multiple
    destinations at the same time (ie. to all connected modules)
</ul>

<p>For example, the <tt>send()</tt> and <tt>scheduleAt()</tt> functions check
that the message being sent/scheduled is owned by the module.
If it is not, then it signals a programming error: the message is probably
owned by another module (already sent earlier?), or currently scheduled, or
inside a queue, a message or some other object -- in either case, the
module does not have any authority over it. When you get the error message
(<tt>"not owner of object"</tt>), you need to carefully examine the error
message to determine which object has ownership of the message, and correct
the logic that caused the error.

<p>The above errors are easy to make in the code, and if not detected
automatically, they could cause random crashes which are usually very
difficult to track down. Of course, some errors of the same kind still
cannot be detected automatically, like calling member functions of a
message object which has been sent to (and so is currently owned by) another
module.

<p>
<h3><a name="sec311"/>7.13.2 Managing Ownership</h3>

<p>Ownership is managed transparently for the user, but this mechanism
has to be supported by the participating classes themselves.
It will be useful to look inside <tt><a href="../api/classcQueue.html">cQueue</a></tt> and <tt><a href="../api/classcArray.html">cArray</a></tt>,
because they might give you a hint what behavior you need
to implement when you want to use non-OMNEST container classes
to store messages or other <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based objects.

<p>
<p class="subheading">Insertion</p>

<p><tt><a href="../api/classcArray.html">cArray</a></tt> and <tt><a href="../api/classcQueue.html">cQueue</a></tt> have internal data structures
(array and linked list) to store the objects which are inserted
into them. However, they do <i>not</i> necessarily own all of these
objects.  (Whether they own an object or not can be determined
from that object's <tt>getOwner()</tt> pointer.)

<p>The default behaviour of <tt><a href="../api/classcQueue.html">cQueue</a></tt> and <tt><a href="../api/classcArray.html">cArray</a></tt> is
to take ownership of the objects inserted.
This behavior can be changed via the <i>takeOwnership</i> flag.

<p>Here is what the <i>insert</i> operation of <tt><a href="../api/classcQueue.html">cQueue</a></tt> (or <tt><a href="../api/classcArray.html">cArray</a></tt>) does:
<ul>
    <li>insert the object into the internal array/list data structure

<p>    <li>if the <i>takeOwnership</i> flag is true, take ownership
    of the object, otherwise just leave it with its original owner
</ul>

<p>The corresponding source code:

<pre class="cpp">
void <a href="../api/classcQueue.html">cQueue</a>::insert(<a href="../api/classcOwnedObject.html">cOwnedObject</a> *obj)
{
    // insert into queue data structure
    ...

    // take ownership if needed
    if (getTakeOwnership())
        take(obj);

}
</pre>
<p>

<p><p class="subheading">Removal</p>

<p>Here is what the <i>remove</i> family of operations in <tt><a href="../api/classcQueue.html">cQueue</a></tt>
(or <tt><a href="../api/classcArray.html">cArray</a></tt>) does:

<p><ul>
    <li>remove the object from the internal array/list data structure

<p>    <li>if the object is actually owned by this <tt><a href="../api/classcQueue.html">cQueue</a></tt>/<tt><a href="../api/classcArray.html">cArray</a></tt>,
    release ownership of the object, otherwise just leave it with
    its current owner
</ul>

<p>After the object was removed from a <tt><a href="../api/classcQueue.html">cQueue</a></tt>/<tt><a href="../api/classcArray.html">cArray</a></tt>,
you may further use it, or if it is not needed any more, you can delete it.

<p>The <i>release ownership</i> phrase requires further explanation.
When you remove an object from a queue or array, the ownership
is expected to be transferred to the simple module's local objects list.
This is accomplished by the <tt>drop()</tt> function, which transfers the
ownership to the object's default owner.
<tt>getDefaultOwner()</tt> is a virtual method returning <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a>*</tt>
defined in <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>, and its implementation returns
the currently executing simple module's local object list.

<p>As an example, the <tt>remove()</tt> method of <tt><a href="../api/classcQueue.html">cQueue</a></tt> is
implemented like this:
  <br><ul><font size=-1>[Actual code in <tt>src/sim</tt> is structured somewhat
  differently, but the meaning is the same.]</font></ul>

<pre class="cpp">
<a href="../api/classcOwnedObject.html">cOwnedObject</a> *<a href="../api/classcQueue.html">cQueue</a>::remove(<a href="../api/classcOwnedObject.html">cOwnedObject</a> *obj)
{
    // remove object from queue data structure
    ...

    // release ownership if needed
    if (obj-&gt;getOwner()==this)
        drop(obj);

    return obj;
}
</pre>
<p>

<p><p class="subheading">Destructor</p>

<p>The concept of <tt>ownership</tt> is that <i>the owner has the
exclusive right and duty to delete the objects it owns</i>.
For example, if you delete a <tt><a href="../api/classcQueue.html">cQueue</a></tt> containing <tt><a href="../api/classcMessage.html">cMessage</a></tt>s,
all messages it contains <i>and</i> owns will also be deleted.

<p>The destructor should delete all data structures the object allocated.
From the contained objects, only the owned ones are deleted -- that is,
where <tt>obj-&gt;getOwner()==this</tt>.

<p>
<p class="subheading">Object Copying</p>

<p>The ownership mechanism also has to be taken into consideration
when a <tt><a href="../api/classcArray.html">cArray</a></tt> or <tt><a href="../api/classcQueue.html">cQueue</a></tt> object is duplicated
(using <tt>dup()</tt> or the copy constructor.)
The duplicate is supposed to have the same content as the
original; however, the question is whether the contained objects
should also be duplicated or only their pointers taken over
to the duplicate <tt><a href="../api/classcArray.html">cArray</a></tt> or <tt><a href="../api/classcQueue.html">cQueue</a></tt>. A similar
question arises when an object is copied using the assignment operator
(<tt>operator=()</tt>).

<p>The convention followed by <tt><a href="../api/classcArray.html">cArray</a></tt>/<tt><a href="../api/classcQueue.html">cQueue</a></tt> is that
only owned objects are copied, and the contained but not owned ones
will have their pointers taken over and their original owners
left unchanged.

<p>


<hr class='pgbr'><h1><a name="sec312"/>8 Building Simulation Programs</h1>
<a name="cha:building-simulation-programs"></a>

<p><h2><a name="sec313"/>8.1 Overview</h2>

<p>As has already been mentioned, an OMNeT++ model consists of
the following parts:

<p><ul>
  <li>NED language<!--ned!files--> topology description(s). These
      are files with the <tt>.ned</tt> extension.
  <li>Message definitions<!--message definitions-->, in files
      with <tt>.msg</tt> extension.
  <li>Simple module implementations and other C++ code, in <tt>.cc</tt>
        files (or <tt>.cpp</tt>, on Windows)
</ul>

<p>
To build an executable simulation program,
you first need to translate the MSG files<!--msg!files-->
into C++, using the message compiler (<tt>opp_msgc</tt>).
After this step, the process is the same as building any C/C++
program from source: all C++ sources need to be compiled into object files
(<tt>.o</tt> files (using gcc on Mac, Linux) or mingw on Windows)

and all object files need to be linked with the necessary libraries to get
an executable or shared library.

<p><ul class="note"><b>NOTE</b><br>
Compiling NED files directly to C++ code is no longer supported in
OMNeT++ 4.0. NED files are always dynamically loaded.
</ul>

<p>File names for libraries differ depending on the platform, whether it is 
a static or shared library, and whether it is a debug or release version.
Let us suppose you have a library called <tt>common</tt>: 
<ul>
  <li>The <tt>opp</tt> prefix is always prepended to all library names to avoid name clashes with other programs.
  <li>For all platforms, where the gcc (or mingw) compiler is used the static library filename has a ".a" extension 
         and the <tt>lib</tt> prefix is prepended to the name (e.g. <tt>liboppfoo[d].a</tt>).
  <li>For all platforms, the debug version filename has a "d" inserted 
            at the end of the library name  (e.g. <tt>liboppcommond.ext</tt>).
  <li>For the Unix/Linux platform, the shared library filename has a ".so"  
         extension (e.g. <tt>liboppcommon[d].so</tt>).
  <li>For the Mac OS X platform, the shared library filename has a ".dylib"  
         extension (e.g. <tt>liboppcommon[d].dylib</tt>).
  <li>For the Windows platform, the shared library filename has a ".dll"  
         extension (e.g. <tt>liboppfoo[d].dll</tt>).
  
</ul>

<p>In OMNeT++ 4.0 we recommend that you use shared libraries whenever it is possible.
You will need to link with the following libraries:

<p><ul>
  <li>The simulation kernel and class library<!--simulation!kernel-->,
    called <i>oppsim</i> (file <tt>liboppsim.[so|dll|dylib]</tt> etc).
  <li>User interfaces. The common part of all user interfaces is
    the <i>oppenvir</i> library (file <tt>liboppenvir.[so|dll|dylib]</tt>, etc),
    and the specific user interfaces are <i>opptkenv</i> and <i>oppcmdenv</i>
    (<tt>libopptkenv.[so|dll|dylib]</tt>, <tt>liboppcmdenv.[so|dll|dylib]</tt>, etc).
    You have to link with <i>oppenvir</i>, plus <i>opptkenv</i> or
    <i>oppcmdenv</i> or both.
</ul>

<p>Luckily, you do not have to worry about the above details, because
automatic tools like <tt>opp_makemake</tt> will take care of the hard
part for you.

<p>The following figure gives an overview of the process of building
and running simulation programs.

<p>
  <center>
    <img src="build-workflow.png">
    <center><i>Figure: Building and running simulation</i></center>
  </center>

<p>

<p>This chapter discusses how to use the simulation system on the
following platforms:
<ul>
  <li>Unix (Linux/Mac OS X) with gcc
  <li>Windows with the included MinGW compiler
  
</ul>

<p>
<h2><a name="sec314"/>8.2 Using gcc</h2>

<p>The following section applies to using OMNeT++ on Linux, Solaris, Mac OS X, FreeBSD and
other Unix derivatives, and also to MinGW on Windows.

<p><ul class="note"><b>NOTE</b><br>
The <tt>doc/</tt> directory of your OMNeT++ installation contains
<tt>Readme.</tt><i>&lt;platform&gt;</i> files that provide more detailed platform specific instructions.
</ul>

<p>
<h3><a name="sec315"/>8.2.1 The opp_makemake Tool</h3>

<p>The <tt>opp_makemake</tt> tool can automatically generate a
<tt>Makefile</tt> for your simulation program, based on the source files
in the current directory or directory tree.
<tt>opp_makemake</tt> has several options; <tt>opp_makemake -h</tt>
displays help.

<p>The most important options are:

<p><ul>
    <li><tt>-f, --force</tt> : Force overwriting existing Makefile
    <li><tt>-o filename</tt> : Name of simulation executable or library to be built.
    <li><tt>-O directory, --out directory</tt> : Specifies the name of the output directory tree
                          for out-of-directory build
    <li><tt>--deep</tt> : Generates a "deep" Makefile. A deep Makefile will
                          cover the whole source tree under the make directory,
                          not just files in that directory.
    <li><tt>-r, --recurse</tt> : Causes make to recursively descend into all subdirectories;
                          subdirectories are expected to contain
                          makefiles themselves.
    <li><tt>-X directory, -Xdirectory, --except directory</tt> :
                          With <tt>-r</tt> and <tt>--deep</tt> option: ignore the given directory.
    <li><tt>-dsubdir, -d subdir, --subdir subdir</tt> :
                          Causes make to recursively descend into the given
                          directory.
    <li><tt>-n, --nolink</tt> :  Produce object files but do not create executable or
                          library.
    <li><tt>-s, --make-so</tt> : Build shared library (.so, .dll or .dylib).
    <li><tt>-a, --make-lib</tt> : Create static library (.a or .lib).
    <li><tt>-Idir</tt> :         Additional NED and C++ include directory.
    <li><tt>-Ldir</tt> :         Add a directory to the library path.
    <li><tt>-llibrary</tt> :     Additional library to link against.
</ul>

<p>
<h3><a name="sec316"/>8.2.2 Basic Use</h3>

<p>Once you have the source files (<tt>*.ned</tt>, <tt>*.msg</tt>, <tt>*.cc</tt>,
<tt>*.h</tt>) in a directory, change the working directory to there and type:

<pre class="commandline">
$ opp_makemake
</pre>
<p>
This will create a file named <tt>Makefile</tt><!--Makefile-->. If you
type <tt>make</tt>, your simulation program should build.

<p>
If you already had a <tt>Makefile</tt> in that directory, <tt>opp_makemake</tt>
will refuse to overwrite it. You can force overwriting the old <tt>Makefile</tt>
with the -f option:

<pre class="commandline">
$ opp_makemake -f
</pre>
<p>
The name of the output file<!--output!file--> will be derived from
the name of the project directory (see later). You can override it
with the <tt>-o</tt> option:

<pre class="commandline">
$ opp_makemake -f -o aloha
</pre>
<p>
In addition to the default target that builds the simulation executable,
the <tt>Makefile</tt> also contains the following targets:

<p><table border>
<TR> <TD align=left>

<p><b>Target</b> </TD> <TD align=left> <b>Action</b></TD></TR>
<TR> <TD align=left> all </TD> <TD align=left> The default target is to build the simulation executable</TD></TR>
<TR> <TD align=left> depend </TD> <TD align=left> Adds (or refreshes) dependencies in the <tt>Makefile</tt></TD></TR>
<TR> <TD align=left> clean </TD> <TD align=left>  Deletes all files that were produced by the make process</TD></TR>
</table>

<p>
<h3><a name="sec317"/>8.2.3 Debug and Release Builds</h3>

<p><tt>opp_makemake</tt> generates a makefile that can create both release and debug builds.
By default it creates debug version, but it is easy to override this behavior.
Just define the <tt>MODE</tt> variable on the <tt>make</tt> command line.

<pre class="commandline">
$ make MODE=release
</pre>
<p>
If you want to create release builds by default you should use the <tt>--mode</tt> <i>mode</i>
option for <tt>opp_makemake</tt> when generating your makefiles.
<pre class="commandline">
$ opp_makemake --mode release ...
</pre>

<p><h3><a name="sec318"/>8.2.4 Debugging the Makefile</h3>

<p><tt>opp_makemake</tt> generates a makefile that prints only minimal information
during the build process (only the name of the compiled file.) If you want to 
see the full compiler commands executed by the makefile, specify <tt>V=1</tt> as 
a command line parameter for the <tt>make</tt> command.

<pre class="commandline">
$ make V=1
</pre>
<p>

<p><h3><a name="sec319"/>8.2.5 Using External C/C++ Libraries</h3>

<p>If you are using external libraries you should specify the include path for the header files
with the <tt>-I</tt> <i>includedir</i> option. You should specify this option if you are using
anything outside of the source directory tree (except the system and OMNeT++ headers which are
always included automatically)

<p>To define an external library to be linked with, use <tt>-Ldir</tt> to specify
the directory of the external library and <tt>-llibrary</tt> to specify the name of the
external dependency.

<p>
<h3><a name="sec320"/>8.2.6 Building Directory Trees</h3>

<p>It is possible to build a whole source directory tree with a single makefile.
A source tree will generate a single output file (executable or library).
A source directory tree will always have a <tt>Makefile</tt> in its root,
and source files may be placed anywhere in the tree.

<p>To turn on this option, use the <tt>opp_makemake --deep</tt> option.
<tt>opp_makemake</tt> will collect all <tt>.cc</tt> and <tt>.msg</tt> files from
the whole subdirectory tree, and generate a makefile that covers all.
If you need to exclude a specific directory, use the <tt>-X exclude/dir/path</tt>
option. (Multiple <tt>-X</tt> options are accepted.)

<p>An example:

<pre class="commandline">
$ opp_makemake -f --deep -X experimental -X obsolete
</pre>
<p>

<p><h3><a name="sec321"/>8.2.7 Automatic Include Dirs</h3>

<p>If your source tree contains several subdirectories (maybe several levels
deep), it can be annoying to have to specify relative paths for your
header files in your <tt>.cc</tt> files or you should specify the include path
explicitly by the <tt>-I includepath</tt> option. <tt>opp_makemake</tt> has a
command line option, which adds all directories in the current source tree
to the compiler command line. This option is turned on by default.

<p><ul class="note"><b>NOTE</b><br>
You may turn off this mechanism with the <tt>--no-deep-includes</tt> option.
</ul>

<p>The only requirement is that your <tt>#include</tt> statements must unambigously
specify the name of the header file. (i.e. if you have two <tt>common.h</tt>
files, one in subdir1 and the other in subdir2 specify <tt>#include
"subdir1/common.h"</tt> instead of <tt>#include "common.h"</tt>. If you want to
include a directory which is outside of your source directory tree you
always must specify it with the <tt>-I external/include/dir</tt> option.

<p>
<h3><a name="sec322"/>8.2.8 Dependency Handling</h3>

<p>Dependency information is used by the makefile to minimize the time required to
compile and link your project. If your makefile contains up-to date dependency info
-- only files changed since you last compiled your project will be re-compiled or linked.

<p>
<tt>opp_makemake</tt> automatically adds dependencies to the makefile<!--Makefile!dependencies-->.
You can regenerate the dependencies by typing <tt>make depend</tt> any time.
The warnings during the dependency generation process can be safely ignored.

<p>
You may generate and add dependencies to the <tt>makefile</tt> manually using the <tt>opp_makedep</tt>
tool. Use <tt>opp_makedep -</tt>-help to display the supported command line options.

<p><ul class="note"><b>NOTE</b><br>
The dependency generator does not handle conditional macros and includes. Conditionally included header
files are always added to the file's dependency list.
</ul>

<p>
<h3><a name="sec323"/>8.2.9 Out-of-Directory Build</h3>

<p>The build system creates object and executable files in a separate directory, called the
<i>output directory</i>. The structure of the output directory will be the same as your
source directory structure except that it will be placed in the <tt>out/configname</tt> directory.
The <tt>configname</tt> part will mirror your compiler toolchain and build mode settings.
(i.e. The result of a debug build with gcc will be placed in <tt>out/gcc-debug</tt>)

<p>
The location of the generated output file is determined by the -O option.
(The default value is 'out', relative to the project root directory):

<p>
<pre class="commandline">
$ opp_makemake -O ../tmp/obj
</pre>

<p>
<ul class="note"><b>NOTE</b><br>
The project directory is the first ancestor of the current directory which
contains a <tt>.project</tt> file).
</ul>

<p>
<ul class="note"><b>NOTE</b><br>
Source files (i.e. those created by the <tt>opp_msgc</tt> compiler) will be generated in the
source folder rather than in the output folder.
</ul>

<p>
<h3><a name="sec324"/>8.2.10 Building Shared and Static Libraries</h3>

<p>By default the makefile will create an executable file, but it is also
possible to build shared or static libraries. Shared libraries
are usually a better choice.

<p>Use <tt>--make-so</tt> to create shared libraries, and <tt>--make-lib</tt>
to build static libraries. The <tt>--nolink</tt> option completely avoids
the linking step, which is useful for top-level makefiles that only invoke
other makefiles, or if you want to do the linking manually.

<p>

<p>
<h3><a name="sec325"/>8.2.11 Recursive Builds</h3>

<p>
The <tt>--recurse</tt> option enables recursive make; when you build the simulation, make
descends into the subdirectories and runs make in them too.
By default, <tt>--recurse</tt> decends into all subdirectories; the -X directory option
can be used to make it ignore certain subdirectories. This option is especially useful
for top level makefiles.

<p>
The <tt>--recurse</tt> option automatically discovers subdirectories, but this
is sometimes inconvenient. Your source directory tree may contain
parts which need their own hand written <tt>Makefile</tt>. This can happen if
you include source files from an other non OMNeT++ project. With the <tt>-d dir</tt>
or <tt>--subdir dir</tt> option, you can explicitly specify which directories to
recurse into, and also, the directories need not be direct children of the
current directory.

<p>
The recursive make options (<tt>--recurse</tt>, <tt>-d</tt>, <tt>--subdir</tt>)
imply <tt>-X</tt>, that is, the directories recursed into will be
automatically excluded from deep makefiles.

<p>
You can control the order of traversal by adding dependencies into
the <tt>makefrag</tt> file (see <a href="#sec326">[8.2.12]</a>)

<p><ul class="note"><b>NOTE</b><br>
With <tt>-d</tt>, it is also possible to create infinite recursions.
<tt>opp_makemake</tt> cannot detect them, it is your responsibility that
cycles do not occur.
</ul>

<p>
Motivation for recursive builds:
<ul>
 <li>toplevel makefile
 <li>integrating sources that have their own makefile
</ul>

<p>
<h3><a name="sec326"/>8.2.12 Customizing the Makefile</h3>
<a name="sec:makefrag"></a>

<p>It is possible to add rules or otherwise customize the generated makefile
by providing a <tt>makefrag</tt> file. When you run <tt>opp_makemake</tt>, it
will automatically insert <tt>makefrag</tt> into the resulting <tt>Makefile</tt>.
With the <tt>-i</tt> option, you can also name other files to be included into the
<tt>Makefile</tt>.

<p><tt>makefrag</tt> will be inserted after the definitions but before the first
rule, so it is possible to override existing definitions and add new
ones, and also to override the default target.

<p><tt>makefrag</tt> can be useful if some of your source files are generated
from other files (for example, you use generated NED files), or you need
additional targets in your makefile or just simply want to override the
default target in the makefile.

<p>
<h3><a name="sec327"/>8.2.13 Projects with Multiple Source Trees</h3>

<p>In the case of a large project, your source files may be spread across
several directories and your project may generate more than one executable
file (i.e. several shared libraries, examples etc.).

<p>Once you have created your makefiles with <tt>opp_makemake</tt> in
every source directory tree, you will need a toplevel makefile.
The toplevel makefile usually calls only the makefiles
recursively in the source directory trees.

<p>
<h3><a name="sec328"/>8.2.14 A Multi-Directory Example</h3>

<p>For a complex example of using <tt>opp_makemake</tt>, we will show how to create
the makefiles for the Mobility Framework. First, take a look at the
project's directory structure and find the directories that should be used as
source trees:

<pre class="verbatim">
mobility-framework
    bitmaps
    contrib &lt;-- source tree (build libmfcontrib.so from this dir)
    core &lt;-- source tree (build libmfcore.so from this dir)
    docs
    network
    template
    testSuite &lt;-- source tree (build testSuite executable from this dir)
</pre>
<p>
Additionally, there are dependencies between these output files: <tt>mfcontrib</tt>
requires <tt>mfcore</tt> and <tt>testSuite</tt> requires <tt>mfcontrib</tt> (and indirectly
<tt>mfcore</tt>).

<p>First, we create the makefile for the core directory. The makefile will build
a shared lib from all .cc files in the <tt>core</tt> subtree, and will name it <tt>mfcore</tt>):

<pre class="commandline">
$ cd core && opp_makemake -f --deep --make-so -o mfcore -O out
</pre>
<p>
The <tt>contrib</tt> directory depends on <tt>mfcore</tt> so we use the <tt>-L</tt> and <tt>-l</tt> options
to specify the library we should link with. Note that we must also add
the include directories manually from the <tt>core</tt> source tree, because autodiscovery works only
in the same source tree:

<pre class="commandline">
$ cd contrib && opp_makemake -f --deep --make-so -o mfcontrib -O out \\
  -I../core/basicModules -I../core/utils -L../out/$(CONFIGNAME)/core -lmfcore
</pre>
<p>
The <tt>testSuite</tt> will be created as an executable file which depends on both
<tt>mfcontrib</tt> and <tt>mfcore</tt>.

<pre class="commandline">
$ cd testSuite && opp_makemake -f --deep -o testSuite -O out
    -I../core/utils -I../core/basicModules -I../contrib/utils \\
    -I../contrib/applLayer -L../out/$(CONFIGNAME)/contrib -lmfcontrib
</pre>
<p>
Now let us specify the dependencies between the above directories. 
Add the lines below to the <tt>makefrag</tt> file in the project directory root.

<pre class="filelisting">
contrib_dir: core_dir
testSuite_dir: contrib_dir
</pre>
<p>
Now the last step is to create a top-level makefile in the root of the project that
calls the previously created makefiles in the correct order. We will use the
<tt>--nolink</tt> option, exclude every subdirectory from the build (<tt>-X.</tt>), and explicitly call
the above makefiles using <tt>-d dirname</tt>. <tt>opp_makemake</tt> will automatically include
the above created <tt>makefrag</tt> file.

<pre class="commandline">
$ opp_makemake -f --nolink -O out -d testSuite -d core -d contrib -X.
</pre>
<p>

<p>

<hr class='pgbr'><h1><a name="sec329"/>9 Configuring Simulations</h1>
<a name="cha:config-sim"></a>

<p><h2><a name="sec330"/>9.1 The Configuration File</h2>

<p>Configuration and input data for the simulation are in
a configuration file usually called <tt>omnetpp.ini</tt>.

<p><h3><a name="sec331"/>9.1.1 An Example</h3>

<p>For a start, let us see a simple <tt>omnetpp.ini</tt> file which
can be used to run the Fifo example simulation.

<pre class="inifile">
[General]
network = FifoNet
sim-time-limit = 100h
cpu-time-limit = 300s
#debug-on-errors = true
#record-eventlog = true

[Config Fifo1]
description = "low job arrival rate"
**.gen.sendIaTime = exponential(0.2s)
**.gen.msgLength = 100b
**.fifo.bitsPerSec = 1000bps

[Config Fifo2]
description = "high job arrival rate"
**.gen.sendIaTime = exponential(0.01s)
**.gen.msgLength = 10b
**.fifo.bitsPerSec = 1000bps
</pre>
<p>
The file is grouped into <i>sections</i> named <tt>[General]</tt>, <tt>[Config Fifo1]</tt>
and <tt>[Config Fifo2]</tt>, each one containing several <i>entries</i>.

<p>
<h3><a name="sec332"/>9.1.2 File Syntax</h3>

<p>An OMNeT++ configuration file is an ASCII text file, but non-ASCII
characters are permitted in comments and string literals. This allows for
using encodings that are a superset of ASCII, for example ISO 8859-1 and
UTF-8. There is no limit on the file size or on the line length.

<p>Comments may be placed at the end of any line after a hash mark, &#8220;#&#8221;.
Comments extend to the end of the line, and are ignored during processing.
Blank lines are also allowed and ignored.

<p>The file is line oriented, and consists of <i>section heading lines</i>,
<i>key-value lines</i>, and <i>directive lines</i>:

<p><ol>
<li> <i>Section heading lines</i> contain a section name enclosed in square brackets.
<li> <i>Key-value lines</i> have the <i>&lt;key&gt;=&lt;value&gt;</i> syntax; spaces
      are allowed (but not required) on both sides of the equal sign.
      If a line contains more than one equal sign, the leftmost one is taken
      as the key-value separator.
<li> Currently there is only one kind of directive line, <i>include</i>. An
      include line starts with the <tt>include</tt> word, followed by the name of
      the file to be included.
</ol>

<p>Key-value lines may not occur above the first section heading line (except
in included files, see later).

<p>Keys may be further classified based on syntax alone:

<p><ol>
<li> Keys that do not contain dots represent global or per-run <i>configuration options</i>.
<li> If a key contains a dot, its last component (substring after the last dot)
      is considered. If the last component contains a hyphen or is equal to
      <tt>typename</tt>, the key represents a <i>per-object configuration option</i>.
<li> Otherwise, the key represents a <i>parameter assignment</i>. Thus, parameter
      assignment keys contain a dot, and no hyphen after the last dot.
</ol>

<p>Long lines can be broken up using the backslash notation: if the last
character of a line is &#8220;\&#8221;, it will be merged with the next
line.

<p>An example:

<pre class="inifile">
# This is a comment line
[General]                       # section heading
network = Foo                   # configuration option
debug-on-errors = false         # another configuration option

**.vector-recording = false     # per-object configuration option
**.app*.typename = "HttpClient" # per-object configuration option

**.app*.interval = 3s           # parameter value
**.app*.requestURL = "http://www.example.com/this-is-a-very-very-very-very\
-very-long-url?q=123456789"     # a two-line parameter value
</pre>
<p>
<h3><a name="sec333"/>9.1.3 File Inclusion</h3>

<p>OMNeT++ supports including an ini file in another<!--ini file!file inclusion-->,
via the <tt>include</tt> keyword. This feature allows you to partition large ini
files into logical units, fixed and varying part, etc.

<p>An example:

<pre class="inifile">
# omnetpp.ini
...
include params1.ini
include params2.ini
include ../common/config.ini
...
</pre>
<p>
You can also include files from other directories. If the included ini file
further includes others, their path names will be understood as relative to
the location of the file which contains the reference, rather than relative
to the current working directory of the simulation.

<p>This rule also applies to other file names occurring in ini files (such as
the <b><tt>load-libs</tt></b>, <b><tt>output-vector-file</tt></b>,
<b><tt>output-scalar-file</tt></b>, etc. options, and <tt>xmldoc()</tt> module
parameter values.)

<p>In included files, it is allowed to have key-value lines without first having a
section heading line. File inclusion is conceptually handled as text
substitution, except that a section heading in an included file will not
change the current section the main file. The following example illustrates
the rules:

<pre class="inifile">
# incl.ini
foo1 = 1          # no preceding section heading: these lines will go into
foo2 = 2          # whichever section the file is included into
[Config Bar]
bar = 3           # this will always go to into [Config Bar]
</pre>
<p>
<pre class="inifile">
# omnetpp.ini
[General]
include incl.ini  # adds foo1/foo2 to [General], and defines [Config Bar] w/ bar
baz1 = 4          # include files don't change the current section, so these
baz2 = 4          # lines still belong to [General]
</pre>

<p><ul class="note"><b>NOTE</b><br>
The concept of file inclusion implies that include files may not make sense
on their own. Thus, when you open an included ini file in an specialized ini file
editor, the file contents may be flagged with errors and warnings. These
errors/warnings disappear when the file is viewed as part of its main file.
</ul>

<p>
<h2><a name="sec334"/>9.2 Sections</h2>
<a name="sec:ch-config-sim:general-section"></a>

<p>An ini file may contain a <tt>[General]</tt> section and several <tt>[Config &lt;configname&gt;]</tt>
sections. The order of the sections doesn't matter.

<p><h3><a name="sec335"/>9.2.1 The [General] Section</h3>

<p>The most commonly used options of the <tt>[General]</tt> section are the
following.

<p><ul>
  <li>The <b><tt>network</tt></b> option selects the model to be set up and run.
  <li>The length of the simulation can be set with the
    <b><tt>sim-time-limit</tt></b> and the <b><tt>cpu-time-limit</tt></b> options (the
    usual time units such as ms, s, m, h, etc. can be used).
</ul>

<p>Note that the NED files loaded by the simulation may contain several
networks, and any of them may be specified in the <b><tt>network</tt></b>
option.

<p>
<h3><a name="sec336"/>9.2.2 Named Configurations</h3>

<p>Named configurations are sections of the form <tt>[Config &lt;configname&gt;]</tt>, where
<i>&lt;configname&gt;</i> is by convention a camel-case string that starts with a capital letter:
<tt>Config1</tt>, <tt>WirelessPing</tt>, <tt>OverloadedFifo</tt>, etc. For example,
<tt>omnetpp.ini</tt> for an Aloha simulation might have the following skeleton:

<pre class="inifile">
[General]
...
[Config PureAloha]
...
[Config SlottedAloha1]
...
[Config SlottedAloha2]
...
</pre>
<p>
Some configuration options (such as user interface selection) are only
accepted in the <tt>[General]</tt> section, but most of them can go into <tt>Config</tt>
sections as well.

<p>When you run a simulation, you need to select one of the configurations
to be activated. In Cmdenv, this is done with the <tt>-c</tt> command-line option:

<pre class="commandline">
$ aloha -c PureAloha
</pre>
<p>
The simulation will then use the contents of the <tt>[Config PureAloha]</tt>
section to set up the simulation. (Tkenv, of course, lets you select
the configuration from a dialog.)

<p>
<h3><a name="sec337"/>9.2.3 Section Inheritance</h3>

<p>Actually, when you activate the PureAloha configuration, the contents of
the <tt>[General]</tt> section will also be taken into account: if some
configuration option or parameter value is not found in <tt>[Config PureAloha]</tt>,
then the search will continue in the <tt>[General]</tt> section. In
other words, lookups in <tt>[Config PureAloha]</tt> will fall back to <tt>[General]</tt>.
The <tt>[General]</tt> section itself is optional; when it is absent, it is
treated like an empty <tt>[General]</tt> section.

<p>All named configurations fall back to <tt>[General]</tt> by default. However, for
each configuration it is possible to specify the fall-back section or a list of
fallback sections explicitly, using the <b><tt>extends</tt></b> key. Consider the
following ini file skeleton:

<pre class="inifile">
[General]
...
[Config SlottedAlohaBase]
...
[Config LowTrafficSettings]
...
[Config HighTrafficSettings]
...

[Config SlottedAloha1]
extends = SlottedAlohaBase, LowTrafficSettings
...
[Config SlottedAloha2]
extends = SlottedAlohaBase, HighTrafficSettings
...
[Config SlottedAloha2a]
extends = SlottedAloha2
...
[Config SlottedAloha2b]
extends = SlottedAloha2
...
</pre>
<p>

<p>If you activate the <tt>SlottedAloha2b</tt> configuration, lookups will consider
sections in the following order (this is also called the
<i>section fallback chain</i>): <tt>SlottedAloha2b</tt>,
<tt>SlottedAloha2</tt>, <tt>SlottedAlohaBase</tt>, <tt>HighTrafficSettings</tt>,
<tt>General</tt>.

<p>The effect is the same as if the contents of the sections
SlottedAloha2b, SlottedAloha2, SlottedAlohaBase, HighTrafficSettings and
General were copied together into one section, one after another,
<tt>[Config SlottedAloha2b]</tt> being at the top, and <tt>[General]</tt>
at the bottom. Lookups always start at the top, and stop at the first
matching entry.

<p>The order of the sections in the <i>fallback chain</i> is computed
using the <i>C3 linearization algorithm</i> ([<a href="#bib-Barrett1996">Barrett1996</a>]):

<p>The <i>fallback chain</i> of a configuration <tt>A</tt> is
<ul>
  <li>if <tt>A</tt> does not have an <b><tt>extends</tt></b> key then
        <tt>A</tt>, <tt>General</tt>
  <li>otherwise the merge of the configurations enumerated in
        the <b><tt>extends</tt></b> key, and all of their
        <i>fallback section chains</i>.
        The merge is <i>monotonic</i>: if some configuration <tt>X</tt>
        precedes configuration <tt>Y</tt> in one of the input chains,
        it will precede it in the output chain too. 
</ul>

<p>The <i>section fallback chain</i> can be printed by the <tt>-X</tt> option
of the command line of the simulation program:

<pre class="commandline">
$ aloha -X SlottedAloha2b
`\opp` Discrete Event Simulation
...
Config SlottedAloha2b
Config SlottedAloha2
Config SlottedAlohaBase
Config HighTrafficSettings
General
</pre>
<p>
The <i>section fallback</i> concept is similar to multiple inheritance in
object-oriented languages, and benefits are similar too; you can factor out
the common parts of several configurations into a &#8220;base&#8221; configuration,
and additionally you can reuse existing configurations (as opposed to
copying them) by using them as a base. In practice you will often have
&#8220;abstract&#8221; configurations too (in the C++/Java sense), which assign only
a subset of parameters and leave the others open, to be assigned in derived
configurations.

<p>If you are experimenting a lot with different parameter settings of a
simulation model, these techniques will make it much easier to manage
ini files.

<p><h2><a name="sec338"/>9.3 Assigning Module Parameters</h2>
<a name="sec:ch-config-sim:parameter-settings"></a>

<p>Simulations get input via module parameters, which can be assigned a
value in NED files or in <tt>omnetpp.ini</tt> -- in this order. Since parameters
assigned in NED files cannot be overridden in <tt>omnetpp.ini</tt>, one can
think about them as being &#8220;hardcoded&#8221;. In contrast, it is easier
and more flexible to maintain module parameter settings in <tt>omnetpp.ini</tt>.

<p>In <tt>omnetpp.ini</tt>, module parameters are referred to by their full paths
(hierarchical names). This name consists of the dot-separated list of
the module names (from the top-level module down to the module containing
the parameter), plus the parameter name
(see section <a href="#sec264">[7.1.5]</a>).

<p>An example <tt>omnetpp.ini</tt> which sets the <tt>numHosts</tt> parameter of
the toplevel module and the <tt>transactionsPerSecond</tt> parameter of the
<tt>server</tt> module:

<pre class="inifile">
[General]
Network.numHosts = 15
Network.server.transactionsPerSecond = 100
</pre>
<p>
Typename pattern assignments are also accepted:

<pre class="inifile">
[General]
Network.host[*].app.typename = "PingApp"
</pre>
<p>

<p><h3><a name="sec339"/>9.3.1 Using Wildcard Patterns</h3>
<a name="sec:ch-config-sim:wildcards"></a>

<p>Models can have a large number of parameters to be configured, and it would
be tedious to set them one-by-one in <tt>omnetpp.ini</tt>. OMNeT++ supports
<i>wildcard patterns</i> which allow for setting several model parameters
at once. The same pattern syntax is used for per-object configuration options;
for example <tt>&lt;object-path-pattern&gt;.record-scalar</tt>, or <tt>&lt;module-path-pattern&gt;.rng-&lt;N&gt;</tt>.

<p>The pattern syntax is a variation on Unix <i>glob</i>-style
patterns. The most apparent differences to globbing rules are the
distinction between <tt>*</tt> and <tt>**</tt>, and that character ranges should
be written with curly braces instead of square brackets; that is,
<i>any-letter</i> is expressed as <tt>{a-zA-Z}</tt> and not as
<tt>[a-zA-Z]</tt>, because square brackets are reserved for the notation of
module vector indices.

<p>Pattern syntax:

<p><ul>
  <li> <tt>?</tt> : matches any character except dot (.)
  <li> <tt>*</tt> : matches zero or more characters except dot (.)
  <li> <tt>**</tt> : matches zero or more characters (any character)
  <li> <tt>{a-f}</tt> : <i>set</i>: matches a character in the range a-f
  <li> <tt>{^a-f}</tt>: <i>negated set</i>: matches a character
    NOT in the range a-f
  <li> <tt>{38..150}</tt> : <i>numeric range</i>: any number (i.e. sequence of digits)
    in the range 38..150, inclusive; both limits are optional
  <li> <tt>[38..150]</tt> : <i>index range</i>: any number in square brackets in the
    range 38..150, inclusive; both limits are optional
  <li> backslash (\) : takes away the special meaning of the
    subsequent character
</ul>

<p><p class="subheading">Precedence</p>

<p>If you use wildcards, the order of entries is important; if a parameter
name matches several wildcard-patterns, the <i>first</i> matching occurrence
is used. This means that you need to list specific settings first, and
more general ones later. Catch-all settings should come last.

<p>An example ini file:

<pre class="inifile">
[General]
*.host[0].waitTime = 5ms   # specifics come first
*.host[3].waitTime = 6ms
*.host[*].waitTime = 10ms  # catch-all comes last
</pre>
<p>

<p><p class="subheading">Asterisk vs Double Asterisk</p>

<p>The <tt>*</tt> wildcard is for matching a single module or parameter name in the
path name, while <tt>**</tt> can be used to match several components in the path.
For example, <tt>**.queue*.bufSize</tt> matches the <tt>bufSize</tt> parameter of any module
whose name begins with <tt>queue</tt> in the model, while <tt>*.queue*.bufSize</tt>
or <tt>net.queue*.bufSize</tt> selects only queues immediately on network level.
Also note that <tt>**.queue**.bufSize</tt> would match <tt>net.queue1.foo.bar.bufSize</tt>
as well!

<p><p class="subheading">Sets, Negated Sets</p>

<p>Sets and negated sets can contain several character ranges and also
enumeration of characters. For example, <tt>{_a-zA-Z0-9}</tt> matches any letter
or digit, plus the underscore; <tt>{xyzc-f}</tt> matches any of the characters
x, y, z, c, d, e, f.
To include '-' in the set, put it at a position where it cannot be
interpreted as character range, for example: <tt>{a-z-}</tt> or <tt>{-a-z}</tt>.
If you want to include '}' in the set, it must be the first
character: <tt>{}a-z}</tt>, or as a negated set: <tt>{^}a-z}</tt>.
A backslash is always taken as a literal backslash (and not as an escape character)
within set definitions.

<p>
<p class="subheading">Numeric Ranges and Index Ranges</p>

<p>Only nonnegative integers can be matched.  The start or the end of the range
(or both) can be omitted: <tt>{10..}</tt>, <tt>{..99}</tt> or <tt>{..}</tt>
are valid numeric ranges (the last one matches any number).
The specification must use exactly two dots.
Caveat: <tt>*{17..19}</tt> will match <tt>a17</tt>, <tt>117</tt> and <tt>963217</tt> as well,
because the <tt>*</tt> can also match digits!

<p>An example for numeric ranges:

<pre class="inifile">
[General]
*.*.queue[3..5].bufSize = 10
*.*.queue[12..].bufSize = 18
*.*.queue[*].bufSize = 6  # this will only affect queues 0,1,2 and 6..11
</pre>
<p>

<p><h3><a name="sec340"/>9.3.2 Using the Default Values</h3>

<p>It is also possible to utilize the default values specified in the NED files.
The <i>&lt;parameter-fullpath&gt;</i><tt>=default</tt> setting assigns
the default value to a parameter if it has one.

<p>The <i>&lt;parameter-fullpath&gt;</i><tt>=ask</tt> setting will try to get the parameter
value interactively from the user.

<p>If a parameter was not set but has a default value, that value will be
assigned. This is like having a <tt>**=default</tt> line at the
bottom of the <tt>[General]</tt> section.

<p>If a parameter was not set and has no default value, that will either
cause an error or will be interactively prompted for, depending
on the particular user interface.

<p><ul class="note"><b>NOTE</b><br>
In Cmdenv you must explicitly enable the interactive mode with the
<tt>--cmdenv-interactive=true</tt> option otherwise you will get an error
when running the simulation.
</ul>

<p>More precisely, parameter resolution takes place as follows:

<p><ol>
<li> If the parameter is assigned in NED, it cannot be overridden in the
    configuration. The value is applied and the process finishes.
<li> If the first match is a value line (matches
    <i>&lt;parameter-fullpath&gt;</i><tt>=</tt><i>&lt;value&gt;</i>), the value is
    applied and the process finishes.
<li> If the first match is a <i>&lt;parameter-fullpath&gt;</i><tt>=default</tt> line,
    the default value is applied and the process finishes.
<li> If the first match is a <i>&lt;parameter-fullpath&gt;</i><tt>=ask</tt> line,
    the parameter will be asked from the user interactively (UI dependent).
<li> If there was no match and the parameter has a default value, it is applied
    and the process finishes.
<li> Otherwise the parameter is declared unassigned, and handled accordingly
    by the user interface. It may be reported as an error, or may be
    asked from the user interactively.
</ol>

<p>
<h2><a name="sec341"/>9.4 Parameter Studies</h2>

<p>It is quite common in simulation studies that the simulation model is
run several times with different parameter settings, and the results
are analyzed in relation to the input parameters. OMNeT++ 3.x had no
direct support for batch runs, and users had to resort to writing shell
(or Python, Ruby, etc.) scripts that iterated over the required
parameter space, to generate a (partial) ini file and run the
simulation program in each iteration.

<p>OMNeT++ 4.x largely automates this process, and eliminates the need for
writing batch execution scripts. It is the ini file where the user can
specify iterations over various parameter settings.
Here is an example:

<pre class="inifile">
[Config AlohaStudy]
*.numHosts = ${1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential(${0.2, 0.4, 0.6}s)
</pre>
<p>
This parameter study expands to 8*3 = 24 simulation runs, where the number of
hosts iterates over the numbers 1, 2, 5, 10, 20, 30, 40, 50, and for
each host count three simulation runs will be done, with the generation
interval being exponential(0.2), exponential(0.4), and
exponential(0.6).

<p>How does it work? First of all, Cmdenv with the <tt>-x</tt> option will tell you how many
simulation runs a given section expands to. (You will of course use Cmdenv for batch runs,
not Tkenv.)

<pre class="commandline">
$ aloha -u Cmdenv -x AlohaStudy

`\opp` Discrete Event Simulation
...
Config: AlohaStudy
Number of runs: 24
</pre>
<p>
If you add the <tt>-g</tt> option, the program will also print out the values
of the iteration variables for each run. (Use <tt>-G</tt> for even more info.)
Note that the parameter study actually maps to nested loops, with the last
<tt>${...}</tt> becoming the innermost loop. The iteration variables are
just named <tt>$0</tt> and <tt>$1</tt> -- we'll see that it is possible to give
meaningful names to them. Please ignore the <tt>$repetition=0</tt> part in
the printout for now.

<pre class="commandline">
$ aloha -u Cmdenv -x AlohaStudy -g
`\opp` Discrete Event Simulation
...
Config: AlohaStudy
Number of runs: 24
Run 0: $0=1, $1=0.2, $repetition=0
Run 1: $0=1, $1=0.4, $repetition=0
Run 2: $0=1, $1=0.6, $repetition=0
Run 3: $0=2, $1=0.2, $repetition=0
Run 4: $0=2, $1=0.4, $repetition=0
Run 5: $0=2, $1=0.6, $repetition=0
Run 6: $0=5, $1=0.2, $repetition=0
Run 7: $0=5, $1=0.4, $repetition=0
...
Run 19: $0=40, $1=0.4, $repetition=0
Run 20: $0=40, $1=0.6, $repetition=0
Run 21: $0=50, $1=0.2, $repetition=0
Run 22: $0=50, $1=0.4, $repetition=0
Run 23: $0=50, $1=0.6, $repetition=0
</pre>
<p>
Any of these runs can be executed by passing the <tt>-r &lt;runnumber&gt;</tt>
option to Cmdenv. So, the task is now to run the simulation program 24
times, with <tt>-r</tt> running from 0 through 23:

<pre class="commandline">
$ aloha -u Cmdenv -c AlohaStudy -r 0
$ aloha -u Cmdenv -c AlohaStudy -r 1
$ aloha -u Cmdenv -c AlohaStudy -r 2
...
$ aloha -u Cmdenv -c AlohaStudy -r 23
</pre>
<p>
This batch can be executed either from the OMNeT++ IDE (where you are
prompted to pick an executable and an ini file, choose the configuration
from a list, and just click Run), or using a little command-line
batch execution tool (<tt>opp_runall</tt>) supplied with OMNeT++.

<p>Actually, it is also possible to get Cmdenv execute all runs in one go,
by simply omitting the <tt>-r</tt> option.

<pre class="commandline">
$ aloha -u Cmdenv -c AlohaStudy

`\opp` Discrete Event Simulation
Preparing for running configuration AlohaStudy, run #0...
...
Preparing for running configuration AlohaStudy, run #1...
...
...
Preparing for running configuration AlohaStudy, run #23...
</pre>
<p>

<p>However, this approach is not recommended, because it is more
susceptible to C++ programming errors in the model. (For example, if
any of the runs crashes, the whole batch is terminated -- which may
not be what the user wants.)

<p>
<h3><a name="sec342"/>9.4.1 Iterations</h3>

<p>Let us have a look at the example ini file in the previous section again:

<pre class="inifile">
[Config AlohaStudy]
*.numHosts = ${1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential( ${0.2, 0.4, 0.6}s )
</pre>
<p>
The <tt>${...}</tt> syntax specifies an iteration. It is sort of a macro: at
each run, the whole <tt>${...}</tt> string is textually replaced with the
current iteration value. The values to iterate over do not need to be
numbers (unless you want to use the <i>"a..b"</i> or
<i>"a..b step c"</i> syntax), and the
substitution takes place even inside string constants. So, the
following examples are all valid (note that textual substitution is
used):

<p><pre class="verbatim">
*.param = 1 + ${1e-6, 1/3, sin(0.5)}
    ==&gt; *.param = 1 + 1e-6
        *.param = 1 + 1/3
        *.param = 1 + sin(0.5)
*.greeting = "We will simulate ${1,2,5} host(s)."
    ==&gt; *.greeting = "We will simulate 1 host(s)."
        *.greeting = "We will simulate 2 host(s)."
        *.greeting = "We will simulate 5 host(s)."
</pre>

<p>To write a literal <tt>${..}</tt> inside a string constant, quote
the left brace with a backslash: <tt>$\{..}</tt>.

<p><ul class="note"><b>NOTE</b><br>
Inside <tt>${..}</tt>, the values are separated with commas. However,
not every comma is taken as a value separator because the parser
tries to be smart about what you meant. Commas inside (nested) parentheses,
brackets or curly braces are ignored so that <tt>${uniform(0,3)}</tt> is
parsed as one value and not as <tt>uniform(0</tt> plus <tt>3)</tt>. Commas, curly
braces and other charachers inside double-quoted string literals are
also ignored, so <tt>${"Hello, world"}</tt> yields a single <tt>"Hello, world"</tt>
string and not <tt>"Hello</tt> plus <tt>world"</tt>. It is assumed that string literals
use backslash as an escape characher, like in C/C++ and NED.

<p>If you want to have a literal comma or close-brace inside a value, you need
to escape it with a backslash: <tt>${foo\,bar\}baz}</tt>
will parse as a single value, <tt>foo,bar}baz</tt>. Backslashes themselves must be doubled.
As the above examples illustrate, the parser removes one level of backslashes,
except inside string literals where they are left intact.
</ul>

<p>
<h3><a name="sec343"/>9.4.2 Named Iteration Variables</h3>

<p>You can assign names to iteration variables, which has the advantage
that you will see meaningful names instead of <tt>$0</tt> and
<tt>$1</tt> in the Cmdenv output, and also lets you refer to the variables at
more than one place in the ini file. The syntax is
<tt>${&lt;varname&gt;=&lt;iteration&gt;}</tt>, and variables can be referred to simply as
<tt>${&lt;varname&gt;}</tt>:

<pre class="inifile">
[Config Aloha]
*.numHosts = ${N=1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential( ${mean=0.2, 0.4, 0.6}s )
**.greeting = "There are ${N} hosts"
</pre>
<p>
The scope of the variable name is the section that defines it, plus
sections based on that section (via <b><tt>extends</tt></b>).

<p><p class="subheading">Referencing Other Iteration Variables</p>

<p>Iterations may refer to other iteration variables, using the dollar syntax
(<tt>$var</tt>) or the dollar-brace syntax (<tt>${var}</tt>).

<p>This feature makes it possible to have loops where the inner iteration range
depends on the outer one. An example:

<pre class="inifile">
**.foo = ${i=1..10}  # outer loop
**.bar = ${j=1..$i}  # inner loop depends on $i
</pre>
<p>
When needed, the default top-down nesting order of iteration loops is
modified (loops are reordered) to ensure that expressions only refer to
more outer loop variables, but not to inner ones. When this is not
possible, an error is generated with the &#8220;circular dependency&#8221; message.

<p>For instance, in the following example the loops will be nested in
<i>k - i - j</i> order, <i>k</i> being the outermost and <i>j</i>
the innermost loop:

<pre class="inifile">
**.foo = ${i=0..$k}   # must be inner to $k
**.bar = ${j=$i..$k}  # must be inner to both $i and $k
**.baz = ${k=1..10}   # may be the outermost loop
</pre>
<p>
And the next example will stop with an error because there is no &#8220;good&#8221;
ordering:

<pre class="inifile">
**.foo = ${i=0..$j}
**.bar = ${j=0..$k}
**.baz = ${k=0..$i} # --&gt; error: circular references
</pre>
<p>
Variables are substituted <i>textually</i>, and the result is normally
<i>not</i> evaluated as an arithmetic expression.  The result of the
substitution is only evaluated where needed, namely in the three arguments
of iteration ranges (<i>from</i>, <i>to</i>, <i>step</i>), and in the
value of the <b><tt>constraint</tt></b> configuration option.

<p>To illustrate textual substitution, consider the following contorted example:

<pre class="inifile">
**.foo = ${i=1..3, 1s+, -}001s
</pre>
<p>
Here, the <tt>foo</tt> NED parameter will receiving the following values in subsequent runs:
<tt>1001s</tt>, <tt>2001s</tt>, <tt>3001s</tt>, <tt>1s+001s</tt>, <tt>-001s</tt>.

<p><ul class="caution"><b>CAUTION</b><br>
Due to textual substitution, variables in arithmetic expressions should be
protected with parentheses -- just like in C/C++ function-style macros.
Consider the following example:

<pre class="inifile">
**.foo = ${i=10}
**.bar = ${j=$i+5}
**.baz = ${k=2*$j}   # bogus! $j should be written as ($j)
constraint = $i+50 &lt; 2*$j  # ditto: should use ($i) and ($j)
</pre>
<p>
Here, the <tt>baz</tt> parameter will receive the string <tt>2*10+5</tt> after
the substitutions and hence evaluate to <i>25</i> instead of the correct
<i>2*(10+5)=30</i>; the constraint expression is similarly wrong. Mind the parens!
</ul>

<p>Substitution also works inside string constants within iterations (<tt>${..}</tt>).

<pre class="inifile">
**.foo = "${i=Jo}"  # -&gt; Jo
**.bar = ${"Hi $i", "Hi ${i}hn"}  # -&gt; Hi Jo /John
</pre>
<p>
However, outside iterations the plain dollar syntax is not understood, only
the dollar-brace syntax is:

<pre class="inifile">
**.foo = "${i=Day}"
**.baz = "Good $i"     # -&gt; remains "Good $i"
**.baz = "Good ${i}"   # -&gt; becomes "Good Day"
</pre>
<p>
<ul class="rationale"><b>Rationale</b><br>
The text substitution model was chosen for greater flexibility as well as
the ability to produce more consistent semantics. The advantages outweigh
the inconvenience of having to parenthesize variable references in
arithmetic expressions.
</ul>

<p>
<h3><a name="sec344"/>9.4.3 Parallel Iteration</h3>

<p>The body of an iteration may end in an exclamation mark followed by the
name of another iteration variable. This syntax denotes a <i>parallel
iteration</i>. A parallel iteration does not define a loop of its own, but
rather, the sequence is advanced in lockstep with the variable after the
&#8220;!&#8221;. In other words, the &#8220;!&#8221; syntax chooses the <i>kth</i> value from
the iteration, where <i>k</i> is the position (iteration count) of the
iteration variable after the &#8220;!&#8221;.

<p>An example:

<pre class="inifile">
**.plan =     ${plan= "A", "B", "C", "D"}
**.numHosts = ${hosts= 10,  20,  50, 100 ! plan}
**.load =     ${load= 0.2, 0.3, 0.3, 0.4 ! plan}
</pre>
<p>
In the above example, the only loop is defined by the first line, the <tt>plan</tt>
variable. The other two iterations, <tt>hosts</tt> and <tt>load</tt> just follow it;
for the first value of <tt>plan</tt> the first values of <tt>host</tt> and <tt>load</tt>
are selected, and so on.

<p>

<p><h3><a name="sec345"/>9.4.4 Predefined Variables, Run ID</h3>

<p>There are a number of predefined variables: <tt>${configname}</tt> and
<tt>${runnumber}</tt> with the obvious meanings; <tt>${network}</tt> is the
name of the network that is simulated; <tt>${processid}</tt> and
<tt>${datetime}</tt> expand to the OS process id of the simulation and the
time it was started; and there are some more: <tt>${runid},</tt>
<tt>${iterationvars}</tt> and <tt>${repetition}.</tt>

<p><tt>${runid}</tt> holds the <i>run ID</i>. When a simulation is run, a a
run ID is generated that uniquely identifies that instance of the
simulation: if you run the same thing again, it will get a different run
ID. Run ID is a concatenation of several variables like
<tt>${configname},</tt> <tt>${runnumber},</tt> <tt>${datetime}</tt> and
<tt>${processid}.</tt> This yields an identifier that is unique &#8220;enough&#8221;
for all practical purposes, yet it is meaningful for humans. The run ID is
recorded into result files written during the simulation, and can be used
to match vectors and scalars written by the same simulation run.

<p>
<h3><a name="sec346"/>9.4.5 Constraint Expression</h3>

<p>In cases when not all combinations of the iteration variables make sense
or need to be simulated, it is possible to specify an additional
constraint expression. This expression is interpreted as a conditional
(an "if" statement) within the innermost
loop, and it must evaluate to <tt>true</tt> for
the variable combination to generate a run. The expression should be
given with the <b><tt>constraint</tt></b> configuration option. An example:

<pre class="inifile">
*.numNodes = ${n=10..100 step 10}
**.numNeighbors = ${m=2..10 step 2}
constraint = ($m) &lt;= sqrt($n)  # note: parens needed due to textual substitution
</pre>
<p>
The expression syntax supports most C language operators including boolean,
conditional and binary shift operations, and most <tt>&lt;math.h&gt;</tt> functions;
data types are boolean, double and string. The expression must evaluate to
a boolean.

<p><ul class="note"><b>NOTE</b><br>
Remember that variables are substituted textually into the expresssion, so
they must be protected with parentheses to preserve evaluation order.
</ul>

<p>
<h3><a name="sec347"/>9.4.6 Repeating Runs with Different Seeds</h3>

<p>It is directly supported to perform several runs with the same
parameters but different random number seeds. There are two
configuration options related to this: <b><tt>repeat</tt></b> and <b><tt>seed-set</tt></b>.
The first one simply specifies how many times a run needs to be repeated. For
example,

<pre class="inifile">
repeat = 10
</pre>
<p>
causes every combination of iteration variables to be repeated 10 times,
and the <tt>${repetition}</tt> predefined variable holds the loop counter.
Indeed, <tt>repeat=10</tt> is equivalent to adding <tt>${repetition=0..9}</tt>
to the ini file. The <tt>${repetition}</tt> loop always becomes the innermost loop.

<p>The <b><tt>seed-set</tt></b> configuration key affects seed selection. Every
simulation uses one or more random number generators (as configured by
the <b><tt>num-rngs</tt></b> key), for which the simulation kernel can automatically
generate seeds. The first simulation run may use one set of seeds (seed
set 0), the second run may use a second set (seed set 1), and so on.
Each set contains as many seeds as there are RNGs configured. All
automatic seeds generate random number sequences that are far apart in
the RNG's cycle, so they will never overlap during
simulations.

<p><ul class="note"><b>NOTE</b><br>
Mersenne Twister, the default RNG of OMNeT++ has a cycle length of
<i>2<sup>19937</sup></i>, which is more than enough for any conceivable purpose.
</ul>

<p>The <b><tt>seed-set</tt></b> key tells the simulation kernel which seed set to use.
It can be set to a concrete number (such as <tt>seed-set=0</tt>), but it
usually does not make sense as it would cause every simulation to run
with exactly the same seeds. It is more practical to set it to either
<tt>${runnumber}</tt> or to <tt>${repetition}</tt>. The default setting is
<tt>${runnumber}</tt>:

<pre class="inifile">
seed-set = ${runnumber}   # this is the default
</pre>
<p>
This causes every simulation run to execute with a unique seed set. The
second option is:

<pre class="inifile">
seed-set = ${repetition}
</pre>
<p>
where all <tt>$repetition=0</tt> runs will use the same seeds (seed set 0), all
<tt>$repetition=1</tt> runs use another seed set, <tt>$repetition=2</tt> a third seed
set, etc.

<p>To perform runs with manually selected seed sets, you can just define an
iteration for the <b><tt>seed-set</tt></b> key:

<pre class="inifile">
seed-set = ${5,6,8..11}
</pre>
<p>
In this case, the <b><tt>repeat</tt></b> key should be left out, as <b><tt>seed-set</tt></b>
already defines an iteration and there is no need for an extra loop.

<p>It is of course also possible to manually specify individual seeds for
simulations. The parallel iteration feature is very convenient here:

<pre class="inifile">
repeat = 4
seed-1-mt = ${53542, 45732, 47853, 33434 ! repetition}
seed-2-mt = ${75335, 35463, 24674, 56673 ! repetition}
seed-3-mt = ${34542, 67563, 96433, 23567 ! repetition}
</pre>
<p>
The meaning of the above is this: in the first repetition, the first
column of seeds is chosen, for the second repetition, the second
column, etc. The "!" syntax chooses the
<i>kth</i> value from the iteration, where <i>k</i> is the position
(iteration count) of the iteration variable after the
"!". Thus, the above example is equivalent to the following:

<pre class="inifile">
# no repeat= line!
seed-1-mt = ${seed1 = 53542, 45732, 47853, 33434}
seed-2-mt = ${        75335, 35463, 24674, 56673 ! seed1}
seed-3-mt = ${        34542, 67563, 96433, 23567 ! seed1}
</pre>
<p>
That is, the iterators of <tt>seed-2-mt</tt> and <tt>seed-3-mt</tt> are advanced
in lockstep with the <tt>seed1</tt> iteration.

<p>

<p><h3><a name="sec348"/>9.4.7 Experiment-Measurement-Replication</h3>

<p>We have introduced three concepts that are useful for organizing
simulation results generated by batch executions or several batches of
executions.

<p>During a simulation study, a user prepares several
<i>experiments</i>. The purpose of an experiment is to find out the
answer to questions like <i>"how does the number of
nodes affect response times in the network?"</i> For an
experiment, several <i>measurements</i> are performed on the
simulation model, and each measurement runs the simulation model with a
different set of parameters. To eliminate the bias introduced by the
particular random number stream used for the simulation, several
<i>replications</i> of every measurement are run with different
random number seeds, and the results are averaged.

<p>OMNeT++ result analysis tools can take advantage of the <i>experiment</i>,
<i>measurement</i> and <i>replication</i> labels recorded into result
files, and display simulation runs and recorded results accordingly on
the user interface.

<p>These labels can be explicitly specified in the ini file using the
<b><tt>experiment-label</tt></b>, <b><tt>measurement-label</tt></b> and <b><tt>replication-label</tt></b>
config options. If they are missing, the default is the following:

<pre class="inifile">
experiment-label = "${configname}"
measurement-label = "${iterationvars}"
replication-label = "#${repetition},seed-set=&lt;seedset&gt;"
</pre>
<p>
That is, the default experiment label is the configuration name; the
measurement label is concatenated from the iteration variables; and the
replication label contains the repeat loop variable and seed-set.
Thus, for our first example the <i>experiment-measurement-replication</i>
tree would look like this:

<p><pre class="verbatim">
"PureAloha"<i><i>--experiment</i></i>
  $N=1,$mean=0.2<i><i> -- measurement</i></i>
    #0, seed-set=0<i><i> -- replication</i></i>
    #1, seed-set=1
    #2, seed-set=2
    #3, seed-set=3
    #4, seed-set=4
  $N=1,$mean=0.4
    #0, seed-set=5
    #1, seed-set=6
    ...
    #4, seed-set=9
  $N=1,$mean=0.6
    #0, seed-set=10
    #1, seed-set=11
    ...
    #4, seed-set=14
  $N=2,$mean=0.2
    ...
  $N=2,$mean=0.4
    ...
    ...
</pre>

<p>The <i>experiment-measurement-replication</i> labels should be enough to
reproduce the same simulation results, given of course that the ini
files and the model (NED files and C++ code) haven't changed.

<p>Every instance of running the simulation gets a unique run ID. We can
illustrate this by listing the corresponding run IDs under each
repetition in the tree. For example:

<p><pre class="verbatim">
"PureAloha"
  $N=1,$mean=0.2
    #0, seed-set=0
      <i>PureAloha-0-20070704-11:38:21-3241</i>
      <i>PureAloha-0-20070704-11:53:47-3884</i>
      <i>PureAloha-0-20070704-16:50:44-4612</i>
    #1, seed-set=1
      <i>PureAloha-1-20070704-16:50:55-4613</i>
    #2, seed-set=2
      <i>PureAloha-2-20070704-11:55:23-3892</i>
      <i>PureAloha-2-20070704-16:51:17-4615</i>
      ...
</pre>

<p>The tree shows that ("PureAloha", "$N=1,$mean=0.2", "#0, seed-set=0")
was run three times. The results produced
by these three executions should be identical, unless, for example,
some parameter was modified in the ini file, or a bug got fixed in the
C++ code.

<p>We believe that the default way of generating
<i>experiment-measurement-replication</i> labels is useful and
sufficient for the majority of simulation studies. However, you can
customize it if needed. For example, here is a way to join two
configurations into one experiment:

<pre class="inifile">
[Config PureAloha_Part1]
experiment-label = "PureAloha"
...
[Config PureAloha_Part2]
experiment-label = "PureAloha"
...
</pre>
<p>
Measurement and replication labels can be customized in a similar way,
making use of named iteration variables, <tt>${repetition}</tt>,
<tt>${runnumber}</tt> and other predefined variables. One possible benefit is
to customize the generated measurement and replication labels. For
example:

<pre class="inifile">
[Config PureAloha_Part1]
measurement = "${N} hosts, exponential(${mean}) packet generation interval"
</pre>
<p>
One should be careful with the above technique though, because if some
iteration variables are left out of the measurement labels, runs with
all values of those variables will be grouped together to the same
replications.

<p>
<h2><a name="sec349"/>9.5 Configuring the Random Number Generators</h2>
<a name="sec:ch-config-sim:rng-config"></a>

<p>The random number architecture of OMNeT++ was already outlined
in section <a href="#sec270">[7.4]</a>. Here
we'll cover the configuration of RNGs in <tt>omnetpp.ini</tt>.

<p><h3><a name="sec350"/>9.5.1 Number of RNGs</h3>

<p>The <b><tt>num-rngs</tt></b> configuration option sets the number of
random number generator instances (i.e. random number streams)
available for the simulation model (see <a href="#sec270">[7.4]</a>).
Referencing an RNG number greater or equal to this number
(from a simple module or NED file) will cause a runtime error.

<p>
<h3><a name="sec351"/>9.5.2 RNG Choice</h3>

<p>The <b><tt>rng-class</tt></b> configuration option sets the random number
generator class to be used. It defaults to <tt>"<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>"</tt>,
the Mersenne Twister RNG. Other available classes are <tt>"<a href="../api/classcLCG32.html">cLCG32</a>"</tt>
(the "legacy" RNG of OMNeT++ 2.3 and earlier versions, with a cycle length
of <i>2<sup>31</sup>-2</i>), and <tt>"cAkaroaRNG"</tt> (Akaroa's random number generator,
see section <a href="#sec371">[10.5]</a>).

<p><h3><a name="sec352"/>9.5.3 RNG Mapping</h3>

<p>The RNG numbers used in simple modules may be arbitrarily mapped to the
actual random number streams (actual RNG instances) from <tt>omnetpp.ini</tt>.
The mapping allows for great flexibility in RNG usage and random number
streams configuration -- even for simulation models which were not
written with RNG awareness.

<p>RNG mapping may be specified in <tt>omnetpp.ini</tt>. The syntax of
configuration entries is the following.

<pre class="inifile">
[General]
&lt;modulepath&gt;.rng-N = M  # where N,M are numeric, M &lt; num-rngs
</pre>
<p>
This maps module-local RNG N to physical RNG M. The following
example maps all <tt>gen</tt> module's default (N=0) RNG to physical RNG 1,
and all <tt>noisychannel</tt> module's default (N=0) RNG to physical RNG 2.

<pre class="inifile">
[General]
num-rngs = 3
**.gen[*].rng-0 = 1
**.noisychannel[*].rng-0 = 2
</pre>
<p>
This mapping allows variance reduction techniques to be applied to
OMNeT++ models, without any model change or recompilation.

<p>
<h3><a name="sec353"/>9.5.4 Automatic Seed Selection</h3>

<p>Automatic seed selection is used for an RNG if you do not explicitly
specify seeds in <tt>omnetpp.ini</tt>. Automatic and manual seed selection can
co-exist; for a particular simulation, some RNGs can be configured
manually, and some automatically.

<p>The automatic seed selection mechanism uses two inputs: the <i>run number</i>
 and the <i>RNG number</i>. For the same run number and RNG number,
OMNeT++ always selects the same seed value for any simulation model.
If the run number or the RNG number is different, OMNeT++ does its best
to choose different seeds which are also sufficiently separated in the RNG's sequence
so that the generated sequences don't overlap.

<p>The run number can be specified either in in <tt>omnetpp.ini</tt> (e.g. via the
<b><tt>cmdenv-runs-to-execute</tt></b> option) or on the command line:

<pre class="commandline">
./mysim -r 1
./mysim -r 2
./mysim -r 3
</pre>
<p>
For the <tt><a href="../api/classcMersenneTwister.html">cMersenneTwister</a></tt> random number generator, selecting seeds
so that the generated sequences don't overlap is easy,
due to the extremely long sequence of the RNG.
The RNG is initialized from the 32-bit seed value <i>seed = runNumber*numRngs + rngNumber</i>.
(This implies that simulation runs participating in the study should have
the same number of RNGs set).
    <br><ul><font size=-1>[While (to our knowledge) no one has proven that the seeds 0,1,2,...
    are well apart in the sequence, this is probably true, due to the extremely
    long sequence of MT. The author would however be interested in papers
    published about seed selection for MT.]</font></ul>

<p>For the <tt><a href="../api/classcLCG32.html">cLCG32</a></tt> random number generator, the situation is more difficult,
because the range of this RNG is rather short (<i>2<sup>31</sup>-1</i>, about 2 billion).
For this RNG, OMNeT++ uses a table of 256 pre-generated seeds, equally spaced
in the RNG's sequence. Index into the table is calculated with the
<i>runNumber*numRngs + rngNumber</i> formula. Care should be taken that
one doesn't exceed 256 with the index, or it will wrap and the
same seeds will be used again. It is best not to use the <tt><a href="../api/classcLCG32.html">cLCG32</a></tt>
at all -- <tt><a href="../api/classcMersenneTwister.html">cMersenneTwister</a></tt> is superior in every respect.

<p>
<h3><a name="sec354"/>9.5.5 Manual Seed Configuration</h3>

<p>In some cases you may want to manually configure seed values.
Reasons for doing that may be that you want to use variance reduction
techniques, or you may want to use the same seeds for several simulation
runs.

<p>To manually set seeds for the Mersenne Twister RNG, use the <tt>seed-</tt><i>k</i><tt>-mt</tt>
option, where <i>k</i> is the RNG index. An example:

<pre class="inifile">
[General]
num-rngs = 3
seed-0-mt = 12
seed-1-mt = 9
seed-2-mt = 7
</pre>
<p>
<a name="sec:ch-config-sim:seedtool"></a>

<p>For the now obsolete <a href="../api/classcLCG32.html">cLCG32</a> RNG, the name of the corresponding option is
<tt>seed-</tt><i>k</i><tt>-lcg32</tt>, and OMNeT++ provides a standalone program
called <tt>opp_lcg32_seedtool</tt> to generate good seed values that
are sufficiently separated in the RNG's sequence.


<hr class='pgbr'><h1><a name="sec355"/>10 Running Simulations</h1>
<a name="cha:run-sim"></a>

<p><h2><a name="sec356"/>10.1 Introduction</h2>

<p>This chapter describes how to run simulations. It covers basic usage,
user interfaces, batch runs, how to use Akaroa, and also explains
how to solve the most common errors.

<p><h3><a name="sec357"/>10.1.1 Running a Simulation Executable</h3>
<a name="sec:ch-run-sim:running"></a>

<p>By default, the output of an <tt>opp_makemake</tt>-generated makefile is
a simulation executable that can be run directly. In simple cases,
this executable can be run without command-line arguments, but usually
one will need to specify options to specify what ini file to use,
which user interface to activate, where to load NED files from, and so on.

<p><p class="subheading">Getting Help</p>

<p>The following sections describe the most frequently used command-line
options. To get a complete list of supported command line options, run
the <tt>opp_run</tt> command (or any other simulation executable) with
the <tt>-h</tt> option.

<pre class="commandline">
$ opp_run -h
</pre>
<p>
<p class="subheading">Specifying Ini Files</p>

<p>The default ini file is <tt>omnetpp.ini</tt>, and is
loaded if no other ini file is given on the command line.

<p>Ini files can be specified both as plain arguments and with the <tt>-f</tt>
option, so the following two commands are equivalent:

<pre class="commandline">
$ ./fifo experiment.ini common.ini
$ ./fifo -f experiment.ini -f common.ini
</pre>
<p>
Multiple ini files can be given, and their contents will be merged. This
allows for partitioning the configuration into separate files, for example
to simulation options, module parameters and result recording options.

<p>
<p class="subheading">Specifying the NED Path</p>

<p>NED files are loaded from directories listed on the NED path. More precisely,
they are loaded from the listed directories and their whole subdirectory trees.
Directories are separated with a semicolon (<tt>;</tt>).

<p><ul class="note"><b>NOTE</b><br>
Semicolon is used as separator on both Unix and Windows.
</ul>

<p>The NED path can be specified in several ways:
<ul>
  <li> using the <tt>NEDPATH</tt> environment variable
  <li> using the <tt>-n</tt> command-line option
  <li> in ini files, with the <b><tt>ned-path</tt></b> configuration option
</ul>

<p>NED path resolution rules are as follows:

<p><ul>
  <li> OMNEST checks for NED path specified on the command line with the <tt>-n</tt> option
  <li> if not found on the command line, it checks for the NEDPATH environment variable
  <li> the <b><tt>ned-path</tt></b> option value from the ini file is appended to the result of the above steps
  <li> if the result is still empty, it falls back to "." (the current directory)
</ul>

<p>
<p class="subheading">Selecting a User Interface</p>

<p>OMNEST simulations can be run under different user interfaces.
Currently the following user interfaces are supported:

<p><ul>
  <li> Tkenv: Tcl/Tk-based graphical, windowing user interface
  <li> Cmdenv: command-line user interface for batch execution
</ul>

<p>You would typically test and debug your simulation under Tkenv,
then run actual simulation experiments from the command line or
shell script, using Cmdenv. Tkenv is also better suited for educational or
demonstration purposes.

<p>Both Tkenv and Cmdenv are provided in the form of a library, and
you may choose between them by linking one or both into your
simulation executable. (Creating the executable was described in
chapter <a href="#sec312">[8]</a>). Both user interfaces
are supported on Unix and Windows platforms.

<p>You can choose which runtime environment is included in your simulation
executable when you generate your makefile. By default, both Tkenv and
Cmdenv is linked in so you can choose between them during runtime, but it
is possible to specify only a single user interface with the <tt>-u
Cmdenv</tt> or <tt>-u Tkenv</tt> option on the <tt>opp_makemake</tt> command line.
This can be useful if you intend to run your simulations on a machine where
Tcl/Tk is not installed.

<p>By default, Tkenv will be used if both runtime environments are present in
your executable. You explicitly select a user interface by adding the
<tt>user-interface=Cmdenv</tt> (or <tt>=Tkenv</tt>) option in your ini file, or
by specifying <tt>-u Cmdenv</tt> or <tt>-u Tkenv</tt> on the command line. If
both the config option and the command line option are present, the command
line option takes precedence.

<p><p class="subheading">Selecting a Configuration and Run Number</p>

<p>Configurations can be selected with the <tt>-c &lt;configname&gt;</tt> command line option.
If you do not specify the configuration and you are running under:

<p><ul>
  <li> Tkenv: the runtime environment will prompt you to choose one.
  <li> Cmdenv: the <tt>General</tt> configuration will be executed.
</ul>

<p>User interfaces may support the <tt>-r runnumber</tt> option to select runs,
either one or more, depending on the type of the user interface.

<p>There are several command line options to get information about the iteration
variables and the number of runs in the configurations:

<p><ul>
  <li> <tt>-a</tt> -- Prints all configuration names and the number of runs in them.
  <li> <tt>-x &lt;configname&gt;</tt> -- Prints the number of runs available in the given configuration.
  <li> <tt>-g</tt> -- Prints the unrolled configuration (together with the -x option) and
                    expands the iteration variables.
  <li> <tt>-G</tt> -- Prints even more details than -g.
</ul>

<p>
<p class="subheading">Loading Extra Libraries</p>

<p>OMNEST allows you to load shared libraries at runtime. This means that you can create
simulation models as a shared library and load the model later into a different executable without
the need to explicitly link against that library. This approach has several advantages.

<p><ul>
  <li> It is possible to distribute the model as a shared library. Others may be able to use
  it without recompiling it.
  <li> You can split a large model into smaller, reusable components.
  <li> You can mix several models (even from different projects)
    without the need of linking or compiling.
</ul>

<p>Use the <tt>-l libraryname</tt> command line option to load a library dynamically.
OMNEST will attempt to load it using the <tt>dlopen()</tt> or <tt>LoadLibrary()</tt> functions and
automatically registers all simple modules in the library.

<p>The prefix and suffix from the library name can be omitted (the extensions
<tt>.dll</tt>, <tt>.so</tt>, <tt>.dylib</tt>, and also the common <tt>lib</tt> prefix
on Unix systems). This means that you can specify the library name in a
platform independent way: if you specify <tt>-l foo</tt>, then OMNEST will
look for <tt>foo.dll</tt>, <tt>libfoo.dll</tt>, <tt>libfoo.so</tt> or <tt>libfoo.dylib</tt>,
depending on the platform.

<p>It is also possible to specify the libraries to be loaded in the ini file
with the <b><tt>load-libs</tt></b> configuration option. The values from the command line
and the config file will be merged.

<p><ul class="note"><b>NOTE</b><br>
  Runtime loading is not needed if your executable or shared lib was
  already linked against the library in question. In that case,
  the platform's dynamic loader will automatically load the library.
</ul>

<p><ul class="note"><b>NOTE</b><br>
  You must ensure that the library can be accessed by OMNEST. Either specify the
  library name with a full path (pre- and postfixes of the library file name
  still can be omitted), or adjust the shared library path environment variable
  of your OS (<tt>PATH</tt> on Windows, <tt>LD_LIBRARY_PATH</tt> on Unix, and
  <tt>DYLD_LIBRARY_PATH</tt> on Mac OS X.)
</ul>

<p><h3><a name="sec358"/>10.1.2 Running a Shared Library</h3>

<p>Shared libraries can be run using the <tt>opp_run</tt> program.
Both <tt>opp_run</tt> and simulation executables are capable of
loading additional shared libraries; actually, <tt>opp_run</tt>
is nothing else than an empty simulation executable.

<p>Example:
<pre class="commandline">
opp_run -l mymodel
</pre>

<p>The above example will load the model found in <tt>libmymodel.so</tt> and execute it.

<p><h3><a name="sec359"/>10.1.3 Controlling the Run</h3>

<p>There are several useful configuration options that control how a simulation is run.

<p><ul>
  <li> <b><tt>cmdenv-express-mode</tt></b> -- Provides only minimal status updates on the console.
  <li> <b><tt>cmdenv-interactive</tt></b> -- Allows the simulation to ask missing parameter values interactively
  <li> <b><tt>cmdenv-status-frequency</tt></b> -- Controls how often the status is written to the console.
  <li> <b><tt>cpu-time-limit</tt></b> -- Limits how long the simulation should run (in wall clock time)
  <li> <b><tt>sim-time-limit</tt></b> -- Limits how long the simulation should run (in simulation time)
  <li> <b><tt>record-eventlog</tt></b> -- Turns on the recording of the simulator events into an event log file.
           The resulting <tt>.elog</tt> file can be analyzed later in the IDE with the sequence chart tool.
  <li> <b><tt>fingerprint</tt></b> -- The simulation kernel computes a checksum while running the simulation.
          It is calculated from the module id and from the current simulation time of each event.
          If you specify the <b><tt>fingerprint</tt></b> option in the config file, the simulation runtime will
          compare the computed checksum with the provided one. If there is a difference it will
          generate an error. This feature is very useful if you make some cosmetic changes to your
          source and want to be reasonable sure that your changes did not alter the behaviour
          of the model.
          <ul class="warning"><b>WARNING</b><br>
          The value of the calculated fingerprint is heavily dependent on the accuracy of the floating
          point arithmetic. There are differences between the floating point handling of AMD and Intel CPUs.
          Running under a processor emulator software like <tt>valgrind</tt> may also produce
          a different fingerprint. This is normal. Hint: see gcc options <tt>-mfpmath=sse -msse2</tt>.
          </ul>
  <li> <b><tt>debug-on-errors</tt></b> -- If the runtime detects any error, it will generate a breakpoint
          so you will be able to check the location and the context of the problem in your debugger.
  <li> <b><tt>debugger-attach-on-error</tt></b> -- Controls just-in-time debugging. When this option is enabled
          and an error occurs during simulation, the simulation program will launch an external debugger,
          and have it attached to the simulation process. Related configuration options are
          <b><tt>debugger-attach-on-startup</tt></b>, <b><tt>debugger-attach-command</tt></b> and
          <b><tt>debugger-attach-wait-time</tt></b>.
</ul>

<p><ul class="note"><b>NOTE</b><br>
  It is also possible to specify a configuration option on the command line (in which case the
  command line takes precedence). To do so, prefix the option name with a double
  dash (--), and be sure not to have spaces around the equal sign. Example:
  <tt>--debug-on-errors=true</tt>
</ul>

<p>To get the list of all possible configuration options, type:

<pre class="commandline">
opp_run -h config
</pre>
<p>

<p><h2><a name="sec360"/>10.2 Cmdenv: the Command-Line Interface</h2>

<p>The command line user interface<!--command line user interface--> is
a small, portable and fast user interface that compiles and runs on
all platforms. Cmdenv<!--Cmdenv--> is designed primarily for batch execution.

<p>Cmdenv simply executes some or all simulation runs that are described
in the configuration file. If one run stops with an error message,
subsequent ones will still be executed. The runs to be executed can be
passed via command-line argument or in the ini file.

<p><h3><a name="sec361"/>10.2.1 Example Run</h3>

<p>When you run the Fifo example under Cmdenv, you should see
something like this:

<pre class="commandline">
$ ./fifo -u Cmdenv -c Fifo1

OMNeT++ Discrete Event Simulation  (C) 1992-2008 Andras Varga, OpenSim Ltd.
Version: 4.0, edition: Academic Public License -- NOT FOR COMMERCIAL USE
See the license for distribution terms and warranty disclaimer
Setting up Cmdenv...
Loading NED files from .: 5

Preparing for running configuration Fifo1, run #0...
Scenario: $repetition=0
Assigned runID=Fifo1-0-20090104-12:23:25-5792
Setting up network 'FifoNet'...
Initializing...
Initializing module FifoNet, stage 0
Initializing module FifoNet.gen, stage 0
Initializing module FifoNet.fifo, stage 0
Initializing module FifoNet.sink, stage 0

Running simulation...
** Event #1   T=0   Elapsed: 0.000s (0m 00s)  0% completed
     Speed:     ev/sec=0   simsec/sec=0   ev/simsec=0
     Messages:  created: 2   present: 2   in FES: 1
** Event #232448   T=11719.051014922336   Elapsed: 2.003s (0m 02s)  3% completed
     Speed:     ev/sec=116050   simsec/sec=5850.75   ev/simsec=19.8351
     Messages:  created: 58114   present: 3   in FES: 2
...
** Event #7206882   T=360000.52066583684   Elapsed: 78.282s (1m 18s)  100% completed
     Speed:     ev/sec=118860   simsec/sec=5911.9   ev/simsec=20.1053
     Messages:  created: 1801723   present: 3   in FES: 2

&lt;!&gt; Simulation time limit reached -- simulation stopped.

Calling finish() at end of Run #0...
End.
</pre>
<p>
As Cmdenv runs the simulation, it periodically prints the sequence number
of the current event, the simulation time, the elapsed (real) time,
and the performance of the simulation (how many events are processed per
second; the first two values are 0 because there wasn't enough data
for it to calculate yet). At the end of the simulation, the <tt>finish()</tt>
methods of the simple modules are run, and the outputs from them are displayed.
On my machine this run took 34 seconds. This Cmdenv output can be
customized via <tt>omnetpp.ini</tt> entries. The output file <tt>results/Fifo1-0.vec</tt>
contains vector data recorded during simulation (here, queueing times),
and it can be processed using the IDE or other tools.

<p><h3><a name="sec362"/>10.2.2 Command-Line Options</h3>

<p>The command line environment allows you to specify more than one run by
using the <tt>-r 2,4,6..8</tt> format. See <a href="#sec367">[10.4]</a>
for more information about running simulation batches.

<p><h3><a name="sec363"/>10.2.3 Cmdenv Ini File Options</h3>
<a name="sec:ch-run-sim:cmdenv-section"></a>

<p><b><tt>cmdenv-runs-to-execute</tt></b> specifies which simulation runs should be executed.
It accepts a comma-separated list of run numbers or run number ranges, e.g.
<tt>1,3..4,7..9</tt>. If the value is missing, Cmdenv executes all runs that have
ini file sections; if no runs are specified in the ini file, Cmdenv does one run.
The <tt>-r</tt> command line option overrides this ini file setting.

<p>
Cmdenv can be executed in two modes, selected by the <b><tt>cmdenv-express-mode</tt></b>
ini file option:

<p><ul>
    <li> <b>Normal</b> (non-express) mode is for debugging; detailed information
        will be written to the standard output (event banners, module output,
        etc).
    <li> <b>Express</b> mode can be used for long simulation runs; only
        periodical status updates are displayed about the progress of the
        simulation.
</ul>

<p><b><tt>cmdenv-performance-display</tt></b> affects express mode only: it controls
whether to print performance information. Turning it on results in a 3-line
entry printed on each update, containing ev/sec, simsec/sec, ev/simsec,
number of messages created/still present/currently scheduled in FES<!--FES-->.

<p>For a full list of options, see the options beginning with <tt>cmdenv-</tt> in
Appendix <a href="#sec566">[25]</a>.

<p>
<h3><a name="sec364"/>10.2.4 Interpreting Cmdenv Output</h3>
<a name="sec:ch-run-sim:interpreting-cmdenv-output"></a>

<p>When the simulation is running in &#8220;express&#8221; mode with detailed
performance display enabled, Cmdenv periodically outputs a three-line
status report about the progress of the simulation.
The output looks like this:

<pre class="commandline">
...
** Event #250000   T=123.74354 ( 2m  3s)    Elapsed: 0m 12s
     Speed:     ev/sec=19731.6   simsec/sec=9.80713   ev/simsec=2011.97
     Messages:  created: 55532   present: 6553   in FES: 8
** Event #300000   T=148.55496 ( 2m 28s)    Elapsed: 0m 15s
     Speed:     ev/sec=19584.8   simsec/sec=9.64698   ev/simsec=2030.15
     Messages:  created: 66605   present: 7815   in FES: 7
...
</pre>
<p>
The first line of the status display (beginning with <tt>**</tt>)
contains:

<p><ul>
   <li>how many events have been processed so far
   <li>the current simulation time (T), and
   <li>the elapsed time (wall clock time) since the beginning of the simulation run.
</ul>

<p>The second line displays info about simulation performance:

<p><ul>
   <li><tt>ev/sec</tt> indicates <i>performance</i>: how many events are processed
     in one real-time second.  On one hand it depends on your hardware
     (faster CPUs process more events per second), and on the other hand
     it depends on the complexity (amount of calculations) associated
     with processing one event. For example, protocol simulations tend to require
     more processing per event than e.g. queueing networks, thus
     the latter produce higher ev/sec values.
     In any case, this value is independent of the size (number of modules) in your model.
   <li><tt>simsec/sec</tt> shows <i>relative speed</i> of the simulation, that is,
     how fast the simulation is progressing compared to real time, how many
     simulated seconds can be done in one real second. This value virtually depends
     on everything: on the hardware, on the size of the simulation model,
     on the complexity of events, and the average simulation time between events as well.
   <li><tt>ev/simsec</tt> is the <i>event density</i>: how many events are
     there per simulated second. Event density only depends on the simulation model,
     regardless of the hardware used to simulate it: in a cell-level ATM simulation
     you will have very hight values (<i>10<sup>9</sup></i>), while in a bank teller simulation
     this value is probably well under 1. It also depends on the size of your
     model: if you double the number of modules in your model, you can expect
     the event density double, too.
</ul>

<p>The third line displays the number of messages, and it is important
because it may indicate the `health' of your simulation.

<p><ul>
   <li><tt>Created</tt>: total number of message objects created since the
     beginning of the simulation run. This does not mean that this many message
     object actually exist, because some (many) of them may have been deleted
     since then. It also does not mean that <i>you</i> created all those
     messages -- the simulation kernel also creates messages for its own use
     (e.g. to implement <tt>wait()</tt> in an <tt>activity()</tt> simple module).
   <li><tt>Present</tt>: the number of message objects currently present
     in the simulation model, that is, the number of messages created (see above)
     minus the number of messages already deleted. This number includes
     the messages in the FES<!--FES-->.
   <li><tt>In FES</tt>: the number of messages currently scheduled in the
     Future Event Set.
</ul>

<p>
The second value, the number of messages present, is more useful than
perhaps one would initially think. It can be an indicator of the `health' of the simulation;
if it is growing steadily, then either you have a memory leak and losing
messages (which indicates a programming error), or the network you simulate is
overloaded and queues are steadily filling up (which might indicate wrong input
parameters).

<p>Of course, if the number of messages does not increase, it does not mean
that you do <i>not</i> have a memory leak (other memory leaks are also
possible). Nevertheless the value is still useful, because by far the
most common way of leaking memory in a simulation is by not deleting messages.

<p>

<p><h2><a name="sec365"/>10.3 Tkenv: the Graphical User Interface</h2>

<p>Tkenv<!--Tkenv--> is a portable graphical windowing user interface.
Tkenv supports interactive execution of the simulation, tracing and
debugging<!--simulation!debugging-->. Tkenv is recommended in the
development stage of a simulation and for presentation purposes,
since it allows one to get a detailed picture of the state
of simulation at any point of execution and to follow what happens
inside the network.

<p><ul class="note"><b>NOTE</b><br>
  This section only covers the command-line and configuration options
  of Tkenv; the user interface is described in the Tkenv chapter of the
  OMNEST User Guide.
</ul>

<p><h3><a name="sec366"/>10.3.1 Command-Line and Configuration Options</h3>

<p>A simulation program built with Tkenv accepts all the general command line
options. <!--command line options--> Additionally, the <tt>-c configname</tt>
and <tt>-r runnumber</tt> options can be used to preselect a single run for execution;
that is, these options suppress the initial run selection dialog.

<p>Tkenv configuration options:
<ul>
  <li><b><tt>tkenv-default-config</tt></b>:
    Specifies which config Tkenv should set up automatically on startup. The
    default is to ask the user. This option is equivalent to the <tt>-c</tt>
    command-line option.

<p>  <li><b><tt>tkenv-default-run</tt></b>: Specifies which run (of the default
    config, see tkenv-default-config) Tkenv should set up automatically on startup.
    The default is to ask the user. This option is equivalent to the <tt>-r</tt>
    command-line option.

<p>  <li><b><tt>tkenv-extra-stack</tt></b>:
    Specifies the extra amount of stack that is reserved for each activity()
    simple module when the simulation is run under Tkenv.

<p>  <li><b><tt>tkenv-image-path</tt></b>: Specifies the path for loading module icons.

<p>  <li><b><tt>tkenv-plugin-path</tt></b>:
    Specifies the search path for Tkenv plugins. Tkenv plugins are .tcl files
    that get evaluated on startup.
</ul>

<p>Tkenv-specific configuration options can also be specified on the command line
by prefixing them with two dashes (e.g <tt>--tkenv-option=value</tt>). See
Appendix <a href="#sec566">[25]</a> for the list of possible configuration options.

<p>
<h2><a name="sec367"/>10.4 Batch Execution</h2>
<a name="sec:ch-run-sim:batch-execution"></a>

<p>Once your model works reliably, you will usually want to run several
simulations. You may want to run the model with various
parameter settings, or you may want <i>(should want?)</i> to
run the same model with the same parameter settings but with
different random number generator seeds, to achieve statistically
more reliable results.

<p>Running a simulation several times by hand can easily become tedious,
and then a good solution is to write a control script that
takes care of the task automatically. Unix shell is
a natural language choice to write the control script in,
but other languages like Perl, Matlab/Octave, Tcl, Ruby might also have
justification for this purpose.

<p>Before running simulation batches, you must set a condition to
stop your simulation. This is usually a time limit set by the
<b><tt>sim-time-limit</tt></b> configuration option, but you can limit your simulation
by using wall clock time (<b><tt>cpu-time-limit</tt></b>) or by directly ending a
simulation with an API call if some condition is true.

<p><h3><a name="sec368"/>10.4.1 Using Cmdenv</h3>

<p>To execute more than one run using Cmdenv, use the <tt>-r</tt> option
and specify the runs in a comma separated format <tt>1,2,4,9..11</tt>, or you may leave
out the <tt>-r</tt> option to execute all runs in the experiment.

<p><ul class="warning"><b>WARNING</b><br>
  Although it is very convenient, we do not recommend that you use this method for
  running simulation batches. Specifying more than one run number
  would run those simulations in the same process. This method is more prone to C++ programming
  errors. A failure in a single run may abort execution (segfault) or invalidate the results of subsequent runs. If you want
  to execute more than one run, we recommend that you run each of them in a separate process;
  you can use the <tt>opp_runall</tt> program for this purpose.
</ul>

<p>
<h3><a name="sec369"/>10.4.2 Using Shell Scripts</h3>

<p>The following script executes a simulation named <tt>wireless</tt>
several times, with parameters for the different runs
given in the <tt>runs.ini</tt> file.

<p>Before you execute your simulation batch, you may check how many
runs are available in the configuration you are using. Use the
<tt>-x config</tt> command line option to print the number of runs or
add the <tt>-g</tt> to get more details.

<pre class="filelisting">
#! /bin/sh
./wireless -f runs.ini -r 1
./wireless -f runs.ini -r 2
./wireless -f runs.ini -r 3
./wireless -f runs.ini -r 4
...
./wireless -f runs.ini -r 10
</pre>
<p>
To run the above script, type it in a text file called e.g. <tt>run</tt>,
give it <tt>x</tt> (executable) permission using <tt>chmod</tt>,
then you can execute it by typing <tt>./run</tt>:

<pre class="commandline">
$ chmod +x run
$ ./run
</pre>
<p>
You can simplify the above script by using a <i>for</i> loop.
In the example below, the variable <tt>i</tt> iterates through
the values of list given after the <tt>in</tt> keyword.
It is very practical, since you can leave out or add runs,
or change the order of runs by simply editing the list --
to demonstrate this, we skip run 6, and include run 15 instead.

<pre class="filelisting">
#! /bin/sh
for i in 3 2 1 4 5 7 15 8 9 10; do
   ./wireless -f runs.ini -r $i
done
</pre>
<p>
If you have many runs, you can use a C-style loop:

<pre class="filelisting">
#! /bin/sh
for ((i=1; $i&lt;50; i++)); do
   ./wireless -f runs.ini -r $i
done
</pre>
<p>
<h3><a name="sec370"/>10.4.3 Using opp_runall</h3>

<p>OMNEST has a utility program called <tt>opp_runall</tt> which
allows you to execute a simulation batch in command line mode.
You must specify the whole command line you would use to run
your batch in Cmdenv. There are advantages to running your batches
this way:
<ul>
  <li> Each simulation run executes in a separate operating system process.
        This means that a crash because of a programming error does not affect
        the outcome of the other runs. They are totally independent of each other.
  <li> If you happen to have a multi core/processor machine, you can take advantage
        of the processing power by running sevaral runs in parallel.
</ul>

<p>The command basically creates a makefile which contains
a separate target for each run. By default the makefile will be executed causing each
target to run. You can give additional options to the <tt>opp_runall</tt> command to
activate parallel building. The <tt>-j</tt> option can be used to specify the maximum number
of parallel runs allowed.

<p><ul class="warning"><b>WARNING</b><br>
  Use the parallel execution option only if you have enough memory to run several simulations
  side by side. If you run out of memory your operating system will start swapping, and the overall
  performance of the system will be greatly reduced. Always specify the number of processes
  after the <tt>-j</tt> option, otherwise the <tt>make</tt> program will try to start <i>all</i>
  runs at the same time. As a rule of thumb: if you have 4 cores (and enough memory), use <tt>-j4</tt>.
</ul>

<p>The form of the command is:
<pre class="commandline">
opp_runall -j2 ./aloha -u Cmdenv -c PureAlohaExperiment -r 0..23
</pre>

<p>You can use the <tt>-x ConfigName -g</tt> command line options with your simulation to
check the number of available runs.

<p>Using the <tt>--export filename</tt> option only generates the <tt>makefile</tt>, but does not start it.
You can run your batch later by invoking the generated makefile.



<p><h2><a name="sec371"/>10.5 Akaroa Support: Multiple Replications in Parallel</h2>
<a name="sec:ch-run-sim:akaroa"></a>
<!--Akaroa-->
<!--Multiple Replications in Parallel-->

<p><h3><a name="sec372"/>10.5.1 Introduction</h3>

<p>Typical simulations are Monte-Carlo simulations: they use
(pseudo-)random numbers to drive the simulation model.
For the simulation to produce statistically reliable results,
one has to carefully consider the following:

<p><ul>
  <li>When the initial transient is over, when can we start
    collecting data? We usually don't want to include the
    initial transient when the simulation is still &#8220;warming up.&#8221;
  <li>When can we stop the simulation? We want to wait long enough
    so that the statistics we are collecting can &#8220;stabilize&#8221;,
    or reach the required sample size to be statistically trustable.
</ul>

<p>Neither question is trivial to answer. One might just suggest
to wait &#8220;very long&#8221; or &#8220;long enough&#8221;. However, this is neither
simple (how do you know what is &#8220;long enough&#8221;?) nor practical
(even with today's high speed processors simulations of modest complexity
can take hours, and one may not afford multiplying runtimes by,
say, 10, &#8220;just to be safe.&#8221;) If you need further convincing,
please read [<a href="#bib-Pawlikowsky02">Pawlikowsky02</a>] and be horrified.

<p>A possible solution is to look at the statistics while the simulation
is running, and decide at runtime when enough data have been
collected for the results to have reached the required accuracy.
One possible criterion is given by the confidence level,
more precisely, by its width relative to the mean.
But ex ante it is unknown how many observations have to be collected
to achieve this level -- it must be determined at runtime.

<p>
<h3><a name="sec373"/>10.5.2 What Is Akaroa</h3>

<p>Akaroa [<a href="#bib-Akaroa99">Akaroa99</a>] addresses the above problem.
According to its authors, Akaroa (Akaroa2) is a &#8220;fully automated
simulation tool designed for running distributed stochastic simulations
in MRIP scenario&#8221; in a cluster computing environment.

<p>MRIP stands for <i>Multiple Replications in Parallel</i>.
In MRIP, the computers of the cluster run independent replications
of the whole simulation process (i.e. with the same parameters but
different seed for the RNGs (random number generators)),
generating statistically equivalent streams of simulation output data.
These data streams are fed to a global data analyser responsible for
analysis of the final results and for stopping the simulation
when the results reach a satisfactory accuracy.

<p>The independent simulation processes run independently of one another
and continuously send their observations to the central analyser
and control process. This process <i>combines</i> the independent data streams,
and calculates from these observations an overall estimate of the mean value
of each parameter.
Akaroa2 decides by a given confidence level and precision
whether it has enough observations or not. When it judges that is
has enough observations it halts the simulation.

<p>If <i>n</i> processors are used, the needed simulation execution time
is usually <i>n</i> times smaller compared to a one-processor
simulation (the required number of observations are produced sooner).
Thus, the simulation would be sped up approximately in proportion
to the number of processors used and sometimes even more.

<p>Akaroa was designed at the University of Canterbury in Christchurch, New Zealand
and can be used free of charge for teaching and non-profit research activities.

<p>
<h3><a name="sec374"/>10.5.3 Using Akaroa with OMNEST</h3>

<p><p class="subheading">Akaroa</p>

<p>Before the simulation can be run in parallel under Akaroa, you have to
start up the system:

<p><ul>
  <li>Start <tt>akmaster</tt> running in the background on some host.
  <li>On each host where you want to run a simulation engine,
     start <tt>akslave</tt> in the background.
</ul>

<p>Each <tt>akslave</tt> establishes a connection with the <tt>akmaster</tt>.

<p>Then you use <tt>akrun</tt> to start a simulation. <tt>akrun</tt> waits
for the simulation to complete, and writes a report of the results
to the standard output. The basic usage of the <tt>akrun</tt> command is:

<pre class="commandline">
akrun -n num_hosts command [argument..]
</pre>
<p>
where <i>command</i> is the name of the simulation you want to start.
Parameters for Akaroa are read from the file named <tt>Akaroa</tt> in
the working directory. Collected data from the processes are
sent to the <tt>akmaster</tt> process, and when the required precision
has been reached, <tt>akmaster</tt> tells the simulation processes to
terminate. The results are written to the standard output.

<p>The above description is not detailed enough help you
set up and successfully use Akaroa -- for that you need to read the
Akaroa manual.

<p><p class="subheading">Configuring OMNEST for Akaroa</p>

<p>First of all, you have to compile OMNEST with Akaroa support enabled.

<p>The OMNEST simulation must be configured in <tt>omnetpp.ini</tt>
so that it passes the observations to Akaroa. The simulation model itself does
not need to be changed -- it continues to write
the observations into output vectors (<tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects,
see chapter <a href="#sec258">[7]</a>). You can place some of
the output vectors under Akaroa control.

<p>You need to add the following to <tt>omnetpp.ini</tt>:

<pre class="inifile">
[General]
rng-class = "cAkaroaRNG"
outputvectormanager-class = "cAkOutputVectorManager"
</pre>
<p>
These lines cause the simulation to obtain random numbers from Akaroa,
and allows data written to selected output vectors to be passed to Akaroa's
global data analyser.
    <br><ul><font size=-1>[For more details on the plugin mechanism these settings make use of,
    see section <a href="#sec488">[17.1]</a>.]</font></ul>

<p>Akaroa's RNG is a Combined Multiple Recursive pseudorandom
number generator (CMRG) with a period of approximately <i>2<sup>191</sup></i>
random numbers, and provides a unique stream of random numbers
for every simulation engine.

<p><ul class="note"><b>NOTE</b><br>
It is vital that you obtain random numbers from Akaroa; otherwise,
all simulation processes will run with the same RNG seeds, and
produce exactly the same results.
</ul>

<p>Then you need to specify which output vectors you want to
be under Akaroa control (by default, none of them are).
You can use the <tt>*</tt>, <tt>**</tt> wildcards (see
section <a href="#sec339">[9.3.1]</a>) to
place certain vectors under Akaroa control.

<pre class="inifile">
&lt;modulename&gt;.&lt;vectorname1&gt;.with-akaroa = true
&lt;modulename&gt;.&lt;vectorname2&gt;.with-akaroa = true
</pre>
<p>

<p><p class="subheading">Using Shared File Systems</p>
<a name="sec:run-sim:using-shared-filesystems"></a>

<p>It is usually practical to have the same physical disk mounted (e.g. via NFS or Samba)
on all computers in the cluster. However, because all OMNEST simulation
processes run with the same settings, they would overwrite each other's
output files (e.g. <tt>omnetpp.vec</tt>, <tt>omnetpp.sca</tt>).
Your can prevent this from happening using the
<b><tt>fname-append-host</tt></b> ini file entry:

<pre class="inifile">
[General]
fname-append-host = true
</pre>
<p>
When turned on, it appends the host name to the names of the output
files (output vector, output scalar, snapshot files).

<p>

<p><h2><a name="sec375"/>10.6 Troubleshooting</h2>

<p><h3><a name="sec376"/>10.6.1 Unrecognized Configuration Option</h3>

<p>If you receive an error message about unrecognized configuration
options you may use <tt>-h config</tt> or <tt>-h configdetails</tt> options
to display all possible configuration options and their descriptions.

<p><h3><a name="sec377"/>10.6.2 Stack Problems</h3>

<p><p class="subheading">&#8220;Stack violation (<i>FooModule</i> stack too small?) in module <i>bar.foo</i>&#8221;</p>
<!--stack!too small-->

<p>OMNEST detected that the module has used more stack space than it has
allocated. The solution is to increase the stack for that module type.
You can call the <tt>getStackUsage()</tt> from <tt>finish()</tt> to find out
actually how much stack the module used.

<p>
<p class="subheading">&#8220;Error: Cannot allocate <i>nn</i> bytes stack for module <i>foo.bar&#8221;</i></p>

<p>The resolution depends on whether you are using OMNEST on Unix or on Windows.

<p><b>Unix.</b>
If you get the above message, you have to increase the total stack
size<!--stack!size--> (the sum of all coroutine stacks). You can do
so in <tt>omnetpp.ini</tt>:

<pre class="inifile">
[General]
total-stack = 2MiB
</pre>
<p>
There is no performance penalty if you set <b><tt>total-stack</tt></b> too high. I
recommend to set it to a few K less than the maximum process stack
size allowed by the operating system (<tt>ulimit -s</tt>; see
next section).

<p>
<b>Windows.</b>
You need to set a <i>low</i> (!) &#8220;reserved stack size&#8221;
in the linker options, for example 64K (/stack:65536 linker flag) will do.
The &#8220;reserved stack size&#8221; is an attribute in the Windows exe
files' internal header. It can be set from the linker, or with
the <tt>editbin</tt> Microsoft utility. You can use the <tt>opp_stacktool</tt>
program (which relies on another Microsoft utility called <tt>dumpbin</tt>)
to display reserved stack size for executables.

<p>You need a low reserved stack size because the Win32 Fiber API,
which is the mechanism underlying <tt>activity()</tt>, uses
this number as the coroutine stack size, and with 1MiB being the default,
it is easy to run out of the 2GiB possible address space (2GiB/1MiB=2048).

<p>A more detailed explanation follows.
Each fiber has its own stack, by default 1MiB (this is the &#8220;reserved&#8221;
stack space -- i.e. reserved in the address space, but not the full
1MiB is actually &#8220;committed&#8221;, i.e. has physical memory assigned to it).
This means that a 2GiB address space will run out after 2048 fibers,
which is way too few. (In practice, you won't even be able to create
this many fibers, because physical memory is also a limiting factor).
Therefore, the 1MiB reserved stack size (RSS) must be set to a smaller
value: the coroutine stack size requested for the module, plus
the <tt>extra-stack-kb</tt> amount for Cmdenv/Tkenv -- which makes
about 16K with Cmdenv, and about 48K when using Tkenv.
Unfortunately, the CreateFiber() Win32 API doesn't allow the RSS to be
specified. The more advanced CreateFiberEx() API which accepts RSS as
parameter is unfortunately only available from Windows XP.

<p>The alternative is the stacksize parameter stored in the EXE header,
which can be set
via the STACKSIZE .def file parameter, via the /stack linker option,
or on an existing executable using the editbin /stack utility.
This parameter specifies a common RSS for the main program stack,
fiber and thread stacks. 64K should be enough. This is the way the
simulation executable should be created; linked with the /stack:65536
option, or the /stack:65536 parameter applied using editbin later.
For example, after applying the editbin /stacksize:65536 command to
dyna.exe, I was able to successfully run the Dyna sample with 8000
Client modules on my Win2K PC with 256M RAM (that means about 12000
modules at runtime, including about 4000 dynamically created modules.)

<p>
<p class="subheading">&#8220;Segmentation fault&#8221;</p>

<p>On Unix, if you set the total stack size higher, you may get a
segmentation fault during network setup<!--segmentation fault--> (or
during execution if you use dynamically created modules), for exceeding
the operating system limit for maximum stack size. For example, in
Linux 2.4.x, the default stack limit is 8192K (that is, 8MiB). The
<tt>ulimit</tt> shell command can be used to modify the
resource limits, and you can raise the allowed maximum stack size
up to 64M.

<pre class="commandline">
$ ulimit -s 65500
$ ulimit -s
65500
</pre>
<p>
Further increase is only possible if you are root.
Resource limits are inherited by child processes.
The following sequence can be used under Linux to get a shell with
256M stack limit:

<pre class="commandline">
$ su root
Password:
# ulimit -s 262144
# su andras
$ ulimit -s
262144
</pre>
<p>
If you don't want to go through the above process at each login, you
can change the limit in the PAM configuration files. In Redhat Linux
(maybe other systems too), add the following line to
<tt>/etc/pam.d/login</tt>:

<pre class="filelisting">
session    required    /lib/security/pam_limits.so
</pre>
<p>
and the following line to <tt>/etc/security/limits.conf</tt>:

<pre class="filelisting">
*    hard    stack    65536
</pre>
<p>
<p>
A more drastic solution is to recompile the kernel with a larger stack
limit. Edit <tt>/usr/src/linux/include/linux/sched.h</tt> and increase
<tt>_STK_LIM</tt> from <tt>(8*1024*1024)</tt> to <tt>(64*1024*1024)</tt>.
</p>

<p>Finally, if you are tight with memory, you can switch to Cmdenv. Tkenv
increases the stack size of each module by about 32K<!--stack!for
  Tkenv--> so that user interface code that is called from a
simple module's context can be safely executed.
Cmdenv does not need that much extra stack.

<p>
<p class="subheading">Eventually...</p>

<p>Once you get to the point where you have to adjust the total stack size to
get your program running, you should probably consider transforming (some
of) your <tt>activity()</tt> simple modules to <tt>handleMessage()</tt>.
<tt>activity()</tt> does not scale well for large simulations.

<p>

<p><h3><a name="sec378"/>10.6.3 Memory Leaks and Crashes</h3>

<p>The most common problems in C++ are associated with memory allocation
(usage of <tt>new</tt> and <tt>delete</tt>):

<p><ul>
   <li><i>memory leaks,</i> that is, forgetting to delete objects
     or memory blocks no longer used;
   <li><i>crashes,</i> usually due to referring to an already deleted
     object or memory block, or trying to delete one for a second time;
   <li><i>heap corruption</i> (eventually leading to crash) due to
     overrunning allocated blocks, i.e. writing past the end of an allocated
     array.
</ul>

<p>The most common cause of memory leaks in OMNEST simulations is
forgetting to delete messages. Both Tkenv and Cmdenv are able
to display the number of messages currently in the simulation,
helping you to determine if you have such a memory leak;
see section <a href="#sec364">[10.2.4]</a>.
If you find that the number of messages is steadily increasing,
you need to find where the message objects are located. You can do so
by selecting <i>Inspect|From list of all objects...</i> from
the Tkenv menu, and reviewing the list in the dialog that pops up.

<p>If the number of messages is stable, it is still possible
you are leaking other <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based objects. You can
find them using Tkenv's <i>Inspect|From list of all objects...</i>
function as well.

<p>If you are leaking non-<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based objects or just
memory blocks (structs, arrays, etc., allocated by <tt>new</tt>),
you will not be able to find them via Tkenv. You will probably need
a specialized memory debugging tool like the ones described below.

<p><p class="subheading">Memory Debugging Tools</p>

<p>If you suspect that you may have memory allocation problems
(crashes associated with double-deletion or accessing already
deleted block, or memory leaks), you can use specialized tools
to track them down.

<p>By far the most efficient, most robust and most versatile tool
is <i>Valgrind</i>, originally developed for debugging KDE.

<p>Other memory debuggers are <i>NJAMD</i>, <i>MemProf</i>,
<i>MPatrol</i>, <i>dmalloc</i> and <i>ElectricFence</i>.
Most of the above tools support tracking down memory leaks as well as
detecting double deletion, writing past the end of an allocated block, etc.

<p>A proven commercial tool is <i>Rational Purify</i>. It has
a good reputation and has proved its usefulness many times.

<p><h3><a name="sec379"/>10.6.4 Simulation Executes Slowly</h3>

<p>Check the following if you think your simulation is running too slowly:

<p><ul>
  <li> Turn on express mode with the <tt>cmdenv-express-mode=true</tt> configuration option.
  <li> Be sure that event logging is turned off (<tt>record-eventlog=false</tt> configuration option).
  <li> Turn of vector file recording if you don't absolutely need it (<tt>**.vector-recording=false</tt>).
  <li> If you are running under Tkenv, disable animation features, close inspectors,
        hide the timeline, hide object tree, turn off log filtering.
  <li> Compile your code as release instead of debug (in some cases this can give you 5x speedup)
</ul>

<p>
What can you do if the simulation executes much slower than you expect?
The best advice that can be given here is that you should
<b>use a good profiler</b> to find out how much time is spent in each
part of the program. Do not make the mistake of omitting this step,
thinking that you know which part is slow! Even for experienced
programmers, a profiling session is all too often full of surprises.
It often turns out that lots of CPU time is spent in completely
innocent-looking statements, while big and complex algorithms
don't take nearly as much time as you expected. <i>Don't assume anything
-- profile before you optimize!</i>

<p>A great profiler on Linux is the <i>Valgrind</i>-based
<i>callgrind</i>, and its visualizer <i>KCachegrind</i>.
Unfortunately it won't be ported to Windows anytime soon.
On Windows, you are out of luck -- commercial products may help, or,
port your simulation to Linux. The latter goes usually much more smoothly
than one would expect.

<p>

<hr class='pgbr'><h1><a name="sec380"/>11 Network Graphics And Animation</h1>
<a name="cha:graphics"></a>

<p><h2><a name="sec381"/>11.1 Display Strings</h2>
<a name="sec:ch-graphics:display-strings"></a>

<p>Display strings<!--display strings--> specify the arrangement and
appearance of representations of modules in graphical user interfaces (currently only
Tkenv); they control how the objects (compound modules, their
submodules and connections) are displayed. Display strings are specified in
NED's <b><tt>@display</tt></b> property.

<p>Display strings can be used in the following contexts:
<ul>
  <li> <i>submodules</i> -- display strings may contain position, arrangement
        (for module vectors), icon, icon color, auxiliary icon, status text,
        communication range (as circle or filled circle), tooltip, etc.
  <li> <i>compound modules, networks</i> -- display strings can specify
        background color, border color, border width,
        background image, scaling, grid, unit of measurement, etc.
  <li> <i>connections</i> -- display strings can specify positioning, color,
        line width, line style, text and tooltip
  <li> <i>messages</i> -- display strings can specify icon, icon color, etc.
</ul>

<p>
<h3><a name="sec382"/>11.1.1 Display String Syntax</h3>

<p>The display string syntax is a semicolon-separated list of tags.
Each tag consists of a key, an equal sign and a comma-separated list of
arguments:

<pre class="ned">
@display("p=100,100;b=60,10,rect,blue,black,2")
</pre>
<p>
Tag arguments may be omitted both at the end and inside the
parameter list. If an argument is omitted, a sensible default value is used.

<pre class="ned">
@display("p=100,100;b=,,rect,blue")
</pre>
<p>
<h3><a name="sec383"/>11.1.2 Display String Placement</h3>

<p>The following NED sample shows where to place display strings in the code:

<pre class="ned">
simple Queue
{
    parameters:
        @display("i=block/queue");
    ...
}

network SimpleQueue
{
    parameters:
        @display("bgi=maps/europe");
    submodules:
        sink: Sink {
            @display("p=273,101");
        }
        ...
    connections:
        source.out --&gt; { @display("ls=red,3"); } --&gt; queue.in++;
}
</pre>
<p>
<h3><a name="sec384"/>11.1.3 Display String Inheritance</h3>

<p>Every module and channel object has one single display string object,
which controls its appearance in various contexts. The initial value of
this display string object comes from merging the <b><tt>@display</tt></b>
properties occurring at various places in NED files.
This section describes the rules for merging <b><tt>@display</tt></b> properties
to create the module or channel's display string.

<p><ul>
  <li> Derived NED types inherit their display string from their base NED type.
  <li> Submodules inherit their display string from their type.
  <li> Connections inherit their display string from their channel type.
</ul>

<p>The base NED type's display string is merged into the current display string
using the following rules:

<p><ul>
  <li> If a tag is present in the base display string, but not in the current one
        the whole tag (with all arguments) is added to the current display string.
        (e.g. base: <tt>"i=icon,red"</tt> current: <tt>"p=2,4"</tt> result: <tt>"p=2,4;i=icon,red"</tt>)
  <li> If a tag is present both in the base and in the current display string
        only tag arguments present in the base, but not in the current display string
        will be copied.
        (e.g. base: <tt>"b=40,20"</tt> current: <tt>"b=,30,oval"</tt> result: <tt>"b=40,30,oval"</tt>)
  <li> If the current display string contains a tag argument with value "-" (hyphen)
        that argument is treated as empty and will not be inherited from other
        display strings. Requesting the value of this argument will return its the
        default value.
  <li> If neither the base display string nor the current one has value for a tag
        a suitable default value will be returned and used.
</ul>

<p>Example of display string inheritance:

<pre class="ned">
simple Base {
    @display("i=block/queue"); // use a queue icon in all instances
}

simple Derived extends Base {
    @display("i=,red,60");  // ==&gt; "i=block/queue,red,60"
}

network SimpleQueue {
    submodules:
        submod: Derived {
            @display("i=,yellow,-;p=273,101;r=70");
                     // ==&gt; "i=block/queue,yellow;p=273,101;r=70"
        }
        ...
}
</pre>
<p>

<p><h3><a name="sec385"/>11.1.4 Display String Tags Used in Submodule Context</h3>

<p>The following tags define how a module appears on the Tkenv user interface
if it is used as a submodule:
<ul>
  <li><tt>b</tt> -- shapes, colors
  <li><tt>i</tt> -- icon
  <li><tt>is</tt> -- icon size
  <li><tt>i2</tt> -- alternate (status) icon placed at the upper right corner of the main icon
  <li><tt>p</tt> -- positioning and layout
  <li><tt>r</tt> -- range indicator
  <li><tt>q</tt> -- queue information text
  <li><tt>t</tt> -- text
  <li><tt>tt</tt> -- tooltip
</ul>

<p><p class="subheading">Icons</p>
By default, modules are represented by simple icons.
Using images for the modules is possible with the <tt>i</tt> tag.
See the <tt>images</tt> subfolder of your OMNeT++ installation for possible
icons. The stock images installed with OMNeT++ have several size variants.
Most of them have very small (vs), small (s), large (l) and
very large (vl) variants. You can specify which variant you want to use with
the <tt>is</tt> tag.

<pre class="ned">
@display("i=block/source;is=l"); // a large source icon from the block icons group
</pre>
<p>
Sometimes you want to have similar icons for modules, but would like to
make them look a little different to create groups or to reflect status
information about the module. You can easily change the color of an already existing image.
The following example colorizes the <tt>block/source</tt> icon, 20% red

<pre class="ned">
@display("i=block/source,red,20")
</pre>
<p>
<center>
<img src="graphics-itag.png">
</center>

<p>If you want to show state information about your module, you can use the <tt>i2</tt> tag to
add a small status icon to your main icon. This icon is displayed in the upper right corner
of your main icon. In most cases the <tt>i2</tt> tag is specified at runtime using
the <tt>setDisplayString()</tt> method, so the icon can be changed dynamically based on the
module's internal state.

<pre class="ned">
@display("i=block/queue;i2=status/busy")
</pre>
<p>
<center>
<img src="graphics-i2tag.png">
</center>

<p><p class="subheading">Shapes</p>

<p>If you want to have simple, but resizable representation for your module, you can use
the <tt>b</tt> tag to create geometric shapes. Currently <tt>oval</tt> and <tt>rectangle</tt>
is supported:

<pre class="ned">
// an oval shape with 70x30 size, red background, black 4 pixel border
@display("b=70,30,oval,red,black,4")
</pre>
<p>
<center>
<img src="graphics-btag.png">
</center>

<p><p class="subheading">Positioning, Coordinates</p>

<p>To define the position of a module inside an other one use the <tt>p</tt> tag.
If you do not specify a <tt>p</tt> tag for your module, the parent module will
automatically choose a position based on a layout algorithm.
The following example will place the module at the given position:
<pre class="ned">
@display("p=50,79");
</pre>

<p><ul class="note"><b>NOTE</b><br>
The coordinates specified in the <tt>p</tt>, <tt>b</tt> or <tt>r</tt> tags are not necessarily
integers and measured in pixels. You can use the parent module's <tt>bgs=<i>pix2unitratio</i>,<i>unit</i></tt> tag,
to set the scaling parameter and the unit of measurement for your module.
You can specify the ratio between 1 pixel and 1 unit with the <tt>bgs</tt> tag.
</ul>

<p>The <tt>p</tt> tag allows the automatic arrangement of module vectors. They can be
arranged in a row, a column, a matrix or a ring, or you may specify their positions
later at runtime using the <tt>setDisplayString()</tt> method. The rest of the arguments
in the <tt>p</tt> tag depend on the layout type:

<p><ul>
  <li> <tt>row -- p=100,100,r,<i>deltaX</i></tt> (A row of modules with <i>deltaX</i> units between the modules)
  <li> <tt>column -- p=100,100,c,<i>deltaY</i></tt> (A column of modules with <i>deltaX</i> units between the modules)
  <li> <tt>matrix -- p=100,100,m,<i>noOfCols</i>,<i>deltaX</i>,<i>deltaY</i></tt> (A matrix with <i>noOfCols</i> columns.
            <i>deltaX</i> and <i>deltaY</i> units between rows and columns)
  <li> <tt>ring -- p=100,100,ri,<i>rx</i>,<i>ry</i></tt> (A ring (oval) with <i>rx</i> and <i>ry</i> as the horizontal and vertical radius.)
  <li> <tt>exact (default) -- p=100,100,x,<i>deltaX</i>,<i>deltaY</i></tt> (Place each module at <i>(100+deltaX, 100+deltaY)</i>.
            The coordinates are usually set at runtime.)
</ul>

<p>A matrix layout for a module vector:

<pre class="ned">
@display("p=,,m,4,50,50");
</pre>
<p>

<p>  <center>
    <img src="graphics-ptag.png">
    <center><i>Figure: Matrix arrangement using the <i>p</i> tag</i></center>
    <a name="fig:graphics-ptag"></a>
  </center>

<p>
<p class="subheading">Wireless Range</p>
In wireless simulations it is very useful to show some kind of range
around your module. This can be an interference range, transmission range
etc. The following example will place the module at a given position,
and draw a circle with a 90-unit radius around it as a range indicator:

<pre class="ned">
submodules:
    ap: AccessPoint {
        @display("p=50,79;r=90");
    }
</pre>
<p>

<p>  <center>
    <img src="graphics-rtag.png">
    <center><i>Figure: Range indicator using the <i>r</i> tag</i></center>
    <a name="fig:graphics-rtag"></a>
  </center>

<p>
<p class="subheading">Additional Decorations</p>
Sometimes you want to annotate your modules with additional information
to make your model more transparent. One special case is when you want to
show the length of a queue (<tt><a href="../api/classcQueue.html">cQueue</a></tt>) embedded somewhere in a module.
In the following example the Server simple module contains a <tt><a href="../api/classcQueue.html">cQueue</a></tt> object,
which was named by the <tt>queue.setName("procqueue")</tt> method.
If we specify <tt>q=procqueue</tt> in the display string, Tkenv will descend into
the module (several levels deep if needed) and look for a queue object
named "procqueue". It will display the length of the queue object along the module.

<pre class="ned">
@display("q=procqueue");
</pre>
<p>
<center>
<img src="graphics-qtag.png">
</center>

<p>You can add a text description to any module using the <tt>t</tt>
(displayed along the module) or <tt>tt</tt> tag (displayed as a tooltip).
The following example displays a short text string along with the module
and adds a tooltip text string that can be seen by hovering over
them module with the mouse.

<pre class="ned">
@display("t=Packets sent: 18;tt=Additional tooltip information");
</pre>
<p>
<center>
<img src="graphics-ttag.png">
</center>

<p><ul class="note"><b>NOTE</b><br>
  The <tt>t</tt> and <tt>tt</tt> tags, when set at runtime, can be used to display
  various information about the module's state. The <tt>setTagArg()</tt> method
  of <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> can be used to update the text:

  <pre class="cpp">
char buf[64];
sprintf(buf, "sent: %d, rcvd: %d", numPkSent, numPkReceived);
getDisplayString().setTagArg("t", 0, buf);
  </pre>
<p>
</ul>

<p>For a detailed descripton of the display string tags, check
Appendix <a href="#sec563">[24]</a>.

<p><h3><a name="sec386"/>11.1.5 Display String Tags Used in Module Background Context</h3>

<p>The following tags describe what a module looks like when opened in
Tkenv. They mostly deal with the module background.

<p><ul>
  <li> <tt>bgi</tt> -- background image
  <li> <tt>bgtt</tt> -- tooltip above the background
  <li> <tt>bgg</tt> -- background grid
  <li> <tt>bgl</tt> -- child layout
  <li> <tt>bgb</tt> -- background size, color, border
  <li> <tt>bgs</tt> -- scaling of background coordinates
  <li> <tt>bgp</tt> -- background coordinate offset
</ul>

<p>The <tt>bgs</tt> tag makes it possible to use a physical unit of measurement,
(e.g. kilometers) for coordinates. <tt>bgs</tt> arguments include a pixel-per-unit
factor (for mapping coordinates to the screen), and a unit name. When <tt>bgs</tt>
is present, all coordinates (including submodule coordinates) are interpreted
in the given unit of measurement. When combined with the <tt>bgi</tt> (background
image) and <tt>bgg</tt> (grid) tags, it is possible to display maps.

<p>The following example demonstrates the use the of module background tags.
The coordinates are given in km (SI unit). The <tt>bgs=<i>pixelsperunit</i>,<i>unit</i></tt>
specifies pixel/unit ratio, i.e. 1km is 0.075 pixel on the screen.
The whole area is 6000x4500km (<tt>bgb=</tt>) and the map of Europe is used as a
background and stretched to fill the module background.
A light grey grid is drawn with a 1000km distance between major ticks,
and 2 minor ticks per major tick (<tt>bgg=tickdistance,minorpermajorticks,color</tt>).
See Figure <a href="#fig:graphics-bgtags">below</a>.

<pre class="ned">
network EuropePlayground
{
    @display("bgb=6000,4500;bgi=maps/europe,s;bgg=1000,2,grey95;bgs=0.075,km");
</pre>
<p>

<p>  <center>
    <img src="graphics-bgtags.png">
    <center><i>Figure: Background grid, scaling and image</i></center>
    <a name="fig:graphics-bgtags"></a>
  </center>

<p>
After specifying the above <tt>bgs</tt> tag, all your submodule coordinates will be treated as if
they were specified in km.

<p>For a detailed descripton of the display string tags, check
Appendix <a href="#sec563">[24]</a>.

<p><h3><a name="sec387"/>11.1.6 Connection Display Strings</h3>

<p>Connections may also have display strings. Connections inherit the
display string property from their channel types, in the same way as
submodules inherit theirs from module types. The default display
strings are empty.

<p>Connections support the following tags:
<ul>
  <li><tt>ls</tt> -- line style and color
  <li><tt>t</tt> -- text
  <li><tt>tt</tt> -- tooltip
  <li><tt>m</tt> -- orientation and positioning
</ul>

<p>Example of a thick, red connection:
<pre class="ned">
source1.out --&gt; { @display("ls=red,3"); } --&gt; queue1.in++;
</pre>

<p><center>
<img src="graphics-lstag.png">
</center>

<p><ul class="note"><b>NOTE</b><br>
If you want to hide a connection, specify zero line width in the display
string (<tt>"ls=,0"</tt>).
</ul>

<p>For a detailed descripton of the display string tags, check
Appendix <a href="#sec563">[24]</a>.

<p><h3><a name="sec388"/>11.1.7 Message Display Strings</h3>

<p>Message display strings affect how messages are shown during animation.
By default, they are displayed as a small filled circle, in one of
8 basic colors (the color is determined as <i>message kind modulo 8</i>),
and with the message class and/or name displayed under it.
The latter is configurable in the Tkenv Options dialog, and message kind
dependent coloring can also be turned off there.

<p><p class="subheading">Specifying Message Display Strings</p>

<p>Message objects do not store a display string by default, but you can redefine
the <tt><a href="../api/classcMessage.html">cMessage</a></tt>'s <tt>getDisplayString()</tt> method and make it return
one.

<p>Example of using an icon to represent a message:

<pre class="cpp">
const char *CustomPacket::getDisplayString() const
{
    return "i=msg/packet;is=vs";
}
</pre>
<p>
Alternatively, you can add the field <tt>displayString</tt> to your message
definition (.msg file), and the message compiler will automatically generate
<tt>setDisplayString()</tt> and <tt>getDisplayString()</tt> methods for you:

<pre class="msg">
message Job
{
    string displayString = "i=msg/package_s,kind";
...
</pre>
<p>
<p class="subheading">Message Display String Tags</p>

<p>The following tags can be used in message display strings:
<ul>
  <li><tt>b</tt> -- shapes, colors
  <li><tt>i</tt> -- icon
  <li><tt>is</tt> -- icon size
</ul>

<p>Using a small red box icon to represent the messages:

<pre class="ned">
@display("i=msd/box,red;is=s");
</pre>
<p>
Messages will be represented by a 15x15 rectangle with white background.
Their border color will depend on the <tt>messageKind</tt> property of the message.

<pre class="ned">
@display("b=15,15,rect,white,kind,5");
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
   In message display strings you may use the word <tt>kind</tt> as a special color.
   This virtual color depends on the <tt>messageKind</tt> field in the message.
</ul>

<p>

<p><h2><a name="sec389"/>11.2 Parameter Substitution</h2>

<p>Parameters of the module or channel containing the
display string can be substituted into the display string
with the <tt>$parameterName</tt> notation:

<p>Example:

<pre class="ned">
simple MobileNode
{
    parameters:
        double xpos;
        double ypos;
        string fillColor;
        // get the values from the module parameters xpos,ypos,fillcolor
        @display("p=$xpos,$ypos;b=60,10,rect,$fillColor,black,2");
}
</pre>
<p>
<h2><a name="sec390"/>11.3 Colors</h2>
<a name="sec:ch-graphics:colors"></a>

<p><h3><a name="sec391"/>11.3.1 Color Names</h3>

<p>Any valid Tk color specification is accepted: English color names
(blue, lightgrey, wheat) or <i>#rgb</i>, <i>#rrggbb</i> format
(where <i>r</i>,<i>g</i>,<i>b</i> are hex digits).

<p>It is also possible to specify colors in HSB (hue-saturation-brightness) as
<i>@hhssbb</i> (with <i>h</i>, <i>s</i>, <i>b</i> being hex digits).
HSB makes it easier to scale colors e.g. from white to bright red.

<p>You can produce a transparent background by specifying a hyphen (<i>"-"</i>)
as background color.

<p>In message display strings, <tt>kind</tt> can also be used as a special color name.
It will map to a color depending on the message kind.
(See the <tt>getKind()</tt> method of <tt><a href="../api/classcMessage.html">cMessage</a></tt>.)

<p><h3><a name="sec392"/>11.3.2 Icon Colorization</h3>

<p>The <tt>"i="</tt> display string tag allows for colorization of icons.
It accepts a target color and a percentage as the degree of colorization.
Percentage has no effect if the target color is missing.
Brightness of the icon is also affected -- to keep the original brightness,
specify a color with about 50% brightness (e.g. #808080 mid-grey,
#008000 mid-green).

<p>Examples:

<p><ul>
  <li> <tt>"i=device/server,gold"</tt> creates a gold server icon
  <li> <tt>"i=misc/globe,#808080,100"</tt> makes the icon greyscale
  <li> <tt>"i=block/queue,white,100"</tt> yields a "burnt-in" black-and-white icon
</ul>

<p>Colorization works with both submodule and message icons.

<p>
<h2><a name="sec393"/>11.4 Icons</h2>
<a name="sec:ch-graphics:icon-library"></a>

<p><h3><a name="sec394"/>11.4.1 The Image Path</h3>

<p>In the current OMNeT++ version, module icons are PNG or GIF files. The icons shipped
with OMNeT++ are in the <tt>images/</tt> subdirectory. Both the graphical NED editor
and Tkenv need the exact location of this directory to load the icons.

<p>Icons are loaded from all directories in the <i>image path</i>,
a semicolon-separated list of directories.
The default image path is compiled into Tkenv with the value
<tt>"<i>omnetpp-dir</i>/images; ./images;./bitmaps"</tt> -- which will work fine
as long as you don't move the directory, and you will also be able to
load more icons from the <tt>images/</tt> subdirectory of the current
directory. As users typically run simulation models from the model's
directory, this practically means that custom icons placed in the
<tt>images/</tt> subdirectory of the model's directory are automatically
loaded.

<p>The compiled-in image path can be overridden with the <tt>OMNETPP_IMAGE_PATH</tt>
environment variable. The way of setting environment variables is system
specific: in Unix, if you are using the bash shell, adding a line

<pre class="commandline">
export OMNETPP_IMAGE_PATH="/home/you/images;./images"
</pre>
<p>
to <tt>\~/.bashrc</tt> or <tt>\~/.bash_profile</tt> will do; on Windows, environment variables
can be set via the <i>My Computer --&gt; Properties</i> dialog.

<p>You can extend the image path from <tt>omnetpp.ini</tt> with the
<tt>tkenv-image-path</tt> option, which is prepended to the environment
variable's value.

<pre class="inifile">
[General]
tkenv-image-path = "/home/you/model-framework/images;/home/you/extra-images"
</pre>
<p>

<p><h3><a name="sec395"/>11.4.2 Categorized Icons</h3>

<p>Since OMNeT++ 3.0, icons are organized into several categories, represented
by folders. These categories include:

<p><ul>
  <li> block/ - icons for subcomponents (queues, protocols, etc).
  <li> device/ - network devices: servers, hosts, routers, etc.
  <li> abstract/ - symbolic icons for various devices
  <li> misc/ - node, subnet, cloud, building, town, city, etc.
  <li> msg/ - icons that can be used for messages
</ul>

<p>Old (pre-3.0) icons are in the <tt>old/</tt> folder.

<p>Tkenv and the IDE now load icons from subdirectories of all directories
of the image path, and these icons can be referenced from display strings
by naming the subdirectory (subdirectories) as well:
<tt>"subdir/icon"</tt>, <tt>"subdir/subdir2/icon"</tt>, etc.

<p>For compatibility, if the display string contains an icon without
a category (i.e. subdirectory) name, OMNeT++ attempts to load it from "old/icon" as well.

<p><h3><a name="sec396"/>11.4.3 Icon Size</h3>

<p>Icons come in various sizes: normal, large, small, very small. Sizes are
encoded into the icon name's suffix: <tt>_vl</tt>, <tt>_l</tt>, <tt>_s</tt>, <tt>_vs</tt>.
In display strings, one can either use the suffix (<tt>"i=device/router_l"</tt>),
or the <tt>"is</tt>" (<i>icon size</i>) display string tag (<tt>"i=device/router;is=l"</tt>),
but not both at the same time (we recommend using the <tt>is</tt> tag whenever possible).


<h2><a name="sec397"/>11.5 Layouting</h2>
<a name="sec:ch-graphics:layouting"></a>

<p>OMNeT++ implements an automatic layouting feature, using
a variation of the SpringEmbedder algorithm. Modules which have
not been assigned explicit positions via the <tt>"p="</tt> tag will be
automatically placed by the algorithm.

<p>SpringEmbedder is a graph layouting algorithm based on a physical model.
Graph nodes (modules) repel each other like electric charges
of the same sign, and connections are sort of springs which try
to contract and pull the nodes they're attached to together. There is also friction
built in, in order to prevent oscillation of the nodes. The layouting algorithm
simulates this physical system until it reaches equilibrium
(or times out). The physical rules above have been slightly tweaked
to achieve better results.

<p>The algorithm doesn't move any module which has fixed coordinates.
Predefined row, matrix, ring or other arrangements (defined
via the 3rd and further args of the <tt>"p="</tt> tag) will be preserved --
you can think about them as if those modules were attached
to a rigid framework so that they can only move as one unit.

<p>Caveats:

<p><ul>
  <li> If the full graph is too big after layouting, it is scaled
    back so that it fits on the screen, <i>unless it contains
    any fixed-position module</i>. (For obvious reasons: if there is a module
    with manually specified position, we don't want to move that one).
    To prevent rescaling, you can specify a sufficiently large bounding
    box in the background display string, e.g. <tt>"b=2000,3000"</tt>.
  <li> Size is ignored by the present layouter, so longish modules
    (such as an Ethernet segment) may produce funny results.
  <li> The algorithm is prone to produce erratic results, especially
    when the number of submodules is small, or when using predefined
    (matrix, row, ring, etc) layouts. The "Re-layout" toobar button
    can then be very useful. Larger networks usually produce
    satisfactory results.
  <li> The algorithm is starting from random positions.
     To get the best results you may experiment with
    different seeds by specifying them using the <tt>bgl=<i>seed</i></tt>
    display string tag.
</ul>

<p><h2><a name="sec398"/>11.6 Enhancing Animation</h2>

<p><h3><a name="sec399"/>11.6.1 Changing Display Strings at Runtime</h3>

<p>Often it is useful to manipulate the display string at runtime.
Changing colors, icon, or text may convey status change, and
changing a module's position is useful when simulating mobile
networks.

<p>Display strings are stored in <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> objects inside
channels, modules and gates. <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> also lets you
manipulate the string.

<p>To get a pointer to the <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> object, you can call
the components's <tt>getDisplayString()</tt> method:

<pre class="cpp">
// Setting a module's position, icon and status icon:
<a href="../api/classcDisplayString.html">cDisplayString</a>& dispStr = getDisplayString();
dispStr.parse("p=40,20;i=device/cellphone;i2=status/disconnect");
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
The connection display string is stored in the channel object, but it
can also be accessed via the source gate of the connection.
</ul>

<pre class="cpp">
// Setting an outgoing connection's color to red:
<a href="../api/classcDisplayString.html">cDisplayString</a>& connDispStr = gate("out")-&gt;getDisplayString();
connDispStr.parse("ls=red");
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
In OMNeT++ 3.x, to manipulate the appearance of a compound module you had to use
the <tt>backgroundDisplayString()</tt> method. This method is no longer
supported in OMNeT++ 4.0, because there is no separate background display string.
Use the <tt>getDisplayString()</tt> method instead with the background
specific tags, i.e. those starting with <tt>bg</tt>.
</ul>

<pre class="cpp">
// Setting module background and grid with background display string tags:
<a href="../api/classcDisplayString.html">cDisplayString</a>& parentDispStr = getParentModule()-&gt;getDisplayString();
parentDispStr.parse("bgi=maps/europe;bgg=100,2");
</pre>
<p>
As far as <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> is concerned, a display string
(e.g. <tt>"p=100,125;i=cloud"</tt>) is a string that consist of several
<i>tags</i> separated by semicolons, and each tag has a <i>name</i>
and after an equal sign, zero or more <i>arguments</i> separated by commas.

<p>The class facilitates tasks such as finding out what tags a display string
has, adding new tags, adding arguments to existing tags,
removing tags or replacing arguments. The internal storage method allows
very fast operation; it will generally be faster than direct string manipulation.
The class doesn't try to interpret the display string in any way, nor does
it know the meaning of the different tags; it merely parses the string
as data elements separated by semicolons, equal signs and commas.

<p>An example:

<pre class="cpp">
dispStr.parse("a=1,2;p=alpha,,3");
dispStr.insertTag("x");
dispStr.setTagArg("x",0,"joe");
dispStr.setTagArg("x",2,"jim");
dispStr.setTagArg("p",0,"beta");
ev &lt;&lt; dispStr.str();  // result: "x=joe,,jim;a=1,2;p=beta,,3"
</pre>
<p>
<h3><a name="sec400"/>11.6.2 Bubbles</h3>

<p>Modules can let the user know about important events (such as a node
going down or coming up) by displaying a bubble with a short message
("Going down", "Coming up", etc.) This is done by the <tt>bubble()</tt> method
of <tt><a href="../api/classcComponent.html">cComponent</a></tt>. The method takes the string to be displayed
as a <tt>const char *</tt> pointer.

<p>An example:
<pre class="cpp">
bubble("Collision! (2 frames)");
</pre>

<p><center>
<img src="graphics-bubble.png">
</center>

<p>If the module contains a lot of code that modifies the display string or
displays bubbles, it is recommended to make these calls conditional
on <tt>ev.isGUI()</tt>. The <tt>ev.isGUI()</tt> call returns <i>false</i>
when the simulation is run under Cmdenv, so one can make the code skip
potentially expensive display string manipulation.

<p>Better:
<pre class="cpp">
if (ev.isGUI())
    bubble("Going down!");
</pre>


<hr class='pgbr'><h1><a name="sec401"/>12 Result Recording and Analysis</h1>
<a name="cha:analyzing-simulation-results"></a>

<p><h2><a name="sec402"/>12.1 Result Recording</h2>

<p>OMNeT++ provides built-in support for recording simulation results, via
<i>output vectors</i> and <i>output scalars</i>. Output vectors are
time series data, recorded from simple modules or channels. You can use
output vectors to record end-to-end delays or round trip times of packets,
queue lengths, queueing times, module state, link utilization, packet
drops, etc. -- anything that is useful to get a full picture of what
happened in the model during the simulation run.

<p>Output scalars are summary results, computed during the simulation and
written out when the simulation completes. A scalar result may be an
(integer or real) number, or may be a statistical summary comprised of
several fields such as count, mean, standard deviation, sum, minimum,
maximum, etc., and optionally histogram data.

<p>Results may be collected and recorded in two ways:

<p><ol>
  <li> Based on the signal mechanism, using declared statistics;
  <li> Directly from C++ code, using the simulation library
</ol>

<p>The second method has been the traditional way of recording results. The
first method, based on signals and declared statistics, was introduced in
OMNeT++ 4.1, and it is preferable because it allows you to always record the
results in the form you need, without requiring heavy instrumentation or
continuous tweaking of the simulation model.

<p><h3><a name="sec403"/>12.1.1 Using Signals and Declared Statistics</h3>

<p>This approach combines the signal mechanism (see
<a href="#sec191">[4.14]</a>) and NED properties (see
<a href="#sec135">[3.12]</a>) in order to de-couple the generation of
results from their recording, thereby providing more flexibility in what to
record and in which form. The details of the solution have been described
in section <a href="#sec195">[4.15]</a> in detail; here we
just give a short overview.

<p>Statistics are declared in the NED files with the <tt>@statistic</tt> property,
and modules emit values using the signal mechanism. The simulation framework
records data by adding special result file writer listeners to the signals.
By being able to choose what listeners to add, the user can control what to
record in the result files and what computations to apply before recording.
The aforementioned section <a href="#sec195">[4.15]</a>
also explains how to instrument simple modules and channels for signals-based
result recording.

<p>The signals approach allows for calculation of aggregate statistics (such as the
total number of packet drops in the network) and for implementing a warm-up
period without support from module code. It also allows you to write
dedicated statistics collection modules for the simulation, also without
touching existing modules.

<p>The same configuration options that were used to control result recording
with <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> and <tt>recordScalar()</tt> also work when utilizing
the signals approach, and there are extra configuration options to make
the additional possibilities accessible.

<p><h3><a name="sec404"/>12.1.2 Direct Result Recording</h3>

<p>With this approach, scalar and statistics results are collected in class
variables inside modules, then recorded in the finalization phase via
<tt>recordScalar()</tt> calls. Vectors are recorded using
<tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects. To record more details, like the
minimum/maximum value or the standard deviation, <tt><a href="../api/classcStdDev.html">cStdDev</a></tt> and
<tt><a href="../api/classcWeightedStdDev.html">cWeightedStdDev</a></tt> can be used, and for recording the distribution
there are histogram and other distribution estimation classes
(<tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>, <tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt>, <tt><a href="../api/classcPSquare.html">cPSquare</a></tt>,
<tt><a href="../api/classcKSplit.html">cKSplit</a></tt>, and others). These classes are described in sections
<a href="#sec286">[7.8]</a> and <a href="#sec291">[7.9]</a>.
Recording of individual vectors, scalars and statistics can be enabled or
disabled via the configuration (ini file), and it is also the place to set
up recording intervals for vectors.

<p>The drawback of recording results directly from modules is that result
recording is hardcoded in modules, and even simple requirement changes
(e.g. record the average delay instead of each delay value, or vice versa)
requires either code change or an excessive amount of result collection
code in the modules.

<p>

<p><h2><a name="sec405"/>12.2 Configuring Result Collection</h2>
<a name="sec:ana-sim:config-results"></a>

<p><h3><a name="sec406"/>12.2.1 Configuring Signal-Based Statistics Recording</h3>
<a name="sec:ana-sim:signal-based-recording"></a>

<p>Signal-based statistics recording has been designed so that it can be
easily configured to record a &#8220;default minimal&#8221; set of results, a
&#8220;detailed&#8221; set of results, and a custom set of results (by modifying
the previous ones, or defined from scratch).

<p>Recording can be tuned with the <b><tt>result-recording-modes</tt></b>
per-object configuration option. The &#8220;object&#8221; here is the statistic,
which is identified by the full path (hierarchical name) of the module or
connection channel object in question, plus the name of the statistic
(which is the &#8220;index&#8221; of <b><tt>@statistic</tt></b> property, i.e. the name in
the square brackets). Thus, configuration keys have the syntax
<i>&lt;module-full-path&gt;.&lt;statistic-name&gt;.</i><tt>result-recording-modes=</tt>.

<p>The <b><tt>result-recording-modes</tt></b> option accepts one or more items as value,
separated by comma. An item may be a result recording mode (surprise!), and
two words with a special meaning, <tt>default</tt> and <tt>all</tt>:

<p><ul>
<li> A <i>result recording mode</i> means any item that may occur in the
      <tt>record</tt> key of the <b><tt>@statistic</tt></b> property; for example,
      <tt>count</tt>, <tt>sum</tt>, <tt>mean</tt>, <tt>vector((count-1)/2)</tt>.
<li> <b><tt>default</tt></b> stands for the set of non-optional items from
      the <b><tt>@statistic</tt></b> property's <tt>record</tt> list, that is, those
      without question marks.
<li> <b><tt>all</tt></b> means all items from the <b><tt>@statistic</tt></b> property's
      <tt>record</tt> list, including the ones with question marks.
</ul>

<p>The default value is <tt>default</tt>.

<p>A lone &#8220;-&#8221; as option value disables all recording modes.

<p><i>Recording mode</i> items in the list may be prefixed with &#8220;+&#8221; or
&#8220;-&#8221; to add/remove them from the set of result recording modes. The
initial set of result recording modes is <tt>default</tt>; if the first item
is prefixed with &#8220;+&#8221; or &#8220;-&#8221;, then that and all subsequent items are
understood as modifying the set; if the first item does not start with with
&#8220;+&#8221; or &#8220;-&#8221;, then it replaces the set, and further items are understood
as modifying the set.

<p>This sounds more complicated than it is; an example will make it clear.
Suppose we are configuring the following statistic:

<pre class="ned">
@statistic[foo](record=count,mean,max?,vector?);
</pre>
<p>
With the following the ini file lines (see results in comments):

<pre class="inifile">
**.result-recording-modes = default  # --&gt; count, mean
**.result-recording-modes = all      # --&gt; count, mean, max
**.result-recording-modes = -        # --&gt; none
**.result-recording-modes = mean     # --&gt; only mean (disables 'default')
**.result-recording-modes = default,-vector,+histogram # --&gt; count,mean,histogram
**.result-recording-modes = -vector,+histogram      # --&gt; same as above
**.result-recording-modes = all,-vector,+histogram  # --&gt; count,mean,max,histogram
</pre>
<p>
Here is another example which shows how to write a more specific option
key. The following line applies to <tt>queueLength</tt> statistics of
<tt>fifo[]</tt> submodule vectors anywhere in the network:

<pre class="inifile">
**.fifo[*].queueLength.result-recording-modes = +vector  # default modes plus vector
</pre>
<p>
In the result file, the recorded scalars will be suffixed with the recording mode,
i.e. the mean of <tt>queueingTime</tt> will be recorded as <tt>queueingTime:mean</tt>.

<p><ul class="note"><b>NOTE</b><br>
Signal-based statistics recording forms a layer above the normal scalar and
vector recording infrastructure, so options like <b><tt>scalar-recording</tt></b>,
<b><tt>vector-recording</tt></b>, <b><tt>vector-recording-intervals</tt></b> also affect it.
These options are described in the following sections.
</ul>

<p>
<h3><a name="sec407"/>12.2.2 Warm-up Period</h3>
<a name="sec:ana-sim:warmup-period"></a>

<p>The <b><tt>warmup-period</tt></b> option specifies the length of the initial
warm-up period. When set, results belonging to the first <i>x</i> seconds
of the simulation will not be recorded into output vectors, and will
not be counted into the calculation of output scalars.
This option is useful for steady-state simulations. The default is 0s
(no warmup period).

<p>Example:

<pre class="inifile">
warmup-period = 20s
</pre>
<p>
Results recorded via signal-based statistics automatically obey the warm-up
period setting, but modules that compute and record scalar results
manually (via <tt>recordScalar()</tt>) need to be modified so that they take
the warm-up period into account.

<p><ul class="note"><b>NOTE</b><br>
When configuring a warm-up period, make sure that modules that compute and
record scalar results manually via <tt>recordScalar()</tt> actually obey the
warm-up period in the C++ code.
</ul>

<p>The warm-up period is available via the <tt>getWarmupPeriod()</tt> method of
the <tt>simulation</tt> object, so the C++ code that updates the corresponding
state variables needs to be surrounded with an <i>if</i> statement:

<p>Old:

<pre class="cpp">
dropCount++;
</pre>
<p>
New:

<pre class="cpp">
if (simTime() &gt;= simulation.getWarmupPeriod())
    dropCount++;
</pre>
<p>

<p><h3><a name="sec408"/>12.2.3 Result File Names</h3>

<p>Simulation results are recorded into <i>output scalar files</i> that
actually hold statistics results as well, and <i>output vector
files</i>. The usual file extension for scalar files is <tt>.sca</tt>, and
for vector files <tt>.vec</tt>.

<p>Every simulation run generates a single scalar file and a vector file.
The file names can be controlled with the <b><tt>output-vector-file</tt></b>
and <b><tt>output-scalar-file</tt></b> options. These options rarely need
to be used, because the default values are usually fine. The defaults
are:

<pre class="inifile">
output-vector-file = "${resultdir}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}-${runnumber}.sca"
</pre>
<p>
Here, <tt>${resultdir}</tt> is the value of the <b><tt>result-dir</tt></b>
configuration option which defaults to <tt>results/</tt>, and
<tt>${configname}</tt> and <tt>${runnumber}</tt> are the name of
the configuration name in the ini file (e.g. <tt>[Config PureAloha]</tt>),
and the run number. Thus, the above defaults generate file names
like <tt>results/PureAloha-0.vec</tt>, <tt>results/PureAloha-1.vec</tt>,
and so on.

<p><ul class="note"><b>NOTE</b><br>
  In OMNeT++ 3.x, the default result file names were <tt>omnetpp.vec</tt> and
  <tt>omnetpp.sca</tt>, and scalar files were always appended to, rather than
  being overwritten as in the 4.x version. When needed, the old behavior
  for scalar files can be turned back on by setting
  <tt>output-scalar-file-append=true</tt> in the configuration.
</ul>

<p>
<h3><a name="sec409"/>12.2.4 Configuring Scalar Results</h3>
<a name="sec:ana-sim:scalar-results"></a>

<p>Recording results into the scalar file can be turned off globally by adding
the following line to the ini file. Any existing file with the same name
will still be removed before the simulation starts.

<pre class="inifile">
**.scalar-recording = false
</pre>
<p>
Recording scalar results can be enabled or disabled individually, using
patterns. The syntax of the configuration option is
<i>&lt;module-full-path&gt;.&lt;scalar-name&gt;.</i><tt>scalar-recording=</tt><i>true/false</i>,
where both <i>&lt;module-full-path&gt;</i> and <i>&lt;scalar-name&gt;</i>
may contain wildcards (see <a href="#sec339">[9.3.1]</a>).
<i>&lt;scalar-name&gt;</i> is the signal name, or the string passed to the
<tt>recordScalar()</tt> call. By default, the recording of all scalars is
enabled.

<p>The following example turns off recording all scalar results, except
end-to-end delays and those produced by TCP modules:

<pre class="inifile">
**.tcp.**.scalar-recording = true
**.endToEndDelay.scalar-recording = true
**.scalar-recording = false
</pre>
<p>


<p><h3><a name="sec410"/>12.2.5 Configuring Output Vectors</h3>
<a name="sec:ana-sim:vector-config"></a>

<p>Recording output vector results can be turned off globally by adding
the following line to the ini file. Any existing file with the same name
will still be removed before the simulation starts.

<pre class="inifile">
**.vector-recording = false
</pre>
<p>
The size of output vector files can easily reach the magnitude of several
hundred megabytes, but very often, only some of the recorded statistics are
interesting to the analyst. OMNeT++ allows you to control which vectors you
want to record, and to specify one or more collection intervals.

<p>Output vectors can be configured with the <b><tt>vector-recording</tt></b> and
<b><tt>vector-recording-intervals</tt></b> per-object options. The syntax of the
configuration options are
<i>&lt;module-full-path&gt;.&lt;vector-name&gt;.</i><tt>vector-recording=</tt><i>true/false</i>,
and <i>&lt;module-full-path&gt;.&lt;vector-name&gt;.</i><tt>vector-recording-intervals=</tt><i>&lt;intervals&gt;</i>,
where both <i>&lt;module-full-path&gt;</i> and <i>&lt;vector-name&gt;</i> may
contain wildcards (see <a href="#sec339">[9.3.1]</a>).
<i>&lt;vector-name&gt;</i> is the signal name, or the name string of the
<tt><a href="../api/classcOutVector.html">cOutVector</a></tt> object. By default, all output vectors are turned
on for the whole duration the simulation.

<p>The following example only records the <tt>queueLength</tt> vectors and
<tt>endToEndDelay</tt> in <tt>voiceApp</tt> modules, and turns off the rest:

<pre class="inifile">
**.queueLength.vector-recording = true
**.voiceApp.endToEndDelay.vector-recording = true
**.vector-recording = false
</pre>
<p>
For the <b><tt>vector-recording-intervals</tt></b> option, one can specify
one or more intervals in the <i>&lt;startTime&gt;..&lt;stopTime&gt;</i> syntax,
separated by comma. <i>&lt;startTime&gt;</i> or <i>&lt;stopTime&gt;</i> need
to be given with measurement units, and both can be omitted to denote
the beginning and the end of the simulation, respectively.

<p>The following example limits all vectors to three intervals, except
<tt>dropCount</tt> vectors which will be recorded during the whole
simulation run:

<pre class="inifile">
**.dropCount.vector-recording-intervals = 0..
**.vector-recording-intervals = 0..1000s, 5000s..6000s, 9000s..
</pre>
<p>
A third per-vector configuration option is <b><tt>vector-record-eventnumbers</tt></b>,
which specifies whether to record event numbers for an output vector.
(Simulation time and value are always recorded. Event numbers are needed
by the Sequence Chart Tool, for example.) Event number recording is enabled
by default; it may be turned off to save disk space.

<pre class="inifile">
**.vector-record-eventnumbers = false
</pre>
<p>
If the (default) <tt>cIndexedFileOutputVectorManager</tt> class is used to
record output vectors, there are two more options to fine-tune its resource
usage. <tt>output-vectors-memory-limit</tt> specifies the total memory that
can be used for buffering output vectors. Larger values produce less
fragmented vector files (i.e. cause vector data to be grouped into larger
chunks), and therefore allow more efficient processing later.
<tt>vector-max-buffered-values</tt> specifies the maximum number of values to
buffer per vector, before writing out a block into the output vector file.
The default is no per-vector limit (i.e. only the total memory limit is in
effect.)

<p>
<h3><a name="sec411"/>12.2.6 Saving Parameters as Scalars</h3>

<p>When you are running several simulations with different parameter
settings, you'll usually want to refer to selected
input parameters in the result analysis as well -- for example when
drawing a throughput (or response time) versus load (or network
background traffic) plot. Average throughput or response time numbers
are saved into the output scalar files, and it is useful for the input
parameters to get saved into the same file as well.

<p>For convenience, OMNeT++ automatically saves the iteration variables
into the output scalar file if they have numeric value, so they can
be referred to during result analysis.

<p><ul class="warning"><b>WARNING</b><br>
    If an iteration variable has non-numeric value, it will not be recorded
    automatically and cannot be used during analysis. This can happen
    unintentionally if you specify units inside an iteration variable list:
<pre class="inifile">
**.param = exponential( ${mean=0.2s, 0.4s, 0.6s} )  #WRONG!
**.param = exponential( ${mean=0.2, 0.4, 0.6}s )    #OK
</pre>
</ul>

<p>Module parameters can also be saved, but this has to be
requested by the user, by configuring <tt>param-record-as-scalar=true</tt> for the
parameters in question. The configuration key is a pattern that
identifies the parameter, plus <tt>.param-record-as-scalar</tt>. An example:

<pre class="inifile">
**.host[*].networkLoad.param-record-as-scalar = true
</pre>
<p>
This looks simple enough, however there are three pitfalls:
non-numeric parameters, too many matching parameters, and
random-valued volatile parameters.

<p>First, the scalar file only holds numeric results, so non-numeric
parameters cannot be recorded -- that will result in a runtime
error.

<p>Second, if wildcards in the pattern match too many parameters, that
might unnecessarily increase the size of the scalar file. For example,
if the <tt>host[]</tt> module vector size is 1000 in the example below, then the
same value (3) will be saved 1000 times into the scalar file, once for
each host.

<pre class="inifile">
**.host[*].startTime = 3
**.host[*].startTime.param-record-as-scalar = true  # saves "3" once for each host
</pre>
<p>
Third, recording a random-valued volatile parameter will just save a
random number from that distribution. This is rarely what you need, and
the simulation kernel will also issue a warning if this happens.

<pre class="inifile">
**.interarrivalTime = exponential(1s)
**.interarrivalTime.param-record-as-scalar = true  # wrong: saves random values!
</pre>
<p>
These pitfalls are quite common in practice, so it is usually better
to rely on the iteration variables in the result analysis.
That is, one can rewrite the above example as

<pre class="inifile">
**.interarrivalTime = exponential( ${mean=1}s )
</pre>
<p>
and refer to the <tt>$mean</tt> iteration variable instead of the
interarrivalTime module parameter(s) during result analysis.
<tt>param-record-as-scalar=true</tt> is not needed, because iteration variables are
automatically saved into the result files.

<p>
<h3><a name="sec412"/>12.2.7 Recording Precision</h3>
<a name="sec:outputfile-precision"></a>

<p>Output scalar and output vector files are text files, and floating point
values (<tt>double</tt>s) are recorded into it using <tt>fprintf()</tt>'s
<tt>"%g"</tt> format. The number of significant digits can be configured
using the <b><tt>output-scalar-precision</tt></b> and <b><tt>output-vector-precision</tt></b>
configuration options.

<p>The default precision is 12 digits. The following has to be considered when
setting a different value:

<p>IEEE-754 doubles are 64-bit numbers. The mantissa is 52 bits, which is
roughly equivalent to 16 decimal places (52*log(2)/log(10)). However, due
to rounding errors, usually only 12..14 digits are correct, and the rest is
pretty much random garbage which should be ignored. However, when you
convert the decimal representation back into a <tt>double</tt> for result
processing, an additional small error will occur, because 0.1, 0.01, etc.
cannot be accurately represented in binary. This conversion error is
usually smaller than what that the <tt>double</tt> variable already had
before recording into the file. However, if it is important, you can
eliminate this error by setting the recording precision to 16 digits or
more (but again, be aware that the last digits are garbage). The practical
upper limit is 17 digits, setting it higher doesn't make any difference in
<tt>fprintf()</tt>'s output.


Errors resulting from converting to/from decimal representation can be
eliminated by choosing an output vector/output scalar manager class
which stores <tt>double</tt>s in their native binary form.
The appropriate configuration options are <b><tt>outputvectormanager-class</tt></b>
and <b><tt>outputvectormanager-class</tt></b>. For example,
<tt>cMySQLOutputScalarManager</tt> and <tt>cMySQLOutputScalarManager</tt>
provided in <tt>samples/database</tt> fulfill this requirement.

<p>However, before worrying too much about rounding and conversion errors,
consider the <i>real</i> accuracy of your results:

<p><ul>
  <li>in real life, it is very difficult to measure quantities (weight, distance,
     even time) with more than a few digits of precision. What precision
     are your input data? For example, if you approximate inter-arrival
     time as <i>exponential(0.153)</i> when the mean is really
     <i>0.152601...</i> and the distribution is not even exactly exponential,
     you are already starting out with a bigger error than rounding can cause.

<p>  <li>the simulation model is itself an approximation of real life. How much
     error do the (known and unknown) simplifications cause in the results?
</ul>

<p>

<p><h2><a name="sec413"/>12.3 Overview of the Result File Formats</h2>

<p>Both output vector and scalar files are textual, line-oriented files.
The advantage of a text-based format is that it is very accessible
with a wide range of tools and languages. The format of result files is
documented in detail in Appendix <a href="#sec569">[26]</a>.


By default, each file contains data from one run only.

<p>Result files start with a header that contains several attributes of the
simulation run: a reasonably globally unique run ID, the network NED type
name, the experiment-measurement-replication labels, the values of
iteration variables and the repetition counter, the date and time, the host
name, the process id of the simulation, random number seeds, configuration
options, and so on. These data can be useful during result processing, and
increase the reproducibility of the results.

<p>
Vectors are recorded into a separate file for practical reasons: vector
data usually consume several magnitudes more disk space than scalars.

<p><h3><a name="sec414"/>12.3.1 Output Vector Files</h3>

<p>All output vectors from a simulation run are recorded into the same file.
The following sections describe the format of the file, and
how to process it.

<p>An example file fragment (without header):

<pre class="filelisting">
...
vector 1   net.host[12]  responseTime  TV
1  12.895  2355.66
1  14.126  4577.66664666
vector 2   net.router[9].ppp[0] queueLength  TV
2  16.960  2
1  23.086  2355.66666666
2  24.026  8
...
</pre>
<p>
There two types of lines: vector declaration lines (beginning with the word
<tt>vector</tt>), and data lines. A <i>vector declaration line</i>
introduces a new output vector, and its columns are: vector Id, module of
creation, name of <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> object, and multiplicity (usually 1).
Actual data recorded in this vector are on <i>data lines</i> which begin
with the vector Id. Further columns on data lines are the simulation time
and the recorded value.

<p>
Since OMNeT++ 4.0, vector data are recorded into the file clustered by
output vectors, which, combined with index files, allows much more
efficient processing. Using the index file, tools can extract particular
vectors by reading only those parts of the file where the desired data are
located, and do not need to scan through the whole file linearly.

<p>
<h3><a name="sec415"/>12.3.2 Scalar Result Files</h3>

<p>Fragment of an output scalar file (without header):

<pre class="filelisting">
...
scalar "lan.hostA.mac" "frames sent"  99
scalar "lan.hostA.mac" "frames rcvd"  3088
scalar "lan.hostA.mac" "bytes sent"   64869
scalar "lan.hostA.mac" "bytes rcvd"   3529448
...
</pre>
<p>
Every scalar generates one <tt>scalar</tt> line in the file.

<p>Statistics objects (<tt>cStatictic</tt> subclasses such as <tt><a href="../api/classcStdDev.html">cStdDev</a></tt>)
generate several lines: mean, standard deviation, etc.

<p>
<h2><a name="sec416"/>12.4 The Analysis Tool in the Simulation IDE</h2>

<p>The Simulation IDE provides an Analysis Tool for analysis and visualization
of simulation results. The Analysis Tool lets you load several result files
at once, and presents their contents somewhat like a database. You can
browse the results, select the particular data you are interested in
(scalars, vectors, histograms), apply processing steps, and create various
charts or plots from them. Data selection, processing and charting steps
can be freely combined, resulting in a high degree of freedom.
These steps are grouped into and stored as "recipes", which get automatically
re-applied when new result files are added or existing files are
replaced. This automation spares the user lots of repetitive manual work,
without resorting to scripting.

<p>The Analysis Tool is covered in detail in the User Guide.

<p>
<h2><a name="sec417"/>12.5 Scave Tool</h2>
<!--scavetool--><a name="sec:ana-sim:scavetool"></a>

<p>Much of the IDE Analysis Tool's functionality is available on the command
line as well, via the <tt>scavetool</tt> program. <tt>scavetool</tt> is
suitable for filtering and basic processing of result files, and
exporting the result in various formats digestible for other tools.
<tt>scavetool</tt> has no graphics capabilities, but it can be used
to produce files that can be directly plotted with other tools like
gnuplot (see <a href="#sec425">[12.6.4]</a>).

<p>When <tt>scavetool</tt> is invoked without arguments, it prints usage information:

<pre class="commandline">
scavetool &lt;command&gt; [options] &lt;file&gt;...
</pre>
<p>
<h3><a name="sec418"/>12.5.1 The <i>filter</i> Command</h3>

<p>The <i>filter</i> command allows you to filter and/or convert result files.

<p>A filter can be specified with the <i>-p &lt;filter&gt;</i> option.
The filter is one or more <i>&lt;pattern&gt;</i> or <i>&lt;fieldname&gt;(&lt;pattern&gt;)</i>
expressions connected with <tt>AND</tt>, <tt>OR</tt> and <tt>NOT</tt> operators;
a naked <i>&lt;pattern&gt;</i> is understood as <tt>name(</tt><i>&lt;pattern&gt;</i><tt>)</tt>.
For example, the filter <tt>"module(**.sink) AND name(delay)"</tt> (or just
<tt>"module(**.sink) AND delay"</tt>) selects the <tt>delay</tt> vectors from all
<tt>sink</tt> modules.

<p>The possible field names are:

<p><ul>
    <li><b>file</b>: full path of the result file
    <li><b>run</b>: run identifier
    <li><b>module</b>: module name
    <li><b>name</b>: vector name
    <li><b>attr:&lt;runAttribute&gt;</b>: value of an attribute of the run,
        e.g. <tt>experiment</tt>, <tt>datetime</tt> or <tt>network</tt>
    <li><b>param:&lt;moduleParameter&gt;</b>: value of the parameter in the run
</ul>

<p>Processing operations can be applied to vectors by the
<i>-a &lt;function&gt;(&lt;parameterlist&gt;)</i> option. You can list
the available functions and their parameters with the <i>info</i> command.

<p>The name and format of the output file can be specified with the
<i>-O &lt;file&gt;</i> and <i>-F &lt;formatname&gt;</i> options, where
the format name is one of the following:

<p><ul>
    <li><b>vec</b>: vector file (default)
    <li><b>csv</b>: CSV file
    <li><b>octave</b>: Octave text file
    <li><b>matlab</b>: Matlab script file
</ul>

<p>The following example writes the window-averaged queuing times stored
in <tt>in.vec</tt> into <tt>out.vec</tt>:

<pre class="commandline">
scavetool filter -p "queuing time" -a winavg(10) -O out.vec in.vec
</pre>
<p>
The next example writes the queueing and transmission times of <tt>sink</tt>
modules into CSV files. It generates a separate file for each vector,
named <tt>out-1.csv</tt>, <tt>out-2.csv</tt>, etc.

<pre class="commandline">
scavetool filter -p "module(**.sink) AND
                    (\"queueing time\" OR \"transmission time\")"
                 -O out.csv -F csv in.vec
</pre>
<p>
The generated CSV files contain a header and two columns:

<pre class="filelisting">
time,"Queue.sink.queueing time"
2.231807576851,0
7.843802235089,0
15.797137536721,3.59449
21.730758362277,6.30398
[...]
</pre>
<p>

<p><h3><a name="sec419"/>12.5.2 The <i>index</i> Command</h3>

<p>If the index file was deleted or the vector file was modified, you need to
rebuild the index file before running the filter command:

<pre class="commandline">
scavetool index Aloha-1.vec
</pre>
<p>
Normally the vector data is written in blocks into the vector file.
However, if the vector file was generated by an older version of the
<tt><a href="../api/classcOutputVectorManager.html">cOutputVectorManager</a></tt>, it might not be so. In this case you have
to specify the -r option to rearrange the records of the vector file,
otherwise the index file would be too big and the indexing inefficient.

<p><h3><a name="sec420"/>12.5.3 The <i>summary</i> Command</h3>

<p>The <i>summary</i> command reports the list of statistics names, module names,
run ids, configuration names in the given files to the standard output.

<pre class="commandline">
scavetool summary Aloha-1.vec
</pre>
<p>

<p><h2><a name="sec421"/>12.6 Alternative Statistical Analysis and Plotting Tools</h2>
<a name="sec:ana-sim:alt-tools"></a>

<p>There are several programs and packages in addition to the OMNeT++ IDE
and <tt>scavetool</tt> that can also be used to analyze
simulation results, and create various plots and charts from them.

<p><ul class="hint"><b>HINT</b><br>
Our recommendation is GNU R because of its features, its popularity, and
the existence of an extension package written specifically for OMNeT++
result processing.
</ul>

<p>
<h3><a name="sec422"/>12.6.1 GNU R</h3>
<a name="sec:ana-sim:gnu-r"></a><!--GNU R-->

<p>R is a free software environment for statistical computing and graphics.
R has an excellent programming language and powerful plotting capabilities,
and it is supported on all major operating systems and platforms.

<p>R is widely used for statistical software development and data analysis.
The program uses a command line interface, though several graphical user
interfaces are available.

<p><ul class="hint"><b>HINT</b><br>
An R package for OMNeT++ result processing is available from
<a href="https://github.com/omnetpp/omnetpp-resultfiles/wiki">https://github.com/omnetpp/omnetpp-resultfiles/wiki</a>.
The package supports loading the contents of OMNeT++ result files into R,
organizing the data and creating various plots and charts.
The package is well documented, and the web site offers a Tutorial, a Tips
page, a tutorial for the Scalar Lattice GUI package, and other information.
</ul>

<p>Several other OMNeT++-related packages such as SimProcTC and Syntony already
use R for data analysis and plotting.

<p>
<h3><a name="sec423"/>12.6.2 NumPy, SciPy and MatPlotLib</h3>
<!--NumPy--><!--SciPy--><!--MatPlotLib-->

<p>NumPy and SciPy are numerical and scientific computing packages for the
Python programming language, and MatPlotlib is a plotting library (also for
Python).

<p>MatPlotlib provides a &#8220;pylab&#8221; API designed to closely resemble that of
MATLAB, thereby making it easy to learn for experienced MATLAB users.
Matplotlib is distributed under a BSD-style license.

<p>
<h3><a name="sec424"/>12.6.3 MATLAB or Octave</h3>
<!--Matlab--><!--Octave-->

<p>MATLAB is a commercial numerical computing environment and programming language.
MATLAB allows easy matrix manipulation, plotting of functions and data,
implementation of algorithms, creation of user interfaces, and interfacing
with programs in other languages.

<p>Octave is an open-source Matlab-like package, available on nearly all platforms.
Currently Octave relies on Gnuplot for plotting, and has more limited
graphics capabilities than GNU R or MATLAB.

<p>
<h3><a name="sec425"/>12.6.4 Gnuplot</h3>
<a name="sec:ana-sim:gnuplot"></a><!--Gnuplot-->

<p>Gnuplot is a very popular command-line program that can generate two-
and three-dimensional plots of functions and data. The program runs
on all major platforms, and it is well supported.

<p>Gnuplot has an interactive command interface. For example, if you have
the data files <tt>foo.csv</tt> and <tt>bar.csv</tt> that contain
two values per line (<i>x</i> <i>y</i>; such files can be exported with
<tt>scavetool</tt> from vector files), you can plot them in the same
graph by typing:

<pre class="commandline">
plot "foo.csv" with lines, "bar.csv" with lines
</pre>
<p>
To adjust the <i>y</i> range, you would type:

<pre class="commandline">
set yrange [0:1.2]
replot
</pre>
<p>
Several commands are available to adjust ranges, plotting style, labels,
scaling etc. On Windows, you can copy the resulting graph to the clipboard from
the Gnuplot window's system menu, then insert it into the application you
are working with.

<p>
<h3><a name="sec426"/>12.6.5 ROOT</h3>
<!--ROOT-->

<p><i>ROOT</i> is an object-oriented data analysis framework,
with strong support for plotting and graphics in general.
ROOT was developed at CERN, and is distributed under a BSD-like license.

<p>ROOT is based on <i>CINT</i>, a &#8220;C/C++ interpreter&#8221;
aimed at processing C/C++ scripts. It is probably harder to get started
using ROOT than with either Gnuplot or Grace, but you will find that ROOT provides
power and flexibility that would be unattainable with the other two programs.

<p>Curt Brune's page at Stanford (http://www.slac.stanford.edu/\~curt/omnet++/)
shows examples of what you can achieve using ROOT with OMNeT++.

<p>
<h3><a name="sec427"/>12.6.6 Grace</h3>
<!--Grace-->

<p>An &#8220;honorable mention,&#8221; <i>Grace</i> is a powerful GPL data visualization
program with a menu-and-dialog graphical user interface for X and Motif. It
has also been ported to Windows. Grace is also known as <i>xmgrace</i>,
and it is a successor of <i>ACE/gr</i> or <i>Xmgr</i>.

<p>Grace can export graphics in various raster and vector formats, and has
many useful features like built-in statistics and analysis functions (e.g.
correlation, histogram), fitting, splines, etc., and it also has a built-in
programming language.

<p>
<h3><a name="sec428"/>12.6.7 Spreadsheet Programs</h3>
<!--Spreadsheets-->

<p>One straightforward solution is to use spreadsheets such as OpenOffice
Calc, Microsoft Excel, Gnumeric or Calligra Tables (formerly KSpread).
Data can be imported from CSV or other formats, exported with <tt>scavetool</tt>
(see <a href="#sec417">[12.5]</a>).

<p>Spreadsheets have good charting and statistical features. A useful
functionality spreadsheets offer for analyzing scalar files is
<i>PivotTable</i> (Excel) or <i>DataPilot</i> (OpenOffice). The
drawback of using spreadsheets is limited automation, leading to tedious
and repetitive tasks; also, the number of rows is usually limited to about
32,000..64,000, which can be limiting when working with large vector files.

<p>


<hr class='pgbr'><h1><a name="sec429"/>13 Eventlog</h1>
<a name="cha:eventlog"></a>

<p><h2><a name="sec430"/>13.1 Introduction</h2>
The eventlog feature and the related tools are completely new in OMNeT++ 4.0. They aim to
help in understanding complex simulation models and to help correctly implement the
desired component behaviors. Using these tools you will be able to easily examine every
minute detail of the simulation back and forth in terms of simulation time, or step-by-step,
focusing on the behavior instead of the statistical results of your model.

<p>The eventlog file is created automatically during a simulation run upon explicit request
configurable in the ini file. The resulting file can be viewed in the OMNeT++ IDE using
the Sequence Chart and the Eventlog Table or can be processed by the command line Eventlog
Tool. These tools support filtering the collected data to allow you to focus on events
relevant to what you are looking for. They allow examining causality relationships and
provide filtering based on simulation times, event numbers, modules and messages.

<p>The simulation kernel records into the eventlog among others: user level messages,
creation and deletion of modules, gates and connections, scheduling of self messages,
sending of messages to other modules either through gates or directly, and processing of
messages (that is events). Optionally, detailed message data can also be automatically
recorded based on a message filter. The result is an eventlog file which contains detailed
information of the simulation run and later can be used for various purposes.

<p><ul class="note"><b>NOTE</b><br>
    The eventlog file may become quite large for long running simulations
    (often hundreds of megabytes, but occasionally several gigabytes), because it
    contains a lot of information about the run, especially when message detail
    recording is turned on.
</ul>

<p><h2><a name="sec431"/>13.2 Configuration</h2>

<p>To record an eventlog file during the simulation, insert the following line into
the ini file:

<pre class="inifile">
record-eventlog = true
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
    Eventlog recording is turned off by default, because creating the eventlog file
    might significantly decrease the overall simulation performance.
</ul>

<p><h3><a name="sec432"/>13.2.1 File Name</h3>

<p>The simulation kernel will write the eventlog file during the simulation into the file
specified by the following ini file configuration entry (showing the default file name
pattern here):

<pre class="inifile">
eventlog-file = ${resultdir}/${configname}-${runnumber}.elog
</pre>
<p>
<h3><a name="sec433"/>13.2.2 Recording Intervals</h3>

<p>The size of an eventlog file is approximately proportional to the number of
events it contains. To reduce the file size and speed up the simulation, it
might be useful to record only certain events. The
<tt>eventlog-recording-intervals</tt> configuration option instructs the
kernel to record events only in the specified intervals. The syntax is
similar to that of <tt>vector-recording-intervals</tt>.

<p>An example:

<pre class="inifile">
eventlog-recording-intervals = ..10.2, 22.2..100, 233.3..
</pre>
<p>
<h3><a name="sec434"/>13.2.3 Recording Modules</h3>

<p>Another factor that affects the size of an eventlog file is the number of
modules for which the simulation kernel records events during the
simulation. The <tt>module-eventlog-recording</tt> per-module configuration
option instructs the kernel to record only the events that occurred in the
matching modules. The default is to record events from all modules. This
configuration option only applies to simple modules.

<p>The following example records events from any of the routers whose index is
between 10 and 20, and turns off recording for all other modules.

<pre class="inifile">
**.router[10..20].**.module-eventlog-recording = true
**.module-eventlog-recording = false
</pre>
<p>
<h3><a name="sec435"/>13.2.4 Recording Message Data</h3>

<p>Since recording message data dramatically increases the size of the
eventlog file and also slows down the simulation, it is turned off by
default, even if writing the eventlog is enabled. To turn on message data
recording, supply a value for the <tt>eventlog-message-detail-pattern</tt>
option in the ini file.

<p>

An example configuration for an IEEE 80211 model that records the <tt>encapsulationMsg</tt> field
and all other fields whose name ends in <tt>Address</tt>, from messages whose class name ends in
<tt>Frame</tt> looks like this:

<pre class="inifile">
eventlog-message-detail-pattern = *Frame:encapsulatedMsg,*Address
</pre>
<p>
An example configuration for a TCP/IP model that records the port and address
fields in all network packets looks like the following:

<pre class="inifile">
eventlog-message-detail-pattern =
 PPPFrame:encapsulatedPacket|IPDatagram:encapsulatedPacket,*Address|TCPSegment:*Port
</pre>
<p>
% <pre class="inifile">
% eventlog-message-detail-pattern = WirelessFrame:declaredOn(WirelessFrame) or bitLength
%</pre>

<p>
<h2><a name="sec436"/>13.3 Eventlog Tool</h2>

<p>The Eventlog Tool is a command line tool to process eventlog files. Invoking it without
parameters will display usage information. The following are the most useful commands for users.

<p><h3><a name="sec437"/>13.3.1 Filter</h3>

<p>The eventlog tool provides off line filtering that is usually applied to the eventlog file
after the simulation has been finished and before actually opening it in the OMNeT++ IDE
or processing it by any other means. Use the filter command and its various options to
specify what should be present in the result file.

<p><h3><a name="sec438"/>13.3.2 Echo</h3>

<p>Since the eventlog file format is text based and users are encouraged to implement their
own filters, a way is needed to check whether an eventlog file is
correct. The echo command provides a way to check this and help users creating custom
filters. Anything not echoed back by the eventlog tool will not be taken into
consideration by the other tools found in the OMNeT++ IDE.

<p><ul class="note"><b>NOTE</b><br>
    Custom filter tools should filter out whole events only, otherwise the
    consequences are undefined.
</ul>

<hr class='pgbr'><h1><a name="sec439"/>14 Documenting NED and Messages</h1>
<a name="cha:neddoc"></a>

<p><h2><a name="sec440"/>14.1 Overview</h2>

<p>OMNeT++ provides a tool which can generate HTML documentation from NED files
and message definitions. Like Javadoc and Doxygen, the NED documentation tool
makes use of source code comments. The generated HTML documentation
lists all modules, channels, messages, etc., and presents their details including
description, gates, parameters, assignable submodule parameters, and
syntax-highlighted source code. The documentation also includes clickable
network diagrams (exported from the graphical editor) and usage diagrams as
well as inheritance diagrams.

<p>The documentation tool integrates with Doxygen, meaning that it can
hyperlink simple modules and message classes to their C++ implementation
classes in the Doxygen documentation. If you also generate the C++
documentation with some Doxygen features turned on (such as
<i>inline-sources</i> and <i>referenced-by-relation</i>, combined with
<i>extract-all</i>, <i>extract-private</i> and
<i>extract-static</i>), the result is an easily browsable and very
informative presentation of the source code. Of course, one still has to
write documentation comments in the code.

<p>In the 4.0 version, the documentation tool is part of the Eclipse-based
simulation IDE.

<p>
<h2><a name="sec441"/>14.2 Documentation Comments</h2>

<p>Documentation is embedded in normal comments. All <tt>//</tt> comments
that are in the &#8220;right place&#8221; (from the documentation tool's
point of view) will be included in the generated documentation.
  <br><ul><font size=-1>[In contrast, Javadoc and Doxygen use special comments (those
     beginning with <tt>/**</tt>, <tt>///</tt>, <tt>//&lt;</tt> or a similar
     marker) to distinguish documentation from &#8220;normal&#8221; comments in the
     source code. In OMNeT++ there is no need for that: NED and the message
     syntax is so compact that practically all comments one would want to write
     in them can serve documentation purposes.]</font></ul>

<p>Example:

<pre class="ned">
//
// An ad-hoc traffic generator to test the Ethernet models.
//
simple Gen
{
    parameters:
        string destAddress;  // destination MAC address
        int protocolId;      // value for SSAP/DSAP in Ethernet frame
        double waitMean @unit(s); // mean for exponential interarrival times
    gates:
        output out;  // to Ethernet LLC
}
</pre>
<p>
You can also place comments above parameters and gates. This is useful
if they need long explanations. Example:

<pre class="ned">
//
// Deletes packets and optionally keeps statistics.
//
simple Sink
{
    parameters:
        // You can turn statistics generation on and off. This is
        // a very long comment because it has to be described what
        // statistics are collected (or not).
        bool collectStatistics = default(true);
    gates:
        input in;
}
</pre>
<p>
<h3><a name="sec442"/>14.2.1 Private Comments</h3>

<p>If you want a comment line <i>not</i> to appear in the documentation,
begin it with <tt>//#</tt>. Those lines will be ignored by the
documentation tool, and can be used to make &#8220;private&#8221; comments
like <tt>FIXME</tt> or <tt>TODO</tt>, or to comment out unused code.

<pre class="ned">
//
// An ad-hoc traffic generator to test the Ethernet models.
//# TODO above description needs to be refined
//
simple Gen
{
    parameters:
        string destAddress;  // destination MAC address
        int protocolId;      // value for SSAP/DSAP in Ethernet frame
        //# double burstiness;  -- not yet supported
        double waitMean @unit(s); // mean for exponential interarrival times
    gates:
        output out;  // to Ethernet LLC
}
</pre>
<p>

<p><h3><a name="sec443"/>14.2.2 More on Comment Placement</h3>

<p>Comments should be written where the tool will find them.
This is a) immediately above the documented item, or b) after the
documented item, on the same line.

<p>In the former case, make sure there is no blank line left
between the comment and the documented item. Blank lines
detach the comment from the documented item.

<p>Example:
<pre class="ned">
// This is wrong! Because of the blank line, this comment is not
// associated with the following simple module!

simple Gen
{
    ...
}
</pre>

<p>Do not try to comment groups of parameters together. The result
will be awkward.

<p><h2><a name="sec444"/>14.3 Referring to Other NED and Message Types</h2>

<p>You can reference other NED and message types by name in comments. There
are two styles in which references can be written: automatic linking and
tilde linking. The same style must be following throughout the whole
project, and the correct one must be selected in the documentation
generator tool when it is run.

<p><h3><a name="sec445"/>14.3.1 Automatic Linking</h3>

<p>In the automatic linking style, words that match existing NED of message
types are hyperlinked automatically. It is usually enough to write the
simple name of the type (e.g. <tt>TCP</tt>), you don't need to spell out the
fully qualified type (<tt>inet.transport.tcp.TCP</tt>), although you can.

<p>Automatic hyperlinking is sometimes overly agressive. For example, when you
write <tt>IP address</tt> in a comment and an <tt>IP</tt> module exists
in the project, it will create a hyperlink to the module, which is probably
not what you want. You can prevent hyperlinking of a word by inserting a
backslash in front it: <tt>\IP address</tt>. The backslash will
not appear in the HTML output. The <tt>&lt;nohtml&gt;</tt> tag will also prevent
hyperlinking words in the enclosed text: <tt>&lt;nohtml&gt;IP address&lt;/nohtml&gt;</tt>.
On the other hand, if you deliberately want to print a backslash immediately
in front of a word (e.g. output <i>&#8220;use \t to print a Tab&#8221;</i>),
use either two backslashes (<tt>use \\t...</tt>) or the
<tt>&lt;nohtml&gt;</tt> tag (<tt>&lt;nohtml&gt;use \t...&lt;/nohtml&gt;</tt>).
Backslashes in other contexts (i.e. when not in front of a word) do not have
a special meaning, and are preserved in the output.

<p>The detailed rules:

<p><ol>
  <li> Words matching a type name are automatically hyperlinked
  <li> A backslash immediately followed by an identifier (i.e. letter or underscore)
        prevents hyperlinking, and the backslash is removed from the output
  <li> A double backslash followed by an identifier produces a single backslash,
        plus the potentially hyperlinked identifier
  <li> Backslashes in any other contexts are not interpreted, and preserved in the output
  <li> Tildes are not interpreted, and are preserved in the output
  <li> Inside <tt>&lt;nohtml&gt;</tt>, no backslash processing or hyperlinking takes place
</ol>

<p><h3><a name="sec446"/>14.3.2 Tilde Linking</h3>

<p>In the tilde style, only words that are explicitly marked with a tilde are
subject to hyperlinking: <tt>~TCP</tt>,
<tt>~inet.transport.tcp.TCP</tt>.

<p>To produce a literal tilde followed by an identifier in the output (for example,
to output <i>&#8220;the ~TCP() destructor&#8221;</i>), you need to
double the tilde character: <tt>the ~~TCP() destructor</tt>.

<p>The detailed rules:

<p><ol>
  <li> Words matching a type name are <i>not</i> hyperlinked automatically
  <li> A tilde immediately followed by an identifier (i.e. letter or underscore)
        will be hyperlinked, and the tilde is removed from the output. It is
        considered an error if there is no type with that name.
  <li> A double tilde followed by an identifier produces a single tilde plus the identifier
  <li> Tildes in any other contexts are not interpreted, and preserved in the output
  <li> Backslashes are not interpreted, and are preserved in the output
  <li> Inside <tt>&lt;nohtml&gt;</tt>, no tilde processing or hyperlinking takes place
</ol>

<p><h2><a name="sec447"/>14.4 Text Layout and Formatting</h2>

<p><h3><a name="sec448"/>14.4.1 Paragraphs and Lists</h3>

<p>If you write longer descriptions, you will need text formatting capabilities.
Text formatting works like in Javadoc or Doxygen -- you can break up the
text into paragraphs and create bulleted/numbered lists without
special commands, and use HTML for more fancy formatting.

<p>Paragraphs are separated by empty lines, like in LaTeX or Doxygen.
Lines beginning with `<tt>-</tt>' will be turned into bulleted lists,
and lines beginning with `<tt>-#</tt>' into numbered lists.

<p>Example:

<pre class="ned">
//
// Ethernet MAC layer. MAC performs transmission and reception of frames.
//
// Processing of frames received from higher layers:
// - sends out frame to the network
// - no encapsulation of frames -- this is done by higher layers.
// - can send PAUSE message if requested by higher layers (PAUSE protocol,
//   used in switches). PAUSE is not implemented yet.
//
// Supported frame types:
// -# IEEE 802.3
// -# Ethernet-II
//
</pre>
<p>

<p><h3><a name="sec449"/>14.4.2 Special Tags</h3>

<p>The documentation tool understands the following tags and will render them accordingly:
<tt>@author</tt>, <tt>@date</tt>, <tt>@todo</tt>, <tt>@bug</tt>, <tt>@see</tt>, <tt>@since</tt>,
<tt>@warning</tt>, <tt>@version</tt>. Example usage:

<pre class="ned">
//
// @author Jack Foo
// @date 2005-02-11
//
</pre>
<p>

<p><h3><a name="sec450"/>14.4.3 Text Formatting Using HTML</h3>

<p>Common HTML tags are understood as formatting commands.
The most useful tags are: <tt>&lt;i&gt;..&lt;/i&gt;</tt> (italic),
<tt>&lt;b&gt;..&lt;/b&gt;</tt> (bold), <tt>&lt;tt&gt;..&lt;/tt&gt;</tt> (typewriter font),
<tt>&lt;sub&gt;..&lt;/sub&gt;</tt> (subscript), <tt>&lt;sup&gt;..&lt;/sup&gt;</tt> (superscript),
<tt>&lt;br&gt;</tt> (line break), <tt>&lt;h3&gt;</tt> (heading),
<tt>&lt;pre&gt;..&lt;/pre&gt;</tt> (preformatted text) and <tt>&lt;a href=..&gt;..&lt;/a&gt;</tt> (link),
as well as a few other tags used for table creation (see below).
For example, <tt>&lt;i&gt;Hello&lt;/i&gt;</tt> will be rendered as &#8220;<i>Hello</i>&#8221;
(using an italic font).

<p>The complete list of HTML tags interpreted by the documentation tool are:
<tt>&lt;a&gt;</tt>, <tt>&lt;b&gt;</tt>, <tt>&lt;body&gt;</tt>, <tt>&lt;br&gt;</tt>, <tt>&lt;center&gt;</tt>,
<tt>&lt;caption&gt;</tt>, <tt>&lt;code&gt;</tt>, <tt>&lt;dd&gt;</tt>, <tt>&lt;dfn&gt;</tt>, <tt>&lt;dl&gt;</tt>,
<tt>&lt;dt&gt;</tt>, <tt>&lt;em&gt;</tt>, <tt>&lt;form&gt;</tt>, <tt>&lt;font&gt;</tt>, <tt>&lt;hr&gt;</tt>,
<tt>&lt;h1&gt;</tt>, <tt>&lt;h2&gt;</tt>, <tt>&lt;h3&gt;</tt>, <tt>&lt;i&gt;</tt>, <tt>&lt;input&gt;</tt>, <tt>&lt;img&gt;</tt>,
<tt>&lt;li&gt;</tt>, <tt>&lt;meta&gt;</tt>, <tt>&lt;multicol&gt;</tt>, <tt>&lt;ol&gt;</tt>, <tt>&lt;p&gt;</tt>, <tt>&lt;small&gt;</tt>,
<tt>&lt;span&gt;</tt>, <tt>&lt;strong&gt;</tt>,
<tt>&lt;sub&gt;</tt>, <tt>&lt;sup&gt;</tt>, <tt>&lt;table&gt;</tt>, <tt>&lt;td&gt;</tt>, <tt>&lt;th&gt;</tt>, <tt>&lt;tr&gt;</tt>,
<tt>&lt;tt&gt;</tt>, <tt>&lt;kbd&gt;</tt>, <tt>&lt;ul&gt;</tt>, <tt>&lt;var&gt;</tt>.

<p>Any tags not in the above list will not be interpreted as formatting commands
but will be printed verbatim -- for example, <tt>&lt;what&gt;bar&lt;/what&gt;</tt>
will be rendered literally as &#8220;&lt;what&gt;bar&lt;/what&gt;&#8221; (unlike HTML where
unknown tags are simply ignored, i.e. HTML would display &#8220;bar&#8221;).

<p>If you insert links to external pages (web sites), its useful to add
the <tt>target="_blank"</tt> attribute to ensure pages come up in a new
browser window and not just in the current frame which looks awkward.
(Alternatively, you can use the <tt>target="_top"</tt> attribute
which replaces all frames in the current browser).

<p>Examples:

<pre class="ned">
//
// For more info on Ethernet and other LAN standards, see the
// &lt;a href="http://www.ieee802.org/" target="_blank"&gt;IEEE 802
// Committee's site&lt;/a&gt;.
//
</pre>
<p>
You can also use the <tt>&lt;a href=..&gt;</tt> tag to create links within the page:

<pre class="ned">
//
// See the &lt;a href="#resources"&gt;resources&lt;/a&gt; in this page.
// ...
// &lt;a name="resources"&gt;&lt;b&gt;Resources&lt;/b&gt;&lt;/a&gt;
// ...
//
</pre>
<p>
You can use the <tt>&lt;pre&gt;..&lt;/pre&gt;</tt> HTML tag to insert source code examples
into the documentation. Line breaks and indentation will be preserved,
but HTML tags continue to be interpreted (or you can turn them off
with <tt>&lt;nohtml&gt;</tt>, see later).

<p>Example:

<pre class="ned">
// &lt;pre&gt;
// // my preferred way of indentation in C/C++ is this:
// &lt;b&gt;for&lt;/b&gt; (&lt;b&gt;int&lt;/b&gt; i=0; i&lt;10; i++)
// {
//     printf(&lt;i&gt;"%d\n"&lt;/i&gt;, i);
// }
// &lt;/pre&gt;
</pre>
<p>
will be rendered as

<p><pre class="verbatim">
// my preferred way of indentation in C/C++ is this:
<b>for</b> (<b>int</b> i=0; i&lt;10; i++)
{
    printf(<i>"%d\n"</i>, i);
}
</pre>

<p>HTML is also the way to create tables. The example below

<pre class="ned">
//
// &lt;table border="1"&gt;
//   &lt;tr&gt;  &lt;th&gt;#&lt;/th&gt; &lt;th&gt;number&lt;/th&gt; &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;1&lt;/td&gt; &lt;td&gt;one&lt;/td&gt;    &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;2&lt;/td&gt; &lt;td&gt;two&lt;/td&gt;    &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;3&lt;/td&gt; &lt;td&gt;three&lt;/td&gt;  &lt;/tr&gt;
// &lt;/table&gt;
//
</pre>
<p>
will be rendered approximately as:

<p><table border>
<TR> <TD align=left>

<p><b>#</b> </TD> <TD align=left> <b>number</b> </TD></TR>
<TR> <TD align=left> 1 </TD> <TD align=left> one </TD></TR>
<TR> <TD align=left> 2 </TD> <TD align=left> two </TD></TR>
<TR> <TD align=left> 3 </TD> <TD align=left> three </TD></TR>
</table>

<p>
<h3><a name="sec451"/>14.4.4 Escaping HTML Tags</h3>

<p>Sometimes you may need to turn off interpreting HTML tags (<tt>&lt;i&gt;</tt>, <tt>&lt;b&gt;</tt>, etc.)
as formatting instructions, and rather you want them to appear as literal
<tt>&lt;i&gt;</tt>, <tt>&lt;b&gt;</tt> text in the documentation. You can achieve this via
surrounding the text with the <tt>&lt;nohtml&gt;</tt>...<tt>&lt;/nohtml&gt;</tt> tag.
For example,

<pre class="ned">
// Use the &lt;nohtml&gt;&lt;i&gt;&lt;/nohtml&gt; tag (like &lt;tt&gt;&lt;nohtml&gt;&lt;i&gt;this&lt;/i&gt;&lt;/nohtml&gt;&lt;tt&gt;)
// to write in &lt;i&gt;italic&lt;/i&gt;.
</pre>
<p>
will be rendered as &#8220;Use the &lt;i&gt; tag (like <tt>&lt;i&gt;this&lt;/i&gt;</tt>) to write
in <i>italic</i>.&#8221;

<p><tt>&lt;nohtml&gt;</tt>...<tt>&lt;/nohtml&gt;</tt> will also prevent <tt>opp_neddoc</tt>
from hyperlinking words that are accidentally the same as an existing
module or message name. Prefixing the word with a backslash will achieve
the same. That is, either of the following will do:

<pre class="ned">
// In &lt;nohtml&gt;IP&lt;/nohtml&gt; networks, routing is...
</pre>
<p>
<pre class="ned">
// In \IP networks, routing is...
</pre>

<p>Both will prevent hyperlinking the word <i>IP</i> if you happen to have
an <tt>IP</tt> module in the NED files.

<p>

<p><h2><a name="sec452"/>14.5 Customizing and Adding Pages</h2>

<p><h3><a name="sec453"/>14.5.1 Adding a Custom Title Page</h3>

<p>The title page is the one that appears in the main frame after
opening the documentation in the browser. By default it contains
a boilerplate text with the generic title <i>&#8220;OMNeT++ Model Documentation&#8221;</i>.
You probably want to customize that, and at least change the title
to the name of the documented simulation model.

<p>You can supply your own version of the title page adding a <tt>@titlepage</tt>
directive to a file-level comment (a comment that appears at the top of
a NED file, but is separated from the first <tt>import</tt>, <tt>channel</tt>,
<tt>module</tt>, etc. definition by at least one blank line).
In theory you can place your title page definition into
any NED or MSG file, but it is probably a good idea to create
a separate <tt>package.ned</tt> file for it.

<p>The lines you write after the <tt>@titlepage</tt> line up to the next
<tt>@page</tt> line (see later) or the end of the comment will be used
as the title page.
You probably want to begin with a title because the documentation
tool doesn't add one (it lets you have full control over the
page contents). You can use the <tt>&lt;h1&gt;..&lt;/h1&gt;</tt> HTML tag
to define a title.

<p>Example:

<pre class="ned">
//
// @titlepage
// &lt;h1&gt;Ethernet Model Documentation&lt;/h1&gt;
//
// This documents the Ethernet model created by David Wu and refined by Andras
// Varga at CTIE, Monash University, Melbourne, Australia.
//
</pre>
<p>

<p><h3><a name="sec454"/>14.5.2 Adding Extra Pages</h3>

<p>You can add new pages to the documentation in a similar way as customizing
the title page. The directive to be used is <tt>@page</tt>, and it can
appear in any file-level comment (see above).

<p>The syntax of the <tt>@page</tt> directive is the following:

<pre class="ned">
// @page filename.html, Title of the Page
</pre>
<p>
Choose a file name that doesn't collide with the files generated
by the documentation tool (such as <tt>index.html</tt>). If the file name
does not end in <tt>.html</tt> already, it will be appended.
The page title you supply will appear on the top of the page as well as
in the page index.

<p>The lines after the <tt>@page</tt> line up to the next <tt>@page</tt> line
or the end of the comment will be used as the page body.
You don't need to add a title because the documentation tool
automatically adds one.

<p>Example:
<pre class="ned">
//
// @page structure.html, Directory Structure
//
// The model core model files and the examples have been placed
// into different directories. The &lt;tt&gt;examples/&lt;/tt&gt; directory...
//
//
// @page examples.html, Examples
// ...
//
</pre>

<p>You can create links to the generated pages using standard HTML,
using the <tt>&lt;a href="..."&gt;...&lt;/a&gt;</tt> tag. All HTML files are
placed in a single directory, so you don't have to worry about
specifying directories.

<p>Example:
<pre class="ned">
//
// @titlepage
// ...
// The structure of the model is described &lt;a href="structure.html"&gt;here&lt;/a&gt;.
//
</pre>

<p>
<h3><a name="sec455"/>14.5.3 Incorporating Externally Created Pages</h3>

<p>You may want to create pages outside the documentation tool
(e.g. using a HTML editor) and include them in the documentation.
This is possible, all you have to do is declare such pages with
the <tt>@externalpage</tt> directive in any of the NED files, and
they will be added to the page index. The pages can then be linked to
from other pages using the HTML <tt>&lt;a href="..."&gt;...&lt;/a&gt;</tt> tag.

<p>The <tt>@externalpage</tt> directive is similar in syntax to <tt>@page</tt>:

<pre class="ned">
// @externalpage filename.html, Title of the Page
</pre>
<p>
The documentation tool does not check if the page exists
or not. It is your responsibility to copy it manually into
the directory of the generated documentation, and to make
sure the hyperlink works.

<p><h2><a name="sec456"/>14.6 File inclusion</h2>

<p>You can include content into the documentation comment with the
<tt>@include</tt> directive. It expects the path of the file to be incuded
relative to the file that includes it.

<p>The line of the <tt>@include</tt> directive will be replaced by the
content of the file. The lines of the included file do not need
to start with <tt>//</tt>, but otherwise they are processed in the same way
as the NED comments. They can include other files, but circular
includes are not allowed.

<pre class="ned">
// ...
// @include ../copyright.txt
// ...
</pre>
<p>
<hr class='pgbr'><h1><a name="sec457"/>15 Testing</h1>
<a name="cha:testing"></a>

<p><h2><a name="sec458"/>15.1 Overview</h2>

<p><h3><a name="sec459"/>15.1.1 Verification, validation</h3>

<p>Correctness of the simulation model is a primary concern of the developers
and users of the model, because they want to obtain credible simulation
results. Verification and validation are activities conducted during the
development of a simulation model with the ultimate goal of producing an
accurate and credible model.

<p><ul>
<li> <b>Verification</b> of a model is the process of confirming that it is
    correctly implemented with respect to the conceptual model, that is, it
    matches specifications and assumptions deemed acceptable for the given
    purpose of application. During verification, the model is tested to find
    and fix errors in the implementation of the model.
<li> <b>Validation</b> checks the accuracy of the model's representation of
    the real system. Model validation is defined to mean &#8220;substantiation that
    a computerized model within its domain of applicability possesses a
    satisfactory range of accuracy consistent with the intended application of
    the model&#8221;. A model should be built for a specific purpose or set of
    objectives and its validity determined for that purpose.
</ul>

<p>Of the two, verification is essentially a software engineering issue, so it
can be assisted with tools used for software quality assurance, for example
testing tools. Validation is not a software engineering issue.

<p><h3><a name="sec460"/>15.1.2 Unit testing, regression testing</h3>

<p>As mentioned above, software testing techniques can be of significant help
during model verification. Testing can also help to ensure that
a simulation model that once passed validation and verification will also
remain correct for an extended period.

<p>Software testing is an art on its own, with several techniques and
methodologies. Here we'll only mention two types that are important for us,
regression testing and unit testing.

<p><ul>
<li> <b>Regression testing</b> is a technique that seeks to uncover new
    software bugs, or regressions, in existing areas of a system after changes
    such as enhancements, patches or configuration changes, have been made to
    them.
<li> <b>Unit testing</b> is a method by which individual units of
    source code are tested to determine if they are fit for use. In an
    object-oriented environment, this is usually done at the class level.
</ul>

<p>The two may overlap; for example, unit tests are also useful for discovering
regressions.

<p>One way of performing regression testing on an OMNEST simulation model is
to record the log produced during simulation, and compare it to a
pre-recorded log. The drawback is that code refactoring may nontrivially
change the log as well, making it impossible to compare to the pre-recorded
one. Alternatively, one may just compare the result files or only certain
simulation results and be free of the refactoring effects, but then certain
regressions may escape the testing. This type of tradeoff seems to be
typical for regression testing.

<p>Unit testing of simulation models may be done on class level or module
level. There are many open-source unit testing frameworks for C++, for
example CppUnit, Boost Test, Google Test, UnitTest++, just to name a few.
They are well suited for class-level testing. However, they are usually
cumbersome to apply to testing modules due to the peculiarities of the
domain (network simulation) and OMNEST.

<p>A test in an <i>xUnit</i>-type testing framework (a collective name for
CppUnit-style frameworks) operates with various assertions to test
function return values and object states. This approach is difficult to
apply to the testing of OMNEST modules that often operate in a complex
environment (cannot be easily instantiated and operated in isolation),
react to various events (messages, packets, signals, etc.), and have
complex dynamic behavior and substantial internal state.

<p>Later sections will introduce <tt>opp_test</tt>, a tool OMNEST provides
for assisting various testing task; and summarize various testing methods
useful for testing simulation models.

<p>
<h2><a name="sec461"/>15.2 The opp_test Tool</h2>

<p><h3><a name="sec462"/>15.2.1 Introduction</h3>

<p>This section documents the <tt>opp_test</tt>, a versatile tool that is
helpful for various testing scenarios. <tt>opp_test</tt> can be used for
various types of tests, including unit tests and regression tests. It was
originally written for testing the OMNEST simulation kernel, but it is
equally suited for testing functions, classes, modules, or whole
simulations.

<p><tt>opp_test</tt> is built around a simple concept: it lets you define
simulations in a concise way, runs them, and checks that the output (result
files, log, etc.) matches a predefined pattern or patterns. In many cases,
this approach works better than inserting various assertions into the code
(which is still also an option).

<p>Each test is a single file, with the <tt>.test</tt> file extension. All NED
code, C++ code, ini files and other data necessary to run the test case as
well as the PASS criteria are packed together in the test file. Such
self-contained tests are easier to handle, and also encourage authors to
write tests that are compact and to the point.

<p>Let us see a small test file, <tt>cMessage_properties_1.test</tt>:

<pre class="filelisting">
%description:
Test the name and length properties of <a href="../api/classcPacket.html">cPacket</a>.

%activity:
<a href="../api/classcPacket.html">cPacket</a> *pk = new <a href="../api/classcPacket.html">cPacket</a>();
pk-&gt;setName("ACK");
pk-&gt;setByteLength(64);
EV &lt;&lt; "name: " &lt;&lt; pk-&gt;getName() &lt;&lt; endl;
EV &lt;&lt; "length: " &lt;&lt; pk-&gt;getByteLength() &lt;&lt; endl;
delete pk;

%contains: stdout
name: ACK
length: 64
</pre>
<p>
What this test says is this: create a simulation with a simple module
that has the above C++ code block as the body of the <tt>activity()</tt> method,
and when run, it should print the text after the <tt>%contains</tt> line.

<p>To run this test, we need a <i>control script</i>, for example
<tt>runtest</tt> from the <tt>omnetpp/test/core</tt> directory. <tt>runtest</tt>
itself relies on the <tt>opp_test</tt> tool.

<p><ul class="note"><b>NOTE</b><br>
The control script is not part of OMNEST because it is somewhat specific to
the simulation model or framework being tested, but it is usually trivial
to write. A later section will explain how write the control script.
</ul>

<p>The output will be similar to this one:

<pre class="filelisting">
$ ./runtest cMessage_properties_1.test
opp_test: extracting files from *.test files into work...
Creating Makefile in omnetpp/test/core/work...
cMessage_properties_1/test.cc
Creating executable: out/gcc-debug/work
opp_test: running tests using work.exe...
*** cMessage_properties_1.test: PASS
========================================
PASS: 1   FAIL: 0   UNRESOLVED: 0

Results can be found in work/
</pre>
<p>
This was a passing test. What would constitute a fail?

<p><ul>
<li> crash
<li> simulation runtime error
<li> nonzero exit code (a simulation runtime error is also detected by nonzero exit code)
<li> the output doesn't match the expectation (there are several possibilities
   for expressing what is expected: multiple match criteria, literal string vs regex,
   positive vs negative match, matching against the standard output, standard error
   or any file, etc.)
</ul>

<p>Normally, you run several tests together. The <tt>runtest</tt> script accepts
several <tt>.test</tt> files on the command line, and when started without
arguments, it defaults to <tt>*.test</tt>, all test files in the current
directory. At the end of the run, the tool prints summary statistics
(number of tests passed, failed, and being unresolved).

<p>An example run from <tt>omnetpp/test/core</tt> (some lines were removed from
the output, and one test was changed to show a failure):

<pre class="filelisting">
$ ./runtest <a href="../api/classcSimpleModule.html">cSimpleModule</a>-*.test
opp_test: extracting files from *.test files into work...
Creating Makefile.vc in omnetpp/test/core/work...
[...]
Creating executable: out/gcc-debug/work
opp_test: running tests using work...
*** cSimpleModule_activity_1.test: PASS
*** cSimpleModule_activity_2.test: PASS
[...]
*** cSimpleModule_handleMessage_2.test: PASS
*** cSimpleModule_initialize_1.test: PASS
*** cSimpleModule_multistageinit_1.test: PASS
*** cSimpleModule_ownershiptransfer_1.test: PASS
*** cSimpleModule_recordScalar_1.test: PASS
*** cSimpleModule_recordScalar_2.test: FAIL (test-1.sca fails %contains-regex(2) rule)
expected pattern:
&gt;&gt;&gt;&gt;run General-1-.*?
scalar Test 	one 	24.2
scalar Test 	two 	-1.5888&lt;&lt;&lt;&lt;
actual output:
&gt;&gt;&gt;&gt;version 2
run General-1-20141020-11:39:34-1200
attr configname General
attr datetime 20141020-11:39:34
attr experiment General
attr inifile _defaults.ini
[...]
scalar Test 	one 	24.2
scalar Test 	two 	-1.5
&lt;&lt;&lt;&lt;
*** cSimpleModule_recordScalar_3.test: PASS
*** cSimpleModule_scheduleAt_notowner_1.test: PASS
*** cSimpleModule_scheduleAt_notowner_2.test: PASS
[...]
========================================
PASS: 36   FAIL: 1   UNRESOLVED: 0
FAILED tests: cSimpleModule_recordScalar_2.test

Results can be found in work/
</pre>
<p>
Note that code from all tests were linked to form a single executable, which saves
time and disk space compared to per-test executables or libraries.

<p>A test file like the one above is useful for unit testing of classes or functions.
However, as we will see, the test framework provides further facilities that make
it convenient for testing modules and whole simulations as well.


The following sections go into details about the syntax and features of <tt>.test</tt> files,
about writing the control script, and give advice on how to cover several use
cases with the <tt>opp_test</tt> tool.

<p>
<h3><a name="sec463"/>15.2.2 Terminology</h3>

<p>The next sections will use the following language:

<p><ul>
<li> <i>test file</i>: A file with the <tt>.test</tt> extension that <tt>opp_test</tt> understands.
<li> <i>test tool</i>: The <tt>opp_test</tt> program
<li> <i>control script</i>: A script that relies on <tt>opp_test</tt> to run the tests.
  The control script is not part of OMNEST because it usually needs to be somewhat
  specific to the simulation model or framework being tested.
<li> <i>test program</i>: The simulation program whose output is checked by the test.
  It is usually <tt>work/work</tt> (<tt>work/work.exe</tt> on Windows). However, it is
  also possible to let the control script build a dynamic library from the test code, and
  then use e.g. <tt>opp_run</tt> as test program.
<li> <i>test directory</i>: The directory where a <tt>.test</tt> file
  is extracted; usually <tt>work/&lt;testname&gt;/</tt>. It is also set as working
  directory for running the test program.
</ul>

<p>
<h3><a name="sec464"/>15.2.3 Test file syntax</h3>

<p>Test files are composed of %-directives of the syntax:

<pre class="filelisting">
%&lt;directive&gt;: &lt;value&gt;
&lt;body&gt;
</pre>
<p>
The body extends up to the next directive, that is, the next line starting with %.
Some directives require a value, others a body, or both.

<p>Certain directives, e.g. <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%contains<font color=maroon><em>  </em>  </font>, may occur several times in the file.

<p><h3><a name="sec465"/>15.2.4 Test description</h3>

<p>Syntax:
<pre class="filelisting">
%description:
&lt;test-description-lines&gt;
</pre>

<p><font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%description<font color=maroon><em>  </em>  </font> is customarily written at the top of the <tt>.test</tt>
file, and lets you provide a multi-line comment about the purpose of the
test. It is recommended to invest time into well-written descriptions,
because determining the original purpose of a test that has become broken
can often be quite difficult without them.

<p>
<h3><a name="sec466"/>15.2.5 Test code generation</h3>

<p>This section describes the ways you can create C++ source and other files
into the test directory.

<p><p class="subheading">%activity</p>

<p>Syntax:

<pre class="filelisting">
%activity:
&lt;body-of-activity()&gt;
</pre>
<p>
<font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%activity<font color=maroon><em>  </em>  </font> lets you run test code without the need for much additional boilerplate.
It generates a simple module that contains a single <tt>activity()</tt> method, and places
your code into <tt>activity()</tt>.

<p>A NED file containing the simple module's (barebones) declaration, and an
ini file to set up the module as a network are also generated.

<p>
<p class="subheading">%module</p>

<p>Syntax:

<pre class="filelisting">
%module: &lt;modulename&gt;
&lt;simple-module-C++-definition&gt;
</pre>
<p>
<font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%module<font color=maroon><em>  </em>  </font> lets you define a module class and run it as the only module
in the simulation.

<p>A NED file containing the simple module's (barebones) declaration, and an
ini file to set up the module as a network are also generated.

<p>
<p class="subheading">%includes, %global</p>

<p>Syntax:

<pre class="filelisting">
%includes:
&lt;#include directives&gt;
</pre>
<p>
<pre class="filelisting">
%global:
&lt;global-code-pasted-before-activity&gt;
</pre>

<p><font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%includes<font color=maroon><em>  </em>  </font> and <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%global<font color=maroon><em>  </em>  </font> are helpers for <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%activity<font color=maroon><em>  </em>  </font>
and <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%module<font color=maroon><em>  </em>  </font>, to allow you to insert additional lines into the
generated C++ code.

<p>They both insert the code block above the module C++ declaration, the only
difference is in their relation to the C++ namespace: <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%includes<font color=maroon><em>  </em>  </font> is
inserted above (outside) the namespace, and <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%globals<font color=maroon><em>  </em>  </font> is inserted
inside the namespace.

<p>
<p class="subheading">The default ini file</p>

<p>The following ini file is always generated:

<pre class="inifile">
[General]
network = &lt;network-name&gt;
cmdenv-express-mode = false
</pre>
<p>
The network name in the file is chosen to match the module
generated with <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%activity<font color=maroon><em>  </em>  </font> or <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%module<font color=maroon><em>  </em>  </font>; if they
are absent, it will be <tt>Test</tt>.

<p><p class="subheading">%network</p>

<p>Syntax:

<pre class="filelisting">
%network: &lt;network-name&gt;
</pre>
<p>
This directive can be used to override the network name in the default ini file.

<p>
<p class="subheading">%file, %inifile</p>

<p>Syntax:

<pre class="filelisting">
%file: &lt;file-name&gt;
&lt;file-contents&gt;
</pre>
<p>
<pre class="filelisting">
%inifile: [&lt;inifile-name&gt;]
&lt;inifile-contents&gt;
</pre>

<p><font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%file<font color=maroon><em>  </em>  </font> saves a file with the given file name and content into the test's
extraction folder in the preparation phase of the test run. It is customarily
used for creating NED files, MSG files, ini files, and extra data files
required by the test. There can be several <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%file<font color=maroon><em>  </em>  </font> sections in the test file.

<p><font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%inifile<font color=maroon><em>  </em>  </font> is similar to <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%file<font color=maroon><em>  </em>  </font> in that it also saves a file with the
given file name and content, but it additionally also adds the file to the simulation's
command line, causing the simulation to read it as an (extra) ini file.
There can be several <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%inifile<font color=maroon><em>  </em>  </font> sections in the test file.

<p>The default ini file is always generated.

<p>
<p class="subheading">The @TESTNAME@ macro</p>

<p>In test files, the string <tt>@TESTNAME@</tt> will be replaced with the test
case name. Since it is substituted everywhere (C++, NED, msg and ini
files), you can also write things like <tt>@TESTNAME@_function()</tt>, or
<tt>printf("this is @TESTNAME@\n")</tt>.

<p><p class="subheading">Avoiding C++ name clashes</p>

<p>Since all sources are compiled into a single test executable, actions have
to be taken to prevent accidental name clashes between C++ symbols in
different test cases. A good way to ensure this is place all code into
namespaces named after the test cases.

<pre class="filelisting">
namespace @TESTNAME@ {
   ...
};
</pre>
<p>
This is done automatically for the <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%activity<font color=maroon><em>  </em>  </font>, <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%module<font color=maroon><em>  </em>  </font>,
<font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%global<font color=maroon><em>  </em>  </font> blocks, but for other files (e.g. source files generated
via <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%file<font color=maroon><em>  </em>  </font>, that needs to be done manually.

<p>
<h3><a name="sec467"/>15.2.6 PASS criteria</h3>

<p><p class="subheading">%contains, %contains-regex, %not-contains, %not-contains-regex</p>

<p>Syntax:

<pre class="filelisting">
%contains: &lt;output-file-to-check&gt;
&lt;multi-line-text&gt;
</pre>
<p>
<pre class="filelisting">
%contains-regex: &lt;output-file-to-check&gt;
&lt;multi-line-regexp&gt;
</pre>

<pre class="filelisting">
%not-contains: &lt;output-file-to-check&gt;
&lt;multi-line-text&gt;
</pre>
<p>
<pre class="filelisting">
%not-contains-regex: &lt;output-file-to-check&gt;
&lt;multi-line-regexp&gt;
</pre>

<p>These directives let you check for the presence (or absence) of certain text in
the output. You can check a file, or the standard output or standard error of
the test program; for the latter two you need to specify <tt>stdout</tt> or
<tt>stderr</tt> as file name. If the file is not found, the test will be marked
as <i>unresolved</i>. There can be several <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%contains<font color=maroon><em>  </em>  </font>-style directives
in the test file.

<p>The text or regular expression can be multi-line. Before match is attempted,
trailing spaces are removed from all lines in both the pattern and the
file contents; leading and trailing blank lines in the patterns are removed;
and any substitutions are performed (see <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%subst<font color=maroon><em>  </em>  </font>). Perl-style regular
expressions are accepted.

<p>To facilitate debugging of tests, the text/regex blocks are saved into
the test directory.

<p>
<p class="subheading">%subst</p>

<p>Syntax:

<pre class="filelisting">
%subst: /&lt;search-regex&gt;/&lt;replacement&gt;/&lt;flags&gt;
</pre>
<p>
It is possible to apply text substitutions to the output before it is
matched against expected output. This is done with <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%subst<font color=maroon><em>  </em>  </font>
directive; there can be more than one <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%subst<font color=maroon><em>  </em>  </font> in a test file. It
takes a Perl-style regular expression to search for, a replacement text,
and flags, in the <i>/search/replace/flags</i> syntax. Flags can be empty
or a combination of the letters <tt>i</tt>, <tt>m</tt>, and <tt>s</tt>, for
case-insensitive, multi-line or single-string match (see the Perl regex
documentation.)

<p><font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%subst<font color=maroon><em>  </em>  </font> was primarily invented to deal with differences in printf
output across platforms and compilers: different compilers print infinite
and not-a-number in different ways: <tt>1.#INF</tt>, <tt>inf</tt>, <tt>Inf</tt>,
<tt>-1.#IND</tt>, <tt>nan</tt>, <tt>NaN</tt> etc. With <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%subst<font color=maroon><em>  </em>  </font>, they can be
brought to a common form:

<pre class="filelisting">
%subst: /-?1\.#INF/inf/
%subst: /-?1\.#IND/nan/
%subst: /-?1\.#QNAN/nan/
%subst: /-?NaN/nan/
%subst: /-?nan/nan/
</pre>
<p>
<p class="subheading">%exitcode, %ignore-exitcode</p>

<p>Syntax:
<pre class="filelisting">
%exitcode: &lt;one-or-more-numeric-exit-codes&gt;
</pre>

<pre class="filelisting">
%ignore-exitcode: 1
</pre>
<p>
<font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%exitcode<font color=maroon><em>  </em>  </font> and <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%ignore-exitcode<font color=maroon><em>  </em>  </font> let you test the exit code of the
test program. The former checks the exit code is one of the numbers specified in
the directive; the other makes the test framework ignore the exit code.

<p>OMNEST simulations exit with zero if the simulation terminated
without an error, and some &gt;0 code if an runtime error occurred. Normally,
a nonzero exit code makes the test fail. However, if the expected outcome
is a runtime error (e.g. you want to test parameter validation code), you
can use either <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%exitcode<font color=maroon><em>  </em>  </font> to express that, or specify <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%ignore-exitcode<font color=maroon><em>  </em>  </font>
and test for the presence of the correct error message in the output.

<p>

<p><p class="subheading">%file-exists, %file-not-exists</p>

<p>Syntax:

<pre class="filelisting">
%file-exists: &lt;filename&gt;
</pre>
<p>
<pre class="filelisting">
%file-not-exists: &lt;filename&gt;
</pre>

<p>These directives test for the presence or absence of a certain file in
the test directory.

<p><h3><a name="sec468"/>15.2.7 Extra processing steps</h3>

<p><p class="subheading">%env, %extraargs, %testprog</p>

<p>Syntax:

<pre class="filelisting">
%env: &lt;environment-variable-name&gt;=&lt;value&gt;
</pre>
<p>
<pre class="filelisting">
%extraargs: &lt;argument-list&gt;
</pre>

<pre class="filelisting">
%testprog: &lt;executable&gt;
</pre>
<p>
The <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%env<font color=maroon><em>  </em>  </font> directive lets you set an environment variable that will
be defined when the test program and the potential pre- and post-processing
commands run. There can be multiple <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%env<font color=maroon><em>  </em>  </font> directives in the test
file.

<p><font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%extraargs<font color=maroon><em>  </em>  </font> lets you add extra command-line arguments to the
test program (usually the simulation) when it is run.

<p>The <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%testprog<font color=maroon><em>  </em>  </font> directive lets you replace the test program.
<font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%testprog<font color=maroon><em>  </em>  </font> also slightly alters the arguments the test program is
run with. Normally, the test program is launched with the following command
line:

<pre class="filelisting">
$ &lt;default-testprog&gt; -u Cmdenv &lt;test-extraargs&gt; &lt;global-extraargs&gt; &lt;inifiles&gt;
</pre>
<p>
When <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%testprog<font color=maroon><em>  </em>  </font> is present, it becomes the following:

<pre class="filelisting">
$ &lt;custom-testprog&gt; &lt;test-extraargs&gt; &lt;global-extraargs&gt;
</pre>
<p>
That is, <tt>-u Cmdenv</tt> and <tt>&lt;inifilenames&gt;</tt> are removed; this allows you to
use programs that do not require or understand them, and places you in complete
command of the arguments list.

<p>Note that <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%extraargs<font color=maroon><em>  </em>  </font> and <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%testprog<font color=maroon><em>  </em>  </font> have an equivalent
command-line option in <tt>opp_test</tt>. (In the text above,
<tt>&lt;global-extraargs&gt;</tt> stands for extra args specified to
<tt>opp_test</tt>.)  <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%env<font color=maroon><em>  </em>  </font> doesn't need an option in
<tt>opp_test</tt>, because the test program inherits the environment
variables from <tt>opp_test</tt>, so you can just set them in the control
script, or in the shell you run the tests from.

<p>
<p class="subheading">%prerun-command, %postrun-command</p>

<p>Syntax:

<pre class="filelisting">
%prerun-command: &lt;command&gt;
</pre>
<p>
<pre class="filelisting">
%postrun-command: &lt;command&gt;
</pre>

<p>These directives let you run extra commands before/after running the test
program (i.e. the simulation). There can be multiple pre- and post-run
commands. The post-run command is useful when the test outcome cannot be determined
by simple text matching, but requires statistical evaluation or other processing.

<p>If the command returns a nonzero exit code, the test framework will assume that
it is due to a technical problem (as opposed to test failure), and count the
test as <i>unresolved</i>. To make the test fail, let the command write a
file, and match the file's contents using <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%contains<font color=maroon><em>  </em>  </font> &amp; co.

<p>If the post-processing command is a short script, it is practical
to add it into the <tt>.test</tt> file via the <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%file<font color=maroon><em>  </em>  </font> directive,
and invoke it via its interpreter. For example:

<pre class="filelisting">
%postrun-command: python test.py
%file: test.py
&lt;Python script&gt;
</pre>
<p>
Or:

<pre class="filelisting">
%postrun-command: R CMD BATCH test.R
%file: test.R
&lt;R script&gt;
</pre>
<p>
If the script is very large or shared among several tests, it is more practical
to place it into a separate file. The test command can find the script e.g.
by relative path, or by referring to an environment variable that contains
its location or full path.

<p>
<h3><a name="sec469"/>15.2.8 Unresolved</h3>

<p>A test case is unresolved if the test program cannot be executed at all, the
output cannot be read, or if the test case declares so. The latter is done
by printing <tt>#UNRESOLVED</tt> or <tt>#UNRESOLVED:some-explanation</tt> on the
standard output, at the beginning of the line.

<p>
<h3><a name="sec470"/>15.2.9 opp_test synopsys</h3>

<p>Little has been said so far what <tt>opp_test</tt> actually does, or how you
can invoke it.

<p>It can be invoked in two modes: file generation and test running. When running
a test suite, it will actually be run twice, once in file generation mode,
then in test running mode.

<p>File generation mode has the syntax <tt>opp_test gen <i>&lt;options&gt;
&lt;testfiles&gt;</i></tt>. For example:

<pre class="filelisting">
$ opp_test gen *.test
</pre>
<p>
This command will extract C++ and NED files, ini files, etc., from
the <tt>.test</tt> files into separate files. All files will be created
in a work directory (which defaults to <tt>./work/</tt>),
and each test will have its own subdirectory under <tt>./work/</tt>.

<p>The second mode, test running, is invoked as <tt>opp_test run <i>&lt;options&gt;
&lt;testfiles&gt;</i></tt>. For example:

<pre class="filelisting">
$ opp_test run *.test
</pre>
<p>
In this mode, <tt>opp_test</tt> will run the simulations, check the
results, and report the number of passes and failures. The way of invoking
simulations (which executable to run, the list of command-line arguments to
pass, etc.) can be specified to <tt>opp_test</tt> via command-line options.

<p><ul class="note"><b>NOTE</b><br>
Run <tt>opp_test</tt> in your OMNEST installation to get the exact list of
command-line options.
</ul>

<p>The simulation needs to have been built from source before <tt>opp_test
run</tt> can be issued. Usually one would employ a command similar to

<pre class="filelisting">
$ cd work; opp_makemake --deep --no-deep-includes; make
</pre>
<p>
to achieve that.

<p><h3><a name="sec471"/>15.2.10 Writing the control script</h3>

<p>Usually one writes a control script to automate the two invocations of <tt>opp_test</tt>
and the build of the simmulation model between them.

<p>A basic variant would look like this:

<pre class="filelisting">
#! /bin/sh
opp_test gen -v *.test || exit 1
(cd work; opp_makemake -f --deep --no-deep-includes; make) || exit 1
opp_test run -v *.test
</pre>
<p>
For any practical use, the test suite needs to refer to the codebase being
tested. This means that the codebase must be added to the include path,
must be linked with, and the NED files must be added to the NED path. The
first two can be achieved by the appropriate parameterization of
<tt>opp_makemake</tt>; the last one can be done by setting and exporting
the <tt>NEDPATH</tt> environment variable in the control script.

<p>For inspiration, check out <tt>runtest</tt> in the <tt>omnetpp/test/core</tt>
directory, and a similar script used in the INET Framework.

<p>
<h2><a name="sec472"/>15.3 Implementing various types of tests</h2>

<p><h3><a name="sec473"/>15.3.1 Smoke tests</h3>

<p>Smoke tests are a tool for very basic verification and regression testing.
Basically, the simulation is run for a while, and it must not crash or stop
with a runtime error. Naturally, smoke test provide very low confidence in
the model, but in turn they are very easy to implement.

<p>Automation is important. The INET Framework contains a script that runs all
or selected simulations defined in a CSV file (with columns like the working
directory and the command to run), and reports the results. The script can
be easily adapted to other models or model frameworks.

<p>
<h3><a name="sec474"/>15.3.2 Fingerprint tests</h3>

<p>Fingerprint tests are a low-cost but effective tool for regression testing
of simulation models. Fingerprint itself is a hash computed from various
properties of simulation events as the simulation executes, and thus, the
final fingerprint value is characteristic of the trajectory of the
simulation. For regression testing, one just needs to compare the computed
fingerprint to that from a reference run -- if they differ, the simulation
trajectory has changed.

<p>Fingerprint tests are very useful for ensuring that a change (refactoring,
bugfix, or new feature) didn't break the simulation. The fingerprint
computation algorithm was deliberately designed so that it is immune to
&#8220;unimportant&#8221; changes (e.g. changes in the debug log messages), but
signals if the behaviour of the model changes.
  <br><ul><font size=-1>[The current (OMNEST 4.x) fingerprint is computed from the module
  ID and simulation time of each event. This is likely to change in OMNEST
  5.x, partly to make the fingerprint immune to module ID changes.]</font></ul>

<p>Technically, providing a <b><tt>fingerprint</tt></b> option in the config file or
on the command line (<tt>-fingerprint=...</tt>) will turn on fingerprint
computation in the OMNEST simulation kernel. When the simulation
terminates, OMNEST will compare the computed hash with the provided one,
and if they differ, an error is generated.

<p><ul class="warning"><b>WARNING</b><br>
The computed fingerprint value is heavily dependent on the accuracy of the
floating point arithmetic. There are differences between the floating point
handling of AMD and Intel CPUs. Running under a processor emulator software
like <tt>valgrind</tt> may also produce a different fingerprint. This is
normal. Hint: see gcc options <tt>-mfpmath=sse -msse2</tt>.
</ul>

<p>The INET Framework contains a script for automated fingerprint tests as
well. The script runs all or selected simulations defined in a CSV file
(with columns like the working directory, the command to run, and the
expected fingerprint), and reports the results. The script is extensively
used during INET Framework development to detect regressions, and can be
easily adapted to other models or model frameworks.

<p>
<h3><a name="sec475"/>15.3.3 Unit tests</h3>

<p>If a simulation models contains units of code (classes, functions) smaller
than a module, they are candidates for unit testing. For a network simulation
model, examples of such classes are network addresses, fragmentation reassembly
buffers, queues, various caches and tables, serializers and deserializers,
checksum computation, etc.

<p>Unit tests can be implemented as <tt>.test</tt> files using the <tt>opp_test</tt>
tool (the <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%activity<font color=maroon><em>  </em>  </font> directive is especially useful here), or
with potentially any other C++ unit testing framework.

<p>When using <tt>.test</tt> files, the <i>build</i> part of the control script
needs to be set up so that it adds the tested library's source folder(s)
to the include path, and also links the library to the test code.

<p>

<p><h3><a name="sec476"/>15.3.4 Module tests</h3>

<p>OMNEST modules are not as easy to unit test as standalone classes, because
they typically assume a more complex environment, and, especially modules
that implement network protocols, participate in more complex interactions
than the latter.

<p>To test a module in isolation, one needs to place it into a simulation
where the module's normal operation environment (i.e. other modules it
normally communicates with) are replaced by mock objects. Mock objects are
responsible for providing stimuli for the module under test, and (partly)
for checking the response.

<p>Module tests may be implemented in <tt>.test</tt> files using the <tt>opp_test</tt>
tool. A <tt>.test</tt> file allows you to place the test description, the test setup
and the expected output into a single, compact file, while large files or files shared
among several tests may be factored out and only referenced by <tt>.test</tt> files.

<p>
<h3><a name="sec477"/>15.3.5 Statistical tests</h3>

<p>Statistical tests are those where the test outcome is decided on
some statistical property or properties of the simulation results.

<p>Statistical tests may be useful as validation as well as regression testing.

<p><p class="subheading">Validation tests</p>

<p>Validation tests aim to verify that simulation results correspond to some
reference values, ideally to those obtained from the real system. In
practice, reference values may come from physical measurements, theoretical
values, or another simulator's results.

<p><p class="subheading">Statistical regression tests</p>

<p>After a refactoring that changes the simulation trajectory (e.g. after
eliminating or introducing extra events, or changes in RNG usage), there
may be no other way to do regression testing than checking that the model
produces <i>statistically</i> the same results as before.

<p>For statististical regression tests, one needs to perform several
simulation runs with the same configuration but different RNG seeds, and
verify that the results are from the same distributions as before. One can
use <i>Student's t-test</i> (for mean) and the <i>F-test</i> (for
variance) to check that the &#8220;before&#8221; and the &#8220;after&#8221; sets of results
are from the same distribution.

<p><p class="subheading">Implementation</p>

<p>Statistical software like <i>GNU R</i> is extremely useful for these
tests.

<p>Statistical tests may also be implemented in <tt>.test</tt> files. To let the
tool run several simulations within one test, one may use
<font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%extraargs<font color=maroon><em>  </em>  </font> to pass the <tt>-r <i>&lt;runs&gt;</i></tt> option to Cmdenv;
alternatively, one may use <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%testprog<font color=maroon><em>  </em>  </font> to have the test tool run
<tt>opp_runall</tt> instead of the normal simulation program. For doing the
statistical computations, one may use <font color=maroon><em> Unknown LaTeX command </em> \ftest </font>%postrun-command<font color=maroon><em>  </em>  </font> to run an R
script. The R script may rely on the <tt>omnetpp</tt> R package for reading
the result files.

<p>The INET Framework contains statistical tests where you can look for
inspiration.

<p>

<p>


<hr class='pgbr'><h1><a name="sec478"/>16 Parallel Distributed Simulation</h1>
<a name="cha:parallel-execution"></a>


<h2><a name="sec479"/>16.1 Introduction to Parallel Discrete Event Simulation</h2>

<p>OMNeT++ supports parallel execution<!--parallel simulation--> of large
simulations. This section provides a brief picture
of the problems and methods of parallel
discrete event simulation (PDES<!--PDES-->). Interested readers are
strongly encouraged to look into the literature.

<p>For parallel execution, the model is to be partitioned into several
LPs (logical processes) that will be simulated independently on
different hosts or processors. Each LP will have its own local
Future Event Set, and thus will maintain its own local simulation
time. The main issue with parallel simulations is keeping LPs
synchronized in order to avoid violating the causality of events.
Without synchronization, a message sent by one LP could arrive in
another LP when the simulation time in the receiving LP has already
passed the timestamp (arrival time) of the message. This would break
causality<!--event!causality--> of events in the receiving LP.

<p>There are two broad categories of parallel simulation algorithms
that differ in the way they handle causality problems outlined
above:

<p><ol>
  <li><b>Conservative algorithms</b><!--parallel simulation!conservative-->
    prevents incausalities from happening. The Null Message Algorithm
    exploits knowledge of the time when LPs send messages to other LPs,
    and uses `null' messages to propagate this information to other LPs.
    If an LP knows it won't receive any messages from other
    LPs until <i>t+&Delta; t</i> simulation time, it may advance until
    <i>t+&Delta; t</i> without the need for external synchronization.
    Conservative simulation tends to converge to sequential simulation
    (slowed down by communication between LPs) if there is not
    enough parallelism in the model, or parallelism is not exploited
    by sending a sufficient number of `null' messages.

<p>  <li><b>Optimistic synchronization</b><!--parallel simulation!optimistic-->
    allows incausalities to occur, but detects and
    repairs them. Repairing involves rollbacks to a previous state,
    sending out anti-messages to cancel messages sent out during the
    period that is being rolled back, etc.  Optimistic synchronization
    is extremely difficult to implement, because it requires periodic
    state saving and the ability to restore previous states. In any
    case, implementing optimistic synchronization in OMNeT++ would
    require -- in addition to a more complicated simulation kernel --
    writing significantly more complex simple<!--module!simple-->
    module code from the user.  Optimistic synchronization may be slow
    in cases of excessive rollbacks.
</ol>

<p>
<h2><a name="sec480"/>16.2 Assessing Available Parallelism in a Simulation Model</h2>

<p>OMNeT++ currently supports conservative synchronization
via the classic Chandy-Misra-Bryant (or null message) algorithm
[<a href="#bib-chandymisra79">chandymisra79</a>].
To assess how efficiently a simulation can be parallelized
with this algorithm, we'll need the following variables:

<p><ul>
  <li><i>P</i> <i>performance</i> represents the number of events processed per
    second (ev/sec).
       <br><ul><font size=-1>[Notations: <i>ev:</i> events, <i>sec:</i> real seconds,
       <i>simsec:</i> simulated seconds]</font></ul>
    <i>P</i> depends on the performance of the hardware and the computation-intensiveness
    of processing an event. <i>P</i> is independent of the size of the model.
    Depending on the nature of the simulation model and the performance of the
    computer, <i>P</i> is usually in the range of 20,000..500,000 ev/sec.
  <li><i>E</i> <i>event density</i> is the number of events that occur per
    simulated second (ev/simsec). <i>E</i> depends on the model only, and not
    where the model is executed. <i>E</i> is determined by the size, the detail level
    and also the nature of the simulated system (e.g. cell-level ATM models
    produce higher <i>E</i> values than call center simulations.)
  <li><i>R</i> <i>relative speed</i> measures the simulation time advancement
    per second (simsec/sec). <i>R</i> strongly depends on both the model and
    on the software/hardware environment where the model executes.
    Note that <i>R = P/E</i>.
  <li><i>L</i> <i>lookahead</i> is measured in simulated seconds (simsec).
    When simulating telecommunication networks and using link delays as
    lookahead, <i>L</i> is typically in the msimsec-<i>&mu;</i>simsec range.
  <li><i>&tau;</i> <i>latency</i> (sec) characterizes the parallel simulation hardware.
    <i>&tau;</i> is the latency of sending a message from one LP to another. <i>&tau;</i>
    can be determined using simple benchmark programs. The authors' measurements
    on a Linux cluster interconnected via a 100Mb Ethernet switch using MPI
    yielded <i>&tau;</i>=22<i>&mu;</i>s which is consistent with measurements reported
    in [<a href="#bib-ongfarrell2000">ongfarrell2000</a>]. Specialized hardware such as
    Quadrics Interconnect [<a href="#bib-quadrics">quadrics</a>] can provide <i>&tau;</i>=5<i>&mu;</i>s or better.
</ul>

<p>In large simulation models, <i>P</i>, <i>E</i> and <i>R</i> usually stay relatively constant
(that is, display little fluctuations in time). They are also intuitive and
easy to measure. The OMNeT++ displays these values on the GUI while the simulation
is running, see Figure <a href="#fig:perfbar-screenshot">below</a>. Cmdenv can also be configured
to display these values.

<p>
  <center>
    <img src="parsim-perfbar-screenshot.png">
    <center><i>Figure: Performance bar in OMNeT++ showing <i>P</i>, <i>R</i> and <i>E</i></i></center>
    <a name="fig:perfbar-screenshot"></a>
  </center>

<p>
After having approximate values of <i>P</i>, <i>E</i>, <i>L</i> and <i>&tau;</i>,
calculate the <i>&lambda;</i> <i>coupling factor</i> as the ratio of <i>LE</i> and <i>&tau; P</i>:

<p><i>&lambda; = (LE) / (&tau; P)</i>

<p>Without going into the details: if the resulting <i>&lambda;</i> value is at
minimum larger than one, but rather in the range 10..100, there is
a good chance that the simulation will perform well when run in
parallel. With <i>&lambda; &lt; 1</i>, poor performance is guaranteed.
For details see the paper [<a href="#bib-ParsimCrit03">ParsimCrit03</a>].

<p>
<h2><a name="sec481"/>16.3 Parallel Distributed Simulation Support in OMNeT++</h2>

<p><h3><a name="sec482"/>16.3.1 Overview</h3>

<p>This chapter presents the parallel simulation architecture
of OMNeT++. The design allows simulation models to be run
in parallel without code modification -- it only requires configuration.
The implementation relies on the approach of placeholder modules
and proxy gates to instantiate the model on different LPs --
the placeholder approach allows simulation techniques such as
topology discovery and direct message sending to work unmodified with
PDES. The architecture is modular and extensible, so it can
serve as a framework for research on parallel simulation.

<p>The OMNeT++ design places a big emphasis on
<i>separation of models from experiments</i>. The main rationale
is that usually a large number of simulation experiments need to be done
on a single model before a conclusion can be drawn about the real system.
Experiments tend to be ad-hoc and change much faster than simulation
models; thus it is a natural requirement to be able to
carry out experiments without disturbing the simulation model itself.

<p>Following the above principle, OMNeT++ allows simulation models
to be executed in parallel without modification. No special instrumentation
of the source code or the topology description is needed,
as partitioning and other PDES configuration is entirely described
in the configuration files.

<p>OMNeT++ supports the Null Message Algorithm with static
topologies, using link delays as lookahead. The laziness of null message
sending can be tuned. Also supported is the Ideal Simulation Protocol
(ISP) introduced by Bagrodia in 2000 [<a href="#bib-bagrodia00">bagrodia00</a>]. ISP is
a powerful research vehicle to measure the efficiency of
PDES algorithms, both optimistic and conservative;
more precisely, it helps determine the maximum speedup achievable
by any PDES algorithm for a particular model and simulation environment.
In OMNeT++, ISP can be used for benchmarking the performance of the
Null Message Algorithm.
Additionally, models can be executed without any synchronization, which
can be useful for educational purposes (to demonstrate the need for
synchronization) or for simple testing.

<p>For the communication between LPs (logical processes), OMNeT++
primarily uses MPI, the Message Passing Interface standard
[<a href="#bib-mpiforum94">mpiforum94</a>].  An alternative communication mechanism is based on
named pipes, for use on shared memory multiprocessors without the need
to install MPI.  Additionally, a file system based communication mechanism
is also available. It communicates via text files created in a shared
directory, and can be useful for educational purposes (to analyse or
demonstrate messaging in PDES algorithms) or to debug PDES algorithms.
Implementation of a shared memory-based communication mechanism is also planned
for the future, to fully exploit the power of multiprocessors without
the overhead of and the need to install MPI.

<p>Nearly every model can be run in parallel. The constraints are the following:
<ul>
  <li>modules may communicate via sending messages only (no direct method call
        or member access) unless mapped to the same processor
  <li>no global variables
  <li>there are some limitations on direct sending (no sending to a <i>sub</i>module
        of another module, unless mapped to the same processor)
  <li>lookahead must be present in the form of link delays
  <li>currently static topologies are supported (we are working on a
      research project that aims to eliminate this limitation)
</ul>

<p>PDES support in OMNeT++ follows a modular and extensible architecture.
New communication mechanisms can be added by implementing a compact
API (expressed as a C++ class) and registering the implementation --
after that, the new communications mechanism can be selected for use
in the configuration.

<p>New PDES synchronization algorithms can be added in a similar way.
PDES algorithms are also represented by C++ classes that have
to implement a very small API
to integrate with the simulation kernel.
Setting up the model on various LPs as well as relaying
model messages across LPs is already taken care of and
not something the implementation of the synchronization algorithm
needs to worry about (although it can intervene if needed,
because the necessary hooks are provided).

<p>The implementation of the Null Message Algorithm is also
modular in itself in that the lookahead discovery can be plugged
in via a defined API. Currently implemented lookahead
discovery uses link delays, but it is possible to
implement more sophisticated approaches and select them in the
configuration.

<p>

<p><h3><a name="sec483"/>16.3.2 Parallel Simulation Example</h3>

<p>We will use the Parallel CQN example simulation for demonstrating the
PDES capabilities of OMNeT++.
The model consists of <i>N</i> tandem queues where each tandem consists
of a switch and <i>k</i> single-server queues with exponential service times
(Figure <a href="#fig:cqn-model">below</a>).
The last queues are looped back to their switches. Each switch
randomly chooses the first queue of one of the tandems as destination,
using uniform distribution. The queues and switches are connected
with links that have nonzero propagation delays.
Our OMNeT++ model for CQN wraps tandems into compound modules.

<p>

<p>  <center>
    <img src="parsim-cqn-model.png">
    <center><i>Figure: The Closed Queueing Network (CQN) model</i></center>
    <a name="fig:cqn-model"></a>
  </center>

<p>
To run the model in parallel, we assign tandems to different LPs
(Figure <a href="#fig:cqn-partitioning">below</a>). Lookahead is provided
by delays on the marked links.

<p>
  <center>
    <img src="parsim-cqn-partitioning.png">
    <center><i>Figure: Partitioning the CQN model</i></center>
    <a name="fig:cqn-partitioning"></a>
  </center>

<p>
To run the CQN model in parallel, we have to configure it for parallel
execution. In OMNeT++, the configuration is in the
<tt>omnetpp.ini</tt> file. For configuration, first we have to specify
partitioning, that is, assign modules to processors. This is done
by the following lines:

<pre class="inifile">
[General]
*.tandemQueue[0]**.partition-id = 0
*.tandemQueue[1]**.partition-id = 1
*.tandemQueue[2]**.partition-id = 2
</pre>
<p>
The numbers after the equal sign identify the LP.

<p>Then we have to select the communication library and the parallel
simulation algorithm, and enable parallel simulation:

<pre class="inifile">
[General]
parallel-simulation = true
parsim-communications-class = "cMPICommunications"
parsim-synchronization-class = "cNullMessageProtocol"
</pre>
<p>
When the parallel simulation is run, LPs are represented
by multiple running instances of the same program.
When using LAM-MPI [<a href="#bib-lammpi">lammpi</a>], the mpirun program (part of LAM-MPI)
is used to launch the program on the desired processors.
When named pipes or file communications is selected, the opp_prun
OMNeT++ utility can be used to start the processes.
Alternatively, one can run the processes by hand (the -p flag
tells OMNeT++ the index of the given LP and the total number of LPs):

<pre class="commandline">
./cqn -p0,3 &
./cqn -p1,3 &
./cqn -p2,3 &
</pre>
<p>
For PDES, one will usually want to select the command-line user interface,
and redirect the output to files. (OMNeT++ provides the necessary
configuration options.)

<p>The graphical user interface of OMNeT++ can also be used
(as evidenced by Figure <a href="#fig:parsim-screenshot">below</a>),
independently of the selected communication mechanism.
The GUI interface can be useful for educational or demonstration purposes.
OMNeT++ displays debugging output about the Null Message Algorithm,
EITs and EOTs can be inspected, etc.

<p>


<p>
  <center>
    <img src="parsim-screenshot.png">
    <center><i>Figure: Screenshot of CQN running in three LPs</i></center>
    <a name="fig:parsim-screenshot"></a>
  </center>

<p>

<p>
<h3><a name="sec484"/>16.3.3 Placeholder Modules, Proxy Gates</h3>

<p>When setting up a model partitioned to several LPs,
OMNeT++ uses placeholder modules and proxy gates.
In the local LP, placeholders represent sibling submodules
that are instantiated on other LPs.
With placeholder modules, every module has all of its siblings
present in the local LP -- either as placeholder or as the &#8220;real thing&#8221;.
Proxy gates take care of forwarding messages to the LP where
the module is instantiated (see Figure <a href="#fig:plach">below</a>).

<p>The main advantage of using placeholders is that algorithms such as
topology discovery embedded in the model can be used with PDES unmodified.
Also, modules can use direct message sending to any sibling module,
including placeholders. This is so because the destination of direct message
sending is an input gate of the destination module -- if the destination
module is a placeholder, the input gate will be a proxy gate which
transparently forwards the messages to the LP where the &#8220;real&#8221; module
was instantiated. A limitation is that the destination of direct message
sending cannot be a <i>submodule</i> of a sibling (which is
probably a bad practice anyway, as it violates encapsulation),
simply because placeholders are empty and so its submodules are
not present in the local LP.

<p>Instantiation of compound modules is slightly more complicated.
Since submodules can be on different LPs, the compound module may
not be &#8220;fully present&#8221; on any given LP, and it may have to be
present on several LPs (wherever it has submodules instantiated).
Thus, compound modules are instantiated wherever they have
at least one submodule instantiated, and are represented by placeholders
everywhere else (Figure <a href="#fig:inst">below</a>).

<p>

<p>  <center>
    <img src="parsim-placeholders.png">
    <center><i>Figure: Placeholder modules and proxy gates</i></center>
    <a name="fig:plach"></a>
  </center>

<p>

<p>  <center>
    <img src="parsim-placeholders2.png">
    <center><i>Figure: Instantiating compound modules</i></center>
    <a name="fig:inst"></a>
  </center>

<p>

<p>
<h3><a name="sec485"/>16.3.4 Configuration</h3>

<p>Parallel simulation configuration is the <tt>[General]</tt> section of <tt>omnetpp.ini</tt>.

<p>The parallel distributed simulation feature can be turned on with the
<b><tt>parallel-simulation</tt></b> boolean option.

<p>The <b><tt>parsim-communications-class</tt></b> selects the class that implements
communication between partitions. The class must implement the
<tt><a href="../api/classcParsimCommunications.html">cParsimCommunications</a></tt> interface.

<p>
The <b><tt>parsim-synchronization-class</tt></b> selects the parallel simulation algorithm.
The class must implement the <tt>cParsimSynchronizer</tt> interface.

<p>
The following two options configure the Null Message Algorithm, so
they are only effective if <tt>cNullMessageProtocol</tt> has been selected
as synchronization class:

<p><ul>
  <li> <b><tt>parsim-nullmessageprotocol-lookahead-class</tt></b>
    selects the lookahead class for the NMA; the class must be subclassed
    from <tt>cNMPLookahead</tt>. The default class is <tt>cLinkDelayLookahead</tt>.

<p>  <li> <b><tt>parsim-nullmessageprotocol-laziness</tt></b> expects a number
    in the <i>(0,1)</i> interval (the default is 0.5), and it ontrols how often
    NMA should send out null messages; the value is understood in proportion
    to the lookahead, e.g. 0.5 means every <i>lookahead/2</i> simsec.
</ul>

<p>The <b><tt>parsim-debug</tt></b> boolean option enables/disables printing
log messages about the parallel simulation algorithm. It is turned on
by default, but for production runs we recommend turning it off.

<p>Other configuration options configure MPI buffer sizes and other details;
see options that begin with <tt>parsim-</tt> in Appendix <a href="#sec566">[25]</a>.

<p>
When you are using cross-mounted home directories (the simulation's
directory is on a disk mounted on all nodes of the cluster),
a useful configuration setting is

<pre class="inifile">
[General]
fname-append-host = true
</pre>
<p>
It will cause the host names to be appended to the names of
all output vector files, so that partitions don't overwrite each other's
output files. (See section <a href="#sec374">[10.5.3]</a>)

<p>

<p>

<p><h3><a name="sec486"/>16.3.5 Design of PDES Support in OMNeT++</h3>

<p>The design of PDES support in OMNeT++ follows a layered approach,
with a modular and extensible architecture. The overall
architecture is depicted in Figure <a href="#fig:parsim-arch">below</a>.

<p>
  <center>
    <img src="parsim-arch.png">
    <center><i>Figure: Architecture of OMNeT++ PDES implementation</i></center>
    <a name="fig:parsim-arch"></a>
  </center>

<p>
The parallel simulation subsytem is an optional component
itself, which can be removed from the simulation kernel
if not needed. It consists of three layers, from the bottom up:
Communications Layer, Partitioning Layer and Synchronization Layer.

<p><p class="subheading">The Communications Layer</p>

<p>The purpose of the Communications Layer is to
provide elementary messaging services between partitions for the
upper layer. The services include send, blocking receive,
nonblocking receive and broadcast. The send/receive operations
work with <i>buffers</i>, which encapsulate packing and unpacking
operations for primitive C++ types. The message class and
other classes in the simulation library can pack and unpack
themselves into such buffers. The Communications layer API
is defined in the <tt><a href="../api/classcParsimCommunications.html">cParsimCommunications</a></tt> interface
(abstract class); specific implementations like the MPI
one (<tt>cMPICommunications</tt>) subclass from this,
and encapsulate MPI send/receive calls. The matching buffer
class <tt>cMPICommBuffer</tt> encapsulates MPI pack/unpack
operations.

<p><p class="subheading">The Partitioning Layer</p>

<p>The Partitioning Layer is responsible for instantiating
modules on different LPs according to the partitioning specified
in the configuration, for configuring proxy gates.
During the simulation, this layer also ensures that cross-partition
simulation messages reach their destinations. It intercepts messages
that arrive at proxy gates and transmits them to the destination LP
using the services of the Communications Layer. The receiving LP
unpacks the message and injects it at the gate the proxy gate points at.
The implementation basically encapsulates the
<tt>cParsimSegment</tt>, <tt>cPlaceholderModule</tt>,
<tt>cProxyGate</tt> classes.

<p><p class="subheading">The Synchronization Layer</p>

<p>The Synchronization Layer encapsulates the parallel
simulation algorithm. Parallel simulation algorithms are also represented
by classes, subclassed from the <tt>cParsimSynchronizer</tt> abstract class.
The parallel simulation algorithm is invoked on the following hooks:
event scheduling, processing model messages outgoing from the LP,
and messages (model messages or internal messages) arriving
from other LPs. The first hook, event scheduling, is a function
invoked by the simulation kernel to determine the next simulation
event; it also has full access to the future event set (FES<!--FES-->) and
can add/remove events for its own use.
Conservative parallel simulation algorithms will use this hook
to block the simulation if the next event is unsafe, e.g. the
null message algorithm implementation (<tt>cNullMessageProtocol</tt>)
blocks the simulation if an EIT has been reached until a null message
arrives (see [<a href="#bib-bagrodia00">bagrodia00</a>] for terminology); also it uses
this hook to periodically send null messages. The second hook
is invoked when a model message is sent to another LP;
the null message algorithm uses this hook to piggyback null
messages on outgoing model messages. The third hook is invoked
when any message arrives from other LPs, and it allows the
parallel simulation algorithm to process its own internal messages
from other partitions; the null message algorithm processes
incoming null messages here.

<p>The Null Message Protocol implementation itself is modular;
it employs a separate, configurable lookahead discovery object.
Currently only link delay based lookahead discovery has been
implemented, but it is possible to implement more sophisticated
types.

<p>The Ideal Simulation Protocol (ISP; see [<a href="#bib-bagrodia00">bagrodia00</a>])
implementation consists of two parallel simulation
protocol implementations:
the first one is based on the null message algorithm and
additionally records the external events (events received
from other LPs) to a trace file; the second one executes
the simulation using the trace file to find out which
events are safe and which are not.

<p>Note that although we implemented a conservative protocol,
the provided API itself would allow implementing optimistic
protocols, too. The parallel simulation algorithm has
access to the executing simulation model, so it could perform
saving/restoring model state if model objects support this
  <br><ul><font size=-1>[Unfortunately, support for state saving/restoration
  needs to be individually and manually added to each class
  in the simulation, including user-programmed simple modules.]</font></ul>.

<p>We also expect that because of the modularity, extensibility and
clean internal architecture of the parallel simulation subsystem,
the OMNeT++ framework has the potential to become a preferred platform
for PDES research.

<p>
<hr class='pgbr'><h1><a name="sec487"/>17 Plug-in Extensions</h1>
<a name="cha:plugin-exts"></a>

<p><h2><a name="sec488"/>17.1 Overview</h2>

<p>OMNEST is an open system, and several details of its operation
can be customized via plug-ins. To create a plug-in, you generally
need to write a C++ class that implements a certain interface
(i.e. subclasses from a C++ abstract class), and register it in OMNEST.
The plug-in class can be activated for a particular simulation
with a corresponding configuration option.

<p>The following plug-in interfaces are supported:

<p><ul>
   <li><tt><a href="../api/classcRNG.html">cRNG</a></tt>. Interface for random number generators.
   <li><tt><a href="../api/classcScheduler.html">cScheduler</a></tt>. The scheduler class. This plug-in interface
     allows for implementing real-time, hardware-in-the-loop, distributed
     and distributed parallel simulation.
   <li><tt><a href="../api/classcConfigurationEx.html">cConfigurationEx</a></tt>. Configuration provider plug-in.
     This plug-in interface lets you replace <tt>omnetpp.ini</tt>
     with some other implementation, for example a database.
   <li><tt><a href="../api/classcOutputScalarManager.html">cOutputScalarManager</a></tt>. It handles recording the scalar output data.
     The default output scalar manager is <tt>cFileOutputScalarManager</tt>,
     defined in the Envir library.
   <li><tt><a href="../api/classcOutputVectorManager.html">cOutputVectorManager</a></tt>. It handles recording the output
     from <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects. The default output vector manager is
     <tt>cIndexedFileOutputVectorManager</tt>, defined in the Envir library.
   <li><tt><a href="../api/classcSnapshotManager.html">cSnapshotManager</a></tt>. It provides an output stream to which
     snapshots are written (see section <a href="#sec299">[7.10.5]</a>).
     The default snapshot manager is <tt>cFileSnapshotManager</tt>,
     defined in the Envir library.
</ul>

<p><a name="sec:ch-plugin-exts:customization"></a>

<p>The classes (<tt><a href="../api/classcRNG.html">cRNG</a></tt>, <tt><a href="../api/classcScheduler.html">cScheduler</a></tt>, etc.) are documented in
the API Reference.

<p>To actually implement and select a plug-in for use:

<p><ol>
   <li> Subclass the given interface class (e.g. for a custom RNG, <tt><a href="../api/classcRNG.html">cRNG</a></tt>)
     to create your own version.
   <li> Register the class by putting the <tt>Register_Class(MyRNGClass)</tt>
     line into the C++ source.
   <li> Compile and link your interface class into the OMNEST simulation
     executable. IMPORTANT: make sure the executable actually contains
     the code of your class! Over-optimizing linkers (esp. on Unix)
     tend to leave out code to which there seem to be no external reference.
   <li> Add an entry to <tt>omnetpp.ini</tt> to tell Envir use your class
     instead of the default class. For RNGs, this setting is <tt>rng-class</tt>
     in the <tt>[General]</tt> section.
</ol>

<p>
<h2><a name="sec489"/>17.2 Plug-in Descriptions</h2>

<p>
<h3><a name="sec490"/>17.2.1 Defining a New Random Number Generator</h3>
<a name="sec:plugin-exts:rng"></a>

<p>The new RNG C++ class must implement the <tt><a href="../api/classcRNG.html">cRNG</a></tt> interface,
and can be activated with the <b><tt>rng-class</tt></b> configuration option.

<p>
<h3><a name="sec491"/>17.2.2 Defining a New Scheduler</h3>
<a name="sec:plugin-exts:scheduler"></a>

<p>The scheduler plug-in interface allows for implementing real-time,
hardware-in-the-loop, distributed and distributed parallel simulation.

The scheduler C++ class must implement the <tt><a href="../api/classcScheduler.html">cScheduler</a></tt> interface,
and can be activated with the <b><tt>scheduler-class</tt></b> configuration option.

<p>To see examples of scheduler classes, check the <tt><a href="../api/classcRealTimeScheduler.html">cRealTimeScheduler</a></tt>
class in the simulation kernel, and <tt>cSocketRTScheduler</tt> which is part
of the <i>Sockets</i> sample simulation.

<p>
<h3><a name="sec492"/>17.2.3 Defining a New Configuration Provider</h3>
<a name="sec:plugin-exts:configuration"></a>

<p><p class="subheading">Overview</p>

<p>The configuration provider plug-in lets you replace ini files
with some other storage implementation, for example a database.
The configuration provider C++ class must implement the
<tt><a href="../api/classcConfigurationEx.html">cConfigurationEx</a></tt> interface, and can be activated with
the <b><tt>configuration-class</tt></b> configuration option.

<p>The <tt><a href="../api/classcConfigurationEx.html">cConfigurationEx</a></tt> interface abstracts the inifile-based
data model to some degree. It assumes that the configuration data
consists of several <i>named configurations</i>. Before every
simulation run, one of the <i>named configurations</i> is
activated, and from then on, all queries into the configuration
operate on the <i>active named configuration</i> only.

<p>It practice, you will probably use the <tt>SectionBasedConfiguration</tt>
class (in <tt>src/envir</tt>) or subclass from it, because it already
implements a lot of functionality that you would otherwise have to.

<p><tt>SectionBasedConfiguration</tt> does not assume ini files or
any other particular storage format; instead, it accepts
an object that implements the <tt><a href="../api/classcConfigurationReader.html">cConfigurationReader</a></tt>
interface to provide the data in raw form to it.
The default implementation of <tt><a href="../api/classcConfigurationReader.html">cConfigurationReader</a></tt> is
<tt>InifileReader</tt>.

<p><p class="subheading">The Startup Sequence</p>

<p>From the configuration plug-in's point of view, the startup sequence
looks like the following (see <tt>src/envir/startup.cc</tt> in the source code):

<p><ol>
  <li> First, ini files specified on the command-line are read into a
     <i>boot-time configuration object</i>. The boot-time configuration
     is always a <tt>SectionBasedConfiguration</tt> with
     <tt>InifileReader</tt>.
  <li> Shared libraries are loaded (see the <tt>-l</tt> command-line option,
     and the <tt>load-libs</tt> configuration option). This allows
     configuration classes to come from shared libraries.
  <li> The <tt>configuration-class</tt> configuration option is examined.
     If it is present, a configuration object of the given class
     is instantiated, and replaces the boot-time configuration.
     The new configuration object is initialized from the boot-time
     configuration, so that it can read parameters (e.g. database
     connection parameters, XML file name, etc) from it.
     Then the boot-time configuration object is deallocated.
  <li> The <tt>load-libs</tt> option from the new configuration object is
     processed.
  <li> Then everything goes on as normally, using the new configuration
     object.
</ol>

<p><p class="subheading">Providing a Custom Configuration Class</p>

<p>To replace the configuration object with your custom implementation,
you would write the class:

<pre class="cpp">
#include "cconfiguration.h"

class CustomConfiguration : public <a href="../api/classcConfigurationEx.html">cConfigurationEx</a>
{
   ...
};

Register_Class(CustomConfiguration);
</pre>
<p>
and then activate it in the boot-time configuration:

<pre class="inifile">
[General]
configuration-class = CustomConfiguration
</pre>
<p>

<p><p class="subheading">Providing a Custom Reader for SectionBasedConfiguration</p>

<p>As said already, writing a configuration class from scratch can
be a lot of work, and it may be more practical to reuse
<tt>SectionBasedConfiguration</tt> with a different configuration
reader class. This can be done with <tt>sectionbasedconfig-configreader-class</tt>
config option, interpreted by <tt>SectionBasedConfiguration</tt>.
Specify the following in your boot-time ini file:

<pre class="inifile">
[General]
configuration-class = SectionBasedConfiguration
sectionbasedconfig-configreader-class = &lt;my new reader class&gt;
</pre>
<p>
The configuration reader class should look like this:

<pre class="cpp">
#include "cconfigreader.h"

class DatabaseConfigurationReader : public <a href="../api/classcConfigurationReader.html">cConfigurationReader</a>
{
   ...
};

Register_Class(DatabaseConfigurationReader);
</pre>
<p>

<p><h3><a name="sec493"/>17.2.4 Defining a New Output Scalar Manager</h3>
<a name="sec:plugin-exts:outputscalarmanager"></a>

<p><tt><a href="../api/classcOutputScalarManager.html">cOutputScalarManager</a></tt> handles recording the scalar output data.
The default output scalar manager is <tt>cFileOutputScalarManager</tt>,
defined in the Envir library.

<p>The new class can be activated with the <b><tt>outputscalarmanager-class</tt></b>
configuration option.

<p>
<h3><a name="sec494"/>17.2.5 Defining a New Output Vector Manager</h3>
<a name="sec:plugin-exts:outputvectormanager"></a>

<p><tt><a href="../api/classcOutputVectorManager.html">cOutputVectorManager</a></tt> handles recording the output from <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects.
The default output vector manager is <tt>cIndexedFileOutputVectorManager</tt>,
defined in the Envir library.

<p>The new class can be activated with the <b><tt>outputvectormanager-class</tt></b>
configuration option.

<p>
<h3><a name="sec495"/>17.2.6 Defining a New Snapshot Manager</h3>
<a name="sec:plugin-exts:snapshotmanager"></a>

<p><tt><a href="../api/classcSnapshotManager.html">cSnapshotManager</a></tt> provides an output stream to which snapshots are written
(see section <a href="#sec299">[7.10.5]</a>). The default snapshot manager
is <tt>cFileSnapshotManager</tt>, defined in the Envir library.

<p>The new class can be activated with the <b><tt>snapshotmanager-class</tt></b>
configuration option.

<p>
<h2><a name="sec496"/>17.3 Accessing the Configuration</h2>
<a name="sec:plugin-exts:accessing-config"></a>

<p><h3><a name="sec497"/>17.3.1 Defining New Configuration Options</h3>

<p>New configuration options need to be declared with one of the appropriate
registration macros. These macros are:

<pre class="cpp">
Register_GlobalConfigOption(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_PerRunConfigOption(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_GlobalConfigOptionU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
Register_PerRunConfigOptionU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
Register_PerObjectConfigOption(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_PerObjectConfigOptionU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
</pre>
<p>
Config options come in three flavors, as indicated by the macro names:

<p><ul>
  <li> <i>Global</i> options affect all configurations (i.e. they are
      only accepted in the <tt>[General]</tt> section but not in
      <tt>[Config &lt;name&gt;]</tt> sections)
  <li> <i>Per-Run</i> options can be specified in any section
      (i.e. both in <tt>[General]</tt> and in <tt>[Config &lt;name&gt;]</tt> sections).
      They are specific to a particular section. Their names always contain
      a hyphen (-) character.
  <li> <i>Per-Object</i> options can be specified in any section
      (i.e. both in <tt>[General]</tt> and in <tt>[Config &lt;name&gt;]</tt> sections).
      They are specific to an object or group of objects and their name must
      not contain a hypen (-) character.
</ul>

<p>The macro arguments are as follows:
<ul>
  <li> <i>ID</i> is a C++ identifier that will let you refer to
        the configuration option in <i><a href="../api/classcConfiguration.html">cConfiguration</a></i> member functions.
        (It is actually pointer to a <tt><a href="../api/classcConfigOption.html">cConfigOption</a></tt> object that
        the macro creates.)
  <li> <i>NAME</i> is the name of the option (a string).
  <li> <i>TYPE</i> is the data type of the option; it must be one of:
        <tt>CFG_BOOL</tt>, <tt>CFG_INT</tt>, <tt>CFG_DOUBLE</tt>, <tt>CFG_STRING</tt>,
        <tt>CFG_FILENAME</tt>, <tt>CFG_FILENAMES</tt>, <tt>CFG_PATH</tt>, <tt>CFG_CUSTOM</tt>.
        The most significant difference between filesystem-related types
        (filename, filenames, path) and plain strings is that relative
        filenames and paths are automatically converted to absolute
        when the configuration is read, with the base directory being the
        location of the ini file where the configuration entry was read from.
  <li> <i>UNIT</i> is a string that names the measurement unit in which
        the option's value is to be interpreted; it implies type <tt>CFG_DOUBLE</tt>.
  <li> <i>DEFAULTVALUE</i> is the default value in textual form (string);
        this should be <tt>NULL</tt> if the option has no default value.
  <li> <i>DESCRIPTION</i> is an arbitrarily long string that describes
        the purpose and and operation of the option. It will be used in
        help texts etc.
</ul>

<p>For example, the <tt>debug-on-errors</tt> option is declared in the following way:

<pre class="cpp">
Register_GlobalConfigOption(CFGID_DEBUG_ON_ERRORS,
                            "debug-on-errors", CFG_BOOL, "false",
                            "When enabled, runtime errors will etc etc...");
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
Registration is necessary because from the 4.0 version, OMNEST validates
the configuration on startup, in order to be able to report invalid or
mistyped option names and other errors.
</ul>

<p>
<h3><a name="sec498"/>17.3.2 Reading Values from the Configuration</h3>

<p>The configuration is accessible via the <tt>getConfig()</tt> method of <tt><a href="../api/classcEnvir.html">cEnvir</a></tt>.
It returns a pointer to the configuration object (<tt><a href="../api/classcConfiguration.html">cConfiguration</a></tt>):

<pre class="cpp">
<a href="../api/classcConfiguration.html">cConfiguration</a> *config = ev.getConfig();
</pre>
<p>
<tt><a href="../api/classcConfiguration.html">cConfiguration</a></tt> provides several methods for querying the configuration.

<p><ul class="note"><b>NOTE</b><br>
The configuration object provides a flattened view of the ini file. Sections
inheriting from each other are merged for you. Configuration options provided
on the command line in the form <tt>--option=value</tt> are added first to the object.
This ensures that the command line options take precedence over the values specified
in the INI file.
</ul>

<pre class="cpp">
const char *getAsCustom(<a href="../api/classcConfigOption.html">cConfigOption</a> *entry, const char *fallbackValue=NULL);
bool getAsBool(<a href="../api/classcConfigOption.html">cConfigOption</a> *entry, bool fallbackValue=false);
long getAsInt(<a href="../api/classcConfigOption.html">cConfigOption</a> *entry, long fallbackValue=0);
double getAsDouble(<a href="../api/classcConfigOption.html">cConfigOption</a> *entry, double fallbackValue=0);
std::string getAsString(<a href="../api/classcConfigOption.html">cConfigOption</a> *entry, const char *fallbackValue="");
std::string getAsFilename(<a href="../api/classcConfigOption.html">cConfigOption</a> *entry);
std::vector&lt;std::string&gt; getAsFilenames(<a href="../api/classcConfigOption.html">cConfigOption</a> *entry);
std::string getAsPath(<a href="../api/classcConfigOption.html">cConfigOption</a> *entry);
</pre>
<p>
<i>fallbackValue</i> is returned if the value is not specified in the configuration,
and there is no default value.

<pre class="cpp">
bool debug = ev.getConfig()-&gt;getAsBool(CFGID_PARSIM_DEBUG);
</pre>
<p>

<p><h2><a name="sec499"/>17.4 Implementing a New User Interface</h2>
<a name="sec:plugin-exts:userinterface"></a>

<p>It is possible to extend OMNEST with a new user interface. The new
user interface will have fully equal rights to Cmdenv and Tkenv; that is,
it can be activated by starting the simulation executable with the
<tt>-u</tt> <i>&lt;name&gt;</i> command-line or the <tt>user-interface</tt>
configuration option, it can be made the default user interface,
it can define new command-line options and configuration options,
and so on.

<p>User interfaces must implement (i.e. subclass from) <tt><a href="../api/classcRunnableEnvir.html">cRunnableEnvir</a></tt>,
and must be registered to OMNEST with the <tt>Register_OmnetApp()</tt> macro.
In practice, you will almost always want to subclass <tt>EnvirBase</tt>
instead of <tt><a href="../api/classcRunnableEnvir.html">cRunnableEnvir</a></tt>, because <tt>EnvirBase</tt> already
implements lots of functionality that otherwise you'd have to.

<p><ul class="note"><b>NOTE</b><br>
If you want something completely different from what <tt>EnvirBase</tt>
provides, such as embedding the simulation kernel into another
application, then you should be reading section <a href="#sec502">[18.2]</a>,
not this one.
</ul>

<p>An example user interface:

<pre class="cpp">
#include "envirbase.h"

class FooEnv : public EnvirBase
{
    ...
};

Register_OmnetApp("FooEnv", FooEnv, 30, "an experimental user interface");
</pre>
<p>
The <tt>envirbase.h</tt> header comes from the <tt>src/envir</tt> directory,
so it is necessary to add it to the include path (<tt>-I</tt>).

<p>The arguments to <tt>Register_OmnetApp()</tt> include the user interface name
(for use with the <tt>-u</tt> and <b><tt>user-interface</tt></b> options),
the C++ class that implements it, a weight for default user interface selection
(if <tt>-u</tt> is missing, the user interface with the largest weight will be
activated), and a description string (for help and other purposes).

<p>The C++ class should implement all methods left pure virtual in
<tt>EnvirBase</tt>, and possibly others if you want to customize
their behavior. One method that you will surely want to reimplement is
<tt>run()</tt> -- this is where your user interface runs. When this method
exits, the simulation program exits.

<p><ul class="note"><b>NOTE</b><br>
A good starting point for implementing your own user interface is
Cmdenv -- just copy and modify its source code to quickly get going.
</ul>

<p>

<hr class='pgbr'><h1><a name="sec500"/>18 Embedding the Simulation Kernel</h1>
<a name="cha:embedding"></a>

<p><h2><a name="sec501"/>18.1 Architecture</h2>

<p>OMNeT++ has a modular architecture. The following diagram illustrates  the
high-level architecture of the OMNeT++ simulations:

<p>
  <center>
    <img src="embed-architecture.png">
    <center><i>Figure: Architecture of OMNeT++ simulation programs</i></center>
  </center>

<p>
The rectangles in the picture represent the following components:

<p><ul>
  <li><b>Sim</b> is the simulation kernel and class
    library<!--simulation!kernel-->. Sim is a library linked to
    your simulation program.
  <li><b>Envir</b> is another library containing all the code
    that is common to all the user interfaces. <tt>main()</tt> also exists in the Envir library.
    Envir provides services, like ini file handling for specific user interface
    implementations. Envir presents itself towards Sim and the executing model
    via the <tt>ev</tt> facade object, hiding all other user interface internals.
    Some aspects of the Envir library can be customized<!--customization--> using plugin
    interfaces. Embedding OMNeT++ into applications<!--embedding--> can
    be achieved by implementing a new user interface in addition to Cmdenv
    and Tkenv, or by replacing Envir with another implementation of <tt>ev</tt>
    (see sections <a href="#sec499">[17.4]</a> and
    <a href="#sec502">[18.2]</a>.)
  <li><b>Cmdenv and Tkenv</b> are specific user interface
    implementations. The simulation is linked either to the  Cmdenv or Tkenv user interfaces, or to both.
  <li>The <b>Model Component Library</b> includes simple module definitions and
    their C++ implementations, compound module types, channels, networks,
    message types, and everything belonging to models that
    have been linked to the simulation program. A simulation program can
    run any model that contains all of the required linked components.
  <li>The <b>Executing Model</b> is the model that is set up
    for simulation. This model contains objects (modules, channels, and so on) that
    are all instances of the components in the model component library.
</ul>

<p>The arrows in the figure describe how components interact with
each other:

<p><ul>
  <li><b>Executing Model <i><==></i> Sim</b>. The simulation kernel
    manages the future events and activates modules in the executing model
    as events occur. The modules of the executing model are stored
    in the main object of Sim, <tt>simulation</tt> (of class <tt><a href="../api/classcSimulation.html">cSimulation</a></tt>).
    In turn, the executing model calls functions in the
    simulation kernel and uses classes in the Sim library.
  <li><b>Sim <i><==></i> Model Component Library</b>. The simulation kernel
    instantiates simple modules and other components when the simulation model
    is set up at the beginning of the simulation run. In addition, it refers
    to the component library when dynamic module creation is used.
    The mechanisms for registering and looking up components in the model
    component library are implemented as part of Sim.
  <li><b>Executing Model <i><==></i> Envir</b>. The <tt>ev</tt> object,
    logically part of Envir, is the facade of the user interface towards the
    executing model. The model uses <tt>ev</tt> to write debug logs (<tt>ev&lt;&lt;</tt>,
    <tt>ev.printf()</tt>).
  <li><b>Sim <i><==></i> Envir</b>. Envir is in full command of what
    happens in the simulation program. Envir contains the <tt>main()</tt> function
    where execution begins. Envir determines which models should be set up
    for simulation, and instructs Sim to do so. Envir contains the main
    simulation loop (<i>determine-next-event</i>, <i>execute-event</i>
    sequence) and invokes the simulation kernel for the necessary
    functionality (event scheduling and event execution are implemented in Sim).
    Envir catches and handles errors and exceptions that occur
    in the simulation kernel or in the library classes during execution.
    Envir presents a single facade object (<tt>ev</tt>) that represents
    the environment (user interface) toward Sim -- no Envir
    internals are visible to Sim or the executing model.
    During simulation model setup, Envir supplies parameter values for
    Sim when Sim asks for them. Sim writes output vectors via Envir,
    so one can redefine the output vector storing mechanism by changing Envir.
    Sim and its classes use Envir to print debug information.
  <li><b>Envir <i><==></i> Tkenv/Cmdenv</b>. Tkenv and Cmdenv
    are concrete user interface implementations. When a simulation program
    is started, the <tt>main()</tt> function (which is part of Envir) determines
    the appropriate user interface class, creates an instance and runs it
    by invoking its <tt>run()</tt> method. Sim's or the model's calls on the
    <tt>ev</tt> object are delegated to the user interface.
</ul>

<p>
<h2><a name="sec502"/>18.2 Embedding the OMNeT++ Simulation Kernel</h2>
<a name="sec:ch-embedding:embedding"></a>

<p>This section discusses the issues of embedding the simulation kernel
or a simulation model into a larger application. We assume that you
do not just want to change one or two aspects of the simulator
(such as , event scheduling or result recording) or create a new user interface
such as Cmdenv or Tkenv -- if so, see chapter <a href="#sec487">[17]</a>.

<p>For the following section, we assume that you will write the embedding
program from scratch. Meaning, starting from a <tt>main()</tt> function.

<p><h3><a name="sec503"/>18.2.1 The main() Function</h3>

<p>The minimalistic program described below initializes the simulation library
and runs two simulations. In later sections we will review the details
of the code and discuss how to improve it.

<pre class="cpp">
#include &lt;omnetpp.h&gt;

int main(int argc, char *argv[])
{
    // the following line MUST be at the top of main()
    cStaticFlag dummy;

    // initializations
    <a href="../api/classCodeFragments.html">CodeFragments</a>::executeAll(<a href="../api/classCodeFragments.html">CodeFragments</a>::STARTUP);
    <a href="../api/classSimTime.html">SimTime</a>::setScaleExp(-12);

    // load NED files
    <a href="../api/classcSimulation.html">cSimulation</a>::loadNedSourceFolder("./foodir");
    <a href="../api/classcSimulation.html">cSimulation</a>::loadNedSourceFolder("./bardir");
    <a href="../api/classcSimulation.html">cSimulation</a>::doneLoadingNedFiles();

    // run two simulations
    simulate("FooNetwork", 1000);
    simulate("BarNetwork", 2000);

    // deallocate registration lists, loaded NED files, etc.
    CodeFragment::executeAll(CodeFragment::SHUTDOWN);
    return 0;
}
</pre>
<p>
The first few lines of the code initialize the simulation library. The
purpose of <tt>cStaticFlag</tt> is to set a global variable to <tt>true</tt>
for the duration of the <tt>main()</tt> function, to help the simulation
library handle exceptions correctly in extreme cases.
<tt>CodeFragment::executeAll(CodeFragment::STARTUP)</tt> performs various startup 
tasks, such as building registration tables out of the <tt>Define_Module()</tt>,
<tt>Register_Class()</tt> and similar entries throughout the code.
<tt><a href="../api/classSimTime.html">SimTime</a>::setScaleExp(-12)</tt> sets the simulation time resolution to
picoseconds; other values can be used as well, but it is mandatory to
choose one.

<p><ul class="note"><b>NOTE</b><br>
The simulation time exponent cannot be changed at a later stage, since it is
a global variable, and the values of the existing <tt>simtime_t</tt> instances
would change.
</ul>

<p>The code then loads the NED files from the <tt>foodir</tt> and
<tt>bardir</tt> subdirectories of the working directory (as if the NED path
was <tt>./foodir;./bardir</tt>), and runs two simulations.

<p>
<h3><a name="sec504"/>18.2.2 The simulate() Function</h3>

<p>A minimalistic version of the <tt>simulate()</tt> function is shown below.
In order to shorten the code, the exception handling code has been ommited (<tt>try</tt>/<tt>catch</tt> blocks)
apart from the event loop. However, every line is marked with &#8220;<tt>E!</tt>&#8221; where various
problems with the simulation model can occur and can be thrown as exceptions.

<pre class="cpp">
void simulate(const char *networkName, simtime_t limit)
{
    // look up network type
    <a href="../api/classcModuleType.html">cModuleType</a> *networkType = <a href="../api/classcModuleType.html">cModuleType</a>::find(networkName);
    if (networkType == NULL) {
        printf("No such network: %s\n", networkName);
        return;
    }

    // create a simulation manager and an environment for the simulation
    <a href="../api/classcEnvir.html">cEnvir</a> *env = new CustomSimulationEnv(argc, argv, new EmptyConfig());
    <a href="../api/classcSimulation.html">cSimulation</a> *sim = new <a href="../api/classcSimulation.html">cSimulation</a>("simulation", env);
    <a href="../api/classcSimulation.html">cSimulation</a>::setActiveSimulation(sim);

    // set up network and prepare for running it
    sim-&gt;setupNetwork(networkType); //E!
    sim-&gt;startRun(); //E!

    // run the simulation
    bool ok = true;
    try {
        while (sim-&gt;getSimTime() &lt; limit) {
            <a href="../api/classcSimpleModule.html">cSimpleModule</a> *mod = sim-&gt;selectNextModule(); //E!
            if (!mod)
                break;
            sim-&gt;doOneEvent(mod);  //E!
        }
        printf("Finished: time limit reached\n");
    }
    catch (<a href="../api/classcTerminationException.html">cTerminationException</a>& e) {
        printf("Finished: %s\n", e.what());
    }
    catch (std::exception& e) {
        ok = false;
        printf("ERROR: %s\n", e.what());
    }

    if (ok)
        simulation.callFinish();  //E!

    // finish the simulation and clean up the network
    sim-&gt;endRun();  //E!
    sim-&gt;deleteNetwork();  //E!

    <a href="../api/classcSimulation.html">cSimulation</a>::setActiveSimulation(NULL);
    delete sim; // deletes env as well
}
</pre>
<p>
The function accepts a network type name (which must be fully qualified
with a package name) and a simulation time limit.

<p>In the first few lines the system looks up the network name among the modules that
have been loaded from the  NED files, and an error message is printed if it is not found.

<p>Then it is required to create and activate a simulation manager object
(<tt><a href="../api/classcSimulation.html">cSimulation</a></tt>).
The simulation manager requires another object, called the environment object. This environment object is used by the simulation manager
to read the configuration. In addition, the results produced by the simulation manager are written to this environment object.

<p>The environment object (<tt>CustomSimulationEnv</tt> in the above code) must
be provided by the programmer; this is described in detail in a later section.

<p><ul class="note"><b>NOTE</b><br>
Before version 4.0, <tt>simulation</tt> and <tt>ev</tt> were global variables;
In the current version they are macros that refer to  <tt>*<a href="../api/classcSimulation.html">cSimulation</a>::getActiveSimulation()</tt>
and <tt>*<a href="../api/classcSimulation.html">cSimulation</a>::getActiveSimulation()-&gt;getEnvir()</tt>.
</ul>

<p>The network is then set up in the simulation manager. The
<tt>sim-&gt;</tt><tt>setupNetwork()</tt> method creates the system module and
recursively all modules and their interconnections; module parameters are
also read from the configuration (where required) and assigned. If there is
an error (for example, module type not found), an exception will be thrown. The
exception object is some kind of <tt>std::exception</tt>, usually a
<tt><a href="../api/classcRuntimeError.html">cRuntimeError</a></tt>.

<p>If the network setup was successful, the <tt>sim-&gt;</tt><tt>startRun()</tt> function is called,
and the <tt>initialize()</tt> methods of modules
and channels are then activated. An exception is thrown if
something goes wrong in any of the <tt>initialize()</tt> methods.

<p>The following lines run the simulation by calling
<tt>sim-&gt;</tt><tt>selectNextModule()</tt> and <tt>sim-&gt;</tt><tt>doOneEvent()</tt>
in an event loop, until the simulation time limit is reached or an
exception occurs. Exceptions that are subclassed from <tt><a href="../api/classcTerminationException.html">cTerminationException</a></tt>
signify the normal termination of the simulation process; other exceptions indicate
various errors.

<p>If the simulation has completed successfully (<tt>ok==true</tt>), the code
goes on to call the <tt>finish()</tt> methods of modules and channels. Then,
regardless of whether there was an error, <tt>sim-&gt;</tt><tt>endRun()</tt> is
called, and the network is shut down using
<tt>sim-&gt;</tt><tt>deleteNetwork()</tt>.

<p>Finally, the simulation manager object is deallocated, but the active
simulation manager is not allowed to be deleted; therefore it is deactivated
using <tt>setActiveSimulation(NULL)</tt>.

<p>
<h3><a name="sec505"/>18.2.3 Providing an Environment Object</h3>

<p>The environment object needs to be subclassed from the <tt><a href="../api/classcEnvir.html">cEnvir</a></tt> class,
but since it has many pure virtual methods, it is easier
to begin by subclassing <tt><a href="../api/classcNullEnvir.html">cNullEnvir</a></tt>. <tt><a href="../api/classcNullEnvir.html">cNullEnvir</a></tt> defines all
pure virtual methods with either an empty body or with a body that throws
an <tt>"unsupported method called"</tt> exception. You can redefine methods
to be more sophisticated later on, as you progress with the development.

<p>You must redefine the <tt>readParameter()</tt> method. This enables
module parameters to obtain their values. For debugging purposes, you can also
redefine <tt>sputn()</tt> where module log messages are written to.
<tt><a href="../api/classcNullEnvir.html">cNullEnvir</a></tt> only provides one random number generator, so if your
simulation model uses more than one, you also need to redefine the
<tt>getNumRNGs()</tt> and <tt>getRNG(k)</tt> methods. To print or store
simulation records, redefine <tt>recordScalar()</tt>, <tt>recordStatistic()</tt>
and/or the output vector related methods. Other <tt><a href="../api/classcEnvir.html">cEnvir</a></tt> methods
are invoked from the simulation kernel to inform the environment about
messages being sent, events scheduled and cancelled, modules created, and so on.

<p>The following example shows a minimalistic environment class that is enough
to get started:

<pre class="cpp">
class CustomSimulationEnv : public <a href="../api/classcNullEnvir.html">cNullEnvir</a>
{
  public:
    // constructor
    CustomSimulationEnv(int ac, char **av, <a href="../api/classcConfiguration.html">cConfiguration</a> *c) :
        <a href="../api/classcNullEnvir.html">cNullEnvir</a>(ac, av, c) {}

    // model parameters: accept defaults
    virtual void readParameter(<a href="../api/classcPar.html">cPar</a> *par) {
        if (par-&gt;containsValue())
            par-&gt;acceptDefault();
        else
            throw <a href="../api/classcRuntimeError.html">cRuntimeError</a>("no value for %s", par-&gt;getFullPath().c_str());
    }

    // send module log messages to stdout
    virtual void sputn(const char *s, int n) {
        (void) ::fwrite(s,1,n,stdout);
    }
};
</pre>
<p>

<p><h3><a name="sec506"/>18.2.4 Providing a Configuration Object</h3>

<p>The configuration object needs to subclass from <tt><a href="../api/classcConfiguration.html">cConfiguration</a></tt>.
<tt><a href="../api/classcConfiguration.html">cConfiguration</a></tt> also has several methods, but the typed ones
(<tt>getAsBool()</tt>, <tt>getAsInt()</tt>, etc.) have default implementations
that delegate to the much fewer string-based methods (<tt>getConfigValue()</tt>, etc.).

<p>It is fairly straightforward to implement a configuration class that
emulates an empty ini file:

<pre class="cpp">
class EmptyConfig : public <a href="../api/classcConfiguration.html">cConfiguration</a>
{
  protected:
    class NullKeyValue : public KeyValue {
      public:
        virtual const char *getKey() const {return NULL;}
        virtual const char *getValue() const {return NULL;}
        virtual const char *getBaseDirectory() const {return NULL;}
    };
    NullKeyValue nullKeyValue;

  protected:
    virtual const char *substituteVariables(const char *value) {return value;}

  public:
    virtual const char *getConfigValue(const char *key) const
        {return NULL;}
    virtual const KeyValue& getConfigEntry(const char *key) const
        {return nullKeyValue;}
    virtual const char *getPerObjectConfigValue(const char *objectFullPath,
        const char *keySuffix) const {return NULL;}
    virtual const KeyValue& getPerObjectConfigEntry(const char *objectFullPath,
        const char *keySuffix) const {return nullKeyValue;}
};
</pre>
<p>

<p><h3><a name="sec507"/>18.2.5 Loading NED Files</h3>

<p>NED files can be loaded with any of the following static methods of
<tt><a href="../api/classcSimulation.html">cSimulation</a></tt>: <tt>loadNedSourceFolder()</tt>, <tt>loadNedFile()</tt>,
and <tt>loadNedText()</tt>. The first method loads an entire subdirectory tree,
the second method loads a single NED file, and the third method takes a literal
string containing NED code and parses it.

<p><ul class="note"><b>NOTE</b><br>
One use of <tt>loadNedText()</tt> is to parse NED sources previously converted
to C++ string constants and linked into the executable. This enables
creating executables that are self-contained, and do not require NED files
to be distributed with them.
</ul>

<p>The above functions can also be mixed, but after the last call,
<tt>doneLoadingNedFiles()</tt> must be invoked (it checks for unresolved
NED types).

<p>Loading NED files has a global effect; therefore they cannot be unloaded.

<p>
<h3><a name="sec508"/>18.2.6 How to Eliminate NED Files</h3>

<p>It is possible to get rid of NED files altogether. This would also
remove the dependency on the <tt>oppnedxml</tt> library and the code in
<tt>sim/netbuilder</tt>, although at the cost of additional coding.

<p><ul class="note"><b>NOTE</b><br>
When the only purpose is to get rid of NED files as external dependency
of the program, it is simpler to use <tt>loadNedText()</tt> on NED files
converted to C++ string constants instead.
</ul>

<p>The trick is to write <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> and <tt><a href="../api/classcChannelType.html">cChannelType</a></tt> objects
for your simple module, compound module and channel types, and register them
manually. For example, <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> has pure virtual methods called
<tt>createModuleObject()</tt>, <tt>addParametersAndGatesTo(module)</tt>,
<tt>setupGateVectors(module)</tt>, <tt>buildInside(module)</tt>, which you
need to implement. The body of the <tt>buildInside()</tt> method would
be similar to C++ files generated by <tt>nedtool</tt> of OMNeT++ 3.x.

<p>
<h3><a name="sec509"/>18.2.7 Assigning Module Parameters</h3>

<p>As already mentioned, modules obtain values for their input parameters
by calling the <tt>readParameter()</tt> method of the environment object
(<tt><a href="../api/classcEnvir.html">cEnvir</a></tt>).

<p><ul class="note"><b>NOTE</b><br>
<tt>readParameter()</tt> is only called for parameters that have not
been set to a fixed (i.e. non-<tt>default</tt>) value in the NED files.
</ul>

<p>The <tt>readParameter()</tt> method should be written in a manner that enables it to assign
the parameter. When doing so, it can recognize the parameter from its name
(<tt>par-&gt;getName()</tt>), from its full path (<tt>par-&gt;getFullPath()</tt>),
from the owner module's class (<tt>par-&gt;getOwner()-&gt;getClassName()</tt>)
or NED type name (<tt>((<a href="../api/classcComponent.html">cComponent</a> *)par-&gt;getOwner())-&gt;getNedTypeName()</tt>).
Then it can set the parameter using one of the typed setter methods
(<tt>setBoolValue()</tt>, <tt>setLongValue()</tt>, etc.), or set it
to an expression provided in string form (<tt>parse()</tt> method).
It can also accept the default value if it exists (<tt>acceptDefault()</tt>).

<p>The following code is a straightforward example that answers parameter
value requests from a pre-filled table.

<pre class="cpp">
class CustomSimulationEnv : public <a href="../api/classcNullEnvir.html">cNullEnvir</a>
{
  protected:
    // parameter (fullpath,value) pairs, needs to be pre-filled
    std::map&lt;std::string,std::string&gt; paramValues;
  public:
    ...
    virtual void readParameter(<a href="../api/classcPar.html">cPar</a> *par) {
        if (paramValues.find(par-&gt;getFullPath())!=paramValues.end())
            par-&gt;parse(paramValues[par-&gt;getFullPath()]);
        else if (par-&gt;containsValue())
            par-&gt;acceptDefault();
        else
            throw <a href="../api/classcRuntimeError.html">cRuntimeError</a>("no value for %s", par-&gt;getFullPath().c_str());
    }
};
</pre>
<p>

<p><h3><a name="sec510"/>18.2.8 Extracting Statistics from the Model</h3>

<p>There are several ways you can extract statistics from the
simulation.

<p><p class="subheading">C++ Calls into the Model</p>

<p>Modules in the simulation are C++ objects. If you add the appropriate
public getter methods to the module classes, you can call them from your
main program to obtain statistics. Modules may be looked up with the
<tt>getModuleByPath()</tt> method of <tt><a href="../api/classcSimulation.html">cSimulation</a></tt>, then cast to the
specific module type via <tt>check_and_cast&lt;&gt;()</tt> so that the getter
methods can be invoked.

<pre class="cpp">
<a href="../api/classcModule.html">cModule</a> *mod = simulation.getModuleByPath("Network.client[2].app");
WebApp *appMod = check_and_cast&lt;WebApp *&gt;(mod);
int numRequestsSent = appMod-&gt;getNumRequestsSent();
double avgReplyTime = appMod-&gt;getAvgReplyTime();
...
</pre>
<p>
The drawback of this approach is that getters need to be added manually
to all affected module classes, which might not be practical, especially
if modules come from external projects.

<p><p class="subheading"><tt><a href="../api/classcEnvir.html">cEnvir</a></tt> Callbacks</p>

<p>A more general way is to catch <tt>recordScalar()</tt> method calls in the
simulation model. The <tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>recordScalar()</tt> method
delegates to the similar function in <tt><a href="../api/classcEnvir.html">cEnvir</a></tt>. You may define the
latter function so that it stores all recorded scalars (for example in an
<tt>std::map</tt>), where the main program can find them later.
Values from output vectors can be captured in a similar manner.

<p>An example implementation:

<pre class="cpp">
class CustomSimulationEnv : public <a href="../api/classcNullEnvir.html">cNullEnvir</a>
{
  private:
    std::map&lt;std::string, double&gt; results;
  public:
    virtual void recordScalar(<a href="../api/classcComponent.html">cComponent</a> *component, const char *name,
                              double value, <a href="../api/classopp__string__map.html">opp_string_map</a> *attributes=NULL)
    {
       results[component-&gt;getFullPath()+"."+name] = value;
    }

    const std::map&lt;std::string, double&gt;& getResults() {return results;}
};

...

const std::map&lt;std::string, double&gt;& results = env-&gt;getResults();
int numRequestsSent = results["Network.client[2].app.numRequestsSent"];
double avgReplyTime = results["Network.client[2].app.avgReplyTime"];
</pre>
<p>
A drawback of this approach is that compile-time checking of statistics names is lost, but
the advantages are that any simulation model can now be used
without changes, and that capturing additional statistics does not require
code modification in the main program.

<p>
<h3><a name="sec511"/>18.2.9 The Simulation Loop</h3>

<p>To run the simulation, the <tt>selectNextModule()</tt> and <tt>doOneEvent</tt>
methods of <tt><a href="../api/classcSimulation.html">cSimulation</a></tt> must be called in a loop:

<pre class="cpp">
while (sim-&gt;getSimTime() &lt; limit)
{
    <a href="../api/classcSimpleModule.html">cSimpleModule</a> *mod = sim-&gt;selectNextModule();
    sim-&gt;doOneEvent(mod);
}
</pre>
<p>
Depending on the concrete scheduler class, the
<tt>selectNextModule()</tt> may return <tt>NULL</tt>. The default
<tt><a href="../api/classcSequentialScheduler.html">cSequentialScheduler</a></tt> never returns <tt>NULL</tt>.

<p>The execution may terminate in various ways. Runtime errors cause a
<tt><a href="../api/classcRuntimeError.html">cRuntimeError</a></tt> (or other kind of <tt>std::exception</tt>) to be
thrown. <tt><a href="../api/classcTerminationException.html">cTerminationException</a></tt> is thrown on normal termination
conditions, such as when the simulation runs out of events to process.

<p>You may customize the loop to exit on other termination conditions as well,
such as on a simulation time limit (see above), on a CPU time limit, or when
results reach a required accuracy. It is relatively straightforward to
build in progress reporting and interactivity (start/stop).

<p>Animation can be hooked up to the appropriate callback methods of
<tt><a href="../api/classcEnvir.html">cEnvir</a></tt>: <tt>beginSend()</tt>, <tt>sendHop()</tt>, <tt>endSend()</tt>,
and others.

<p>
<h3><a name="sec512"/>18.2.10 Multiple, Coexisting Simulations</h3>

<p>It is possible for several instances of <tt><a href="../api/classcSimulation.html">cSimulation</a></tt> to coexist,
and also to set up and simulate a network in each instance. However, this
requires frequent use of <tt><a href="../api/classcSimulation.html">cSimulation</a>::setActiveSimulation()</tt>.
Before invoking any <tt><a href="../api/classcSimulation.html">cSimulation</a></tt> method or module method,
the corresponding <tt><a href="../api/classcSimulation.html">cSimulation</a></tt> instance needs to be designated
as the active simulation manager. This is necessary because several models
and simulation kernel methods refer to the active simulation manager
instance via the <tt>simulation</tt> macro, and it is similar with the
<tt>ev</tt> macro.

<p><ul class="note"><b>NOTE</b><br>
Before the 4.0 version, <tt>simulation</tt> and <tt>ev</tt> were global variables;
in the current version they are macros that refer to <tt>*<a href="../api/classcSimulation.html">cSimulation</a>::getActiveSimulation()</tt>
and <tt>*<a href="../api/classcSimulation.html">cSimulation</a>::getActiveSimulation()-&gt;getEnvir()</tt>.
</ul>

<p>Every <tt><a href="../api/classcSimulation.html">cSimulation</a></tt> instance should have its own associated
environment object (<tt><a href="../api/classcEnvir.html">cEnvir</a></tt>). Environment objects may not be
shared among several <tt><a href="../api/classcSimulation.html">cSimulation</a></tt> instances. The
<tt><a href="../api/classcSimulation.html">cSimulation</a></tt>'s destructor also removes the associated
<tt><a href="../api/classcEnvir.html">cEnvir</a></tt> instance.

<p><tt><a href="../api/classcSimulation.html">cSimulation</a></tt> instances may be reused from one simulation to another,
but it is also possible to create a new instance for each simulation run.

<p><ul class="note"><b>NOTE</b><br>
It is not possible to run different simulations concurrently from
different theads, due to the use of global variables which are not easy
to eliminate, such as the active simulation manager pointer and the active
environment object pointer. Static buffers and objects (like string pools)
are also used for efficiency reasons in some places inside the simulation
kernel.
</ul>

<p>
<h3><a name="sec513"/>18.2.11 Installing a Custom Scheduler</h3>

<p>The default event scheduler is <tt><a href="../api/classcSequentialScheduler.html">cSequentialScheduler</a></tt>. To replace
it with a different scheduler (e.g. <tt><a href="../api/classcRealTimeScheduler.html">cRealTimeScheduler</a></tt> or your
own scheduler class), add a <tt>setScheduler()</tt> call into <tt>main()</tt>:

<pre class="cpp">
<a href="../api/classcScheduler.html">cScheduler</a> *scheduler = new CustomScheduler();
simulation.setScheduler(scheduler);
</pre>
<p>
It is usually not a good idea to change schedulers in the middle of
a simulation, therefore  <tt>setScheduler()</tt> may only be called when
no network is set up.

<p>
<h3><a name="sec514"/>18.2.12 Multi-Threaded Programs</h3>

<p>The OMNeT++ simulation kernel is not reentrant; therefore it must be protected
against concurrent access.

<p>
% </pre>
% </pre>
% </pre>
% </pre>


<hr class='pgbr'><h1><a name="sec515"/>19 Appendix&#58; NED Reference</h1>
<a name="cha:ned-ref"></a>

<p><h2><a name="sec516"/>19.1 Syntax</h2>

<p><h3><a name="sec517"/>19.1.1 NED File Name Extension</h3>

<p>NED files have the <tt>.ned</tt> file name suffix. This is mandatory, and
cannot be overridden.

<p><h3><a name="sec518"/>19.1.2 NED File Encoding</h3>

<p>NED files are ASCII, but non-ASCII characters are permitted in comments
and string literals. This allows for using encodings that are a superset
of ASCII, for example ISO 8859-1 and UTF-8.

<p><ul class="note"><b>NOTE</b><br>
    There is no standard way to specify or determine the encoding of a NED file.
    It is up to the user to configure the desired encoding in text editors
    and other tools that edit or process NED files.
</ul>

<p>String literals (e.g. in parameter values) will be passed to the C++ code
as <tt>const char *</tt> without any conversion; it is up to the simulation model
to interpret them using the desired encoding.

<p>Line ending may be either CR or CRLF, regardless of the platform.

<p>
<h3><a name="sec519"/>19.1.3 Reserved Words</h3>

<p>NED file authors have to take care that no reserved words are used as identifiers.
The reserved words of the NED language are:

<p><tt>allowunconnected bool channel channelinterface connections const
default double extends false for gates if import index inout input int like
module moduleinterface network output package parameters property simple
sizeof string submodules this true typename types volatile xml xmldoc</tt>

<p>
<h3><a name="sec520"/>19.1.4 Identifiers</h3>

<p>Identifiers must be composed of letters of the English alphabet (a-z, A-Z),
numbers (0-9) and underscore &#8220;_&#8221;. Identifiers may only begin with a
letter or underscore.

<p>The recommended way to compose identifiers from multiple words is to
capitalize the beginning of each word (<i>camel case</i>).

<p>
<h3><a name="sec521"/>19.1.5 Case Sensitivity</h3>

<p>Keywords and identifiers in the NED language are case sensitive. For example,
<tt>TCP</tt> and <tt>Tcp</tt> are two different names.

<p>
<h3><a name="sec522"/>19.1.6 Literals</h3>
<a name="ch-ned-ref:sec:literals"></a>

<p><p class="subheading">String Literals</p>

<p>String literals use double quotes. The following C-style backslash escapes
are recognized: <tt>\b</tt>, <tt>\f</tt>,
<tt>\n</tt>, <tt>\r</tt>, <tt>\t</tt>,
<tt>\\</tt>, <tt>\"</tt>, and
<tt>\xhh</tt> where <i>h</i> is a hexadecimal digit.

<p><p class="subheading">Numeric Constants</p>

<p>Numeric constants are accepted in the usual decimal, hexadecimal (<tt>0x</tt> prefix)
and scientific notations. Octal numbers are not accepted (numbers that start
with the <tt>0</tt> digit are interpreted as decimal.)

<p><p class="subheading">Quantity Constants</p>

<p>A quantity constant has the form <i>(&lt;numeric-constant&gt; &lt;unit&gt;)+</i>, for
example <tt>12.5mW</tt> or <tt>3h 15min 37.2s</tt>. Whitespace is optional in front
of a unit, but must be present after a unit if it is followed by a number.

<p>When multiple measurement units are present, they have to be convertible
into each other (i.e. refer to the same physical quantity).

<p>Section <a href="#sec558">[19.5.6]</a> lists the units recognized by OMNeT++.
Other units can be used as well; the only downside being that OMNeT++ will
not be able to perform conversions on them.

<p>
<h3><a name="sec523"/>19.1.7 Comments</h3>

<p>Comments can be placed at the end of lines. Comments begin with a double
slash <tt>//</tt>, and continue until the end of the line.

<p>
<h3><a name="sec524"/>19.1.8 Grammar</h3>

<p>The grammar of the NED language can be found in Appendix
<a href="#sec559">[20]</a>.

<p><h2><a name="sec525"/>19.2 Built-in Definitions</h2>
<a name="ch-ned-ref:sec:built-in-defs"></a>

<p>The NED language has the following built-in definitions, all in the <tt>ned</tt>
package: channels <tt>IdealChannel</tt>, <tt>DelayChannel</tt>, and <tt>DatarateChannel</tt>;
module interfaces <tt>IBidirectionalChannel</tt>, and <tt>IUnidirectionalChannel</tt>.
The latter two are reserved for future use.

<p>The bodies of <tt>@statistic</tt> properties have been omitted for brevity from
the following listing.

<p><ul class="note"><b>NOTE</b><br>
You can print the full definitions by running <tt>opp_run -h neddecls</tt>.
</ul>

<pre class="ned">
package ned;
@namespace("");

channel IdealChannel
{
    @class(<a href="../api/classcIdealChannel.html">cIdealChannel</a>);
}

channel DelayChannel
{
    @class(<a href="../api/classcDelayChannel.html">cDelayChannel</a>);
    @signal[messageSent](type=<a href="../api/classcMessage.html">cMessage</a>);
    @signal[messageDiscarded](type=<a href="../api/classcMessage.html">cMessage</a>);
    @statistic[messages](...);
    @statistic[messagesDiscarded](...);
    bool disabled = default(false);
    double delay = default(0s) @unit(s); // propagation delay
}

channel DatarateChannel
{
    @class(<a href="../api/classcDatarateChannel.html">cDatarateChannel</a>);
    @signal[channelBusy](type=long);
    @signal[messageSent](type=<a href="../api/classcMessage.html">cMessage</a>);
    @signal[messageDiscarded](type=<a href="../api/classcMessage.html">cMessage</a>);
    @statistic[busy](...);
    @statistic[utilization](...);
    @statistic[packets](...);
    @statistic[packetBytes](...);
    @statistic[packetsDiscarded](...);
    @statistic[throughput](...);
    bool disabled = default(false);
    double delay = default(0s) @unit(s); // propagation delay
    double datarate = default(0bps) @unit(bps); // bits per second; 0=infinite
    double ber = default(0); // bit error rate (BER)
    double per = default(0); // packet error rate (PER)
}

moduleinterface IBidirectionalChannel
{
    gates:
        inout a;
        inout b;
}

moduleinterface IUnidirectionalChannel
{
    gates:
        input i;
        output o;
}
</pre>
<p>

<p>
<h2><a name="sec526"/>19.3 Packages</h2>
<a name="ch-ned-ref:sec:packages"></a>

<p>NED supports hierarchical namespaces called <i>packages</i>. The model
is similar to Java packages, with minor changes.

<p>
<h3><a name="sec527"/>19.3.1 Package Declaration</h3>

<p>A NED file may contain a package declaration. The package declaration
uses the <b><tt>package</tt></b> keyword, and specifies the package for the
definitions in the NED file. If there is no package declaration, the file's
contents are in the <i>default package</i>.

<p>Component type names must be unique within their package.

<p>
<h3><a name="sec528"/>19.3.2 Directory Structure, package.ned</h3>

<p>Like in Java, the directory of a NED file must match the package
declaration. However, it is possible to omit directories at the top which do
not contain any NED files (like the typical <tt>/org/<i>&lt;projectname&gt;</i></tt>
directories in Java).

<p>The top of a directory tree containing NED files is named a <i>NED source
folder</i>.

<p><ul class="note"><b>NOTE</b><br>
The OMNeT++ runtime recognizes a <tt>NEDPATH</tt> environment variable, which
contains a list of NED source folders, and is similar to the Java <tt>CLASSPATH</tt>
variable. <tt>NEDPATH</tt> also has a command-line option equivalent.
</ul>

<p>The <tt>package.ned</tt> file at the top level of a NED source folder plays a
special role.

<p>If there is no toplevel <tt>package.ned</tt> or it contains no package declaration,
the declared package of a NED file in the folder <tt><i>&lt;srcfolder&gt;</i>/x/y/z</tt>
<i>must</i> be <tt>x.y.z</tt>.
If there is a toplevel <tt>package.ned</tt> and it declares the package as
<tt>a.b</tt>, then any NED file in the folder <tt><i>&lt;srcfolder&gt;</i>/x/y/z</tt>
<i>must</i> have the declared package <tt>a.b.x.y.z</tt>.

<p><ul class="note"><b>NOTE</b><br>
    <tt>package.ned</tt> files are allowed in other folders as well.
    They may contain properties and/or documentation for their package,
    but cannot be used to define the package they are in.
</ul>

<p>

<p>
<h2><a name="sec529"/>19.4 Components</h2>

<p>Simple modules, compound modules, networks, channels, module interfaces
and channel interfaces are called <i>components</i>.

<p>
<h3><a name="sec530"/>19.4.1 Simple Modules</h3>
<a name="ch-ned-ref:sec:simple-modules"></a>

<p>Simple module types are declared with the <b><tt>simple</tt></b> keyword;
see the NED Grammar (Appendix <a href="#sec559">[20]</a>) for the
syntax.

<p>Simple modules may have properties (<a href="#sec537">[19.4.8]</a>),
parameters (<a href="#sec538">[19.4.9]</a>)
and gates (<a href="#sec540">[19.4.11]</a>).

<p>A simple module type may not have inner types (<a href="#sec544">[19.4.15]</a>).

<p>A simple module type may extend another simple module type, and
may implement one or more module interfaces (<a href="#sec534">[19.4.5]</a>).
Inheritance rules are described in section <a href="#sec550">[19.4.21]</a>,
and interface implementation rules in section <a href="#sec549">[19.4.20]</a>.

<p>Every simple module type has an associated C++ class, which must be
subclassed from <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>. The way of associating the
NED type with the C++ class is described in section
<a href="#sec536">[19.4.7]</a>.

<p>

<p><h3><a name="sec531"/>19.4.2 Compound Modules</h3>
<a name="ch-ned-ref:sec:compound-modules"></a>

<p>Compound module types are declared with the <b><tt>module</tt></b> keyword;
see the NED Grammar (Appendix <a href="#sec559">[20]</a>) for the
syntax.

<p>A compound module may have properties (<a href="#sec537">[19.4.8]</a>),
parameters (<a href="#sec538">[19.4.9]</a>),
and gates (<a href="#sec540">[19.4.11]</a>); its internal structure is defined by
its submodules (<a href="#sec541">[19.4.12]</a>) and
connections (<a href="#sec542">[19.4.13]</a>);
and it may also have inner types (<a href="#sec544">[19.4.15]</a>)
that can be used for its submodules and connections.

<p>A compound module type may extend another compound module type, and
may implement one or more module interfaces (<a href="#sec534">[19.4.5]</a>).
Inheritance rules are described in section <a href="#sec550">[19.4.21]</a>,
and interface implementation rules in section <a href="#sec549">[19.4.20]</a>.

<p>

<p><h3><a name="sec532"/>19.4.3 Networks</h3>
<a name="ch-ned-ref:sec:networks"></a>

<p><p class="subheading">The network Keyword</p>

<p>A network declared with the <b><tt>network</tt></b> keyword is equivalent to a compound
module (<b><tt>module</tt></b> keyword) with the <b><tt>@isNetwork(true)</tt></b> property.

<p><ul class="note"><b>NOTE</b><br>
    A simple module can only be designated to be a network by spelling out the
    <b><tt>@isNetwork</tt></b> property; the <b><tt>network</tt></b> keyword cannot
    be used for that purpose.
</ul>

<p><p class="subheading">The @isNetwork Property</p>

<p>The <b><tt>@isNetwork</tt></b> property is only recognized for simple modules and
compound modules. The value may be empty, true or false:

<pre class="ned">
@isNetwork;
@isNetwork();
@isNetwork(true);
@isNetwork(false);
</pre>
<p>
The empty value corresponds to <b><tt>@isNetwork(true)</tt></b>.

<p>The <b><tt>@isNetwork</tt></b> property is not inherited; that is, a subclass
of a module with <b><tt>@isNetwork</tt></b> set does not automatically become a network.
The <b><tt>@isNetwork</tt></b> property needs to be explicitly added to the subclass
to make it a network.

<p><ul class="rationale"><b>Rationale</b><br>
    Subclassing may introduce changes to a module that make it unfit to be used
    as a network.
</ul>

<p>

<p><h3><a name="sec533"/>19.4.4 Channels</h3>
<a name="ch-ned-ref:sec:channels"></a>

<p>Channel types are declared with the <b><tt>channel</tt></b> keyword;
see the NED Grammar (Appendix <a href="#sec559">[20]</a>) for the
syntax.

<p>Channel types may have properties (<a href="#sec537">[19.4.8]</a>)
and parameters (<a href="#sec538">[19.4.9]</a>).

<p>A channel type may not have inner types (<a href="#sec544">[19.4.15]</a>).

<p>A channel type may extend another channel type, and
may implement one or more channel interfaces (<a href="#sec535">[19.4.6]</a>).
Inheritance rules are described in section <a href="#sec550">[19.4.21]</a>,
and interface implementation rules in section <a href="#sec549">[19.4.20]</a>.

<p>Every channel type has an associated C++ class, which must be
subclassed from <tt><a href="../api/classcChannel.html">cChannel</a></tt>. The way of associating the
NED type with the C++ class is described in section
<a href="#sec536">[19.4.7]</a>.

<p>The <tt>@defaultname</tt> property of a channel type determines the default name
of the channel object when used in a connection.

<p>
<h3><a name="sec534"/>19.4.5 Module Interfaces</h3>
<a name="ch-ned-ref:sec:module-interfaces"></a>

<p>Module interface types are declared with the <b><tt>moduleinterface</tt></b> keyword;
see the NED Grammar (Appendix <a href="#sec559">[20]</a>) for the
syntax.

<p>Module interfaces may have properties (<a href="#sec537">[19.4.8]</a>),
parameters (<a href="#sec538">[19.4.9]</a>), and
gates (<a href="#sec540">[19.4.11]</a>). However, parameters are not allowed
to have a value assigned, not even a default value.

<p>A module interface type may not have inner types (<a href="#sec544">[19.4.15]</a>).

<p>A module interface type may extend one or more other module interface types.
Inheritance rules are described in section <a href="#sec550">[19.4.21]</a>.

<p>

<p><h3><a name="sec535"/>19.4.6 Channel Interfaces</h3>
<a name="ch-ned-ref:sec:channel-interfaces"></a>

<p>Channel interface types are declared with the <b><tt>channelinterface</tt></b> keyword;
see the NED Grammar (Appendix <a href="#sec559">[20]</a>) for the
syntax.

<p>Channel interfaces may have properties (<a href="#sec537">[19.4.8]</a>) and
parameters (<a href="#sec538">[19.4.9]</a>). However, parameters are not
allowed to have a value assigned, not even a default value.

<p>A channel interface type may not have inner types (<a href="#sec544">[19.4.15]</a>).

<p>A channel interface type may extend one or more other channel interface types.
Inheritance rules are described in section <a href="#sec550">[19.4.21]</a>.

<p>

<p><h3><a name="sec536"/>19.4.7 Resolving the C++ Implementation Class</h3>
<a name="ch-ned-ref:sec:resolving-cpp-class"></a>

<p>The procedure for determining the C++ implementation class for simple modules
and for channels are identical. It goes as follows (we are going to say
<i>component</i> instead of <i>&#8220;simple module or channel&#8221;</i>):

<p>If the component extends another component and has no <b><tt>@class</tt></b>
property, the C++ implementation class is inherited from the base type.

<p>If the component contains a <b><tt>@class</tt></b> property, the C++ class name
will be composed of the <i>current namespace</i> (see below) and the
value of the <b><tt>@class</tt></b> property. The <b><tt>@class</tt></b> property should
contain a single value.

<p><ul class="note"><b>NOTE</b><br>
    The <b><tt>@class</tt></b> property may itself contain a namespace declaration (ie.
    may contain &#8220;<tt>::</tt>&#8221;).
</ul>

<p>If the component contains no <b><tt>@class</tt></b> property and has no base
class, the C++ class name will be composed of the <i>current namespace</i> and the
unqualified name of the component.

<p><ul class="important"><b>IMPORTANT</b><br>
    NED subclassing does not imply subclassing the C++ implementation! If you
    want to subclass a simple module or channel in NED as well as in C++, you
    explicitly need to specify the <b><tt>@class</tt></b> property, otherwise the
    derived simple module or channel will continue to use the C++ class from its
    super type.
</ul>

<p>Compound modules will be instantiated with the built-in <tt><a href="../api/classcModule.html">cModule</a></tt> class,
unless the module contains the <b><tt>@class</tt></b> property. When <b><tt>@class</tt></b> is present,
the resolution rules are the same as with simple modules.

<p>
<p class="subheading">Current Namespace</p>
<a name="ch:ned-ref:current-namespace"></a>

<p>The <i>current namespace</i> is the value of the first <b><tt>@namespace</tt></b>
property found while searching the following order:

<p><ol>
  <li> the current NED file
  <li> the <tt>package.ned</tt> file in the current package or the first ancestor
        package searching upwards
</ol>

<p><ul class="note"><b>NOTE</b><br>
    Note that namespaces coming from multiple <b><tt>@namespace</tt></b> properties
    in different scopes do not nest, but rather, the nearest one wins.
</ul>

<p>The <b><tt>@namespace</tt></b> property should contain a single value.

<p>

<p><h3><a name="sec537"/>19.4.8 Properties</h3>
<a name="ch-ned-ref:sec:properties"></a>

<p>Properties are a means of adding metadata annotations to NED files, component types,
parameters, gates, submodules, and connections.

<p><p class="subheading">Identifying a Property</p>

<p>Properties are identified by name. It is possible to have several properties
on the same object with the same name, as long as they have unique indices.
An index is an identifier in square brackets after the property name.

<p>The following example shows a property without index, one with the index <tt>index1</tt>,
and a third with the index <tt>index2</tt>.

<pre class="ned">
@prop1();
@prop2[index1]();
@prop3[index2]();
</pre>
<p>

<p><p class="subheading">Property Value</p>

<p>The value of the property is specified inside parentheses. The property value consists of
<i>key=valuelist</i> pairs, separated by semicolons; <i>valuelist</i> elements
are separated with commas. Example:

<pre class="ned">
@prop(key1=value11,value12,value13;key2=value21,value22)
</pre>
<p>
Keys must be unique.

<p>If the key+equal sign part (<tt>key=</tt>) is missing, the valuelist belongs
to the <i>default key</i>. Examples:

<pre class="ned">
@prop1(value1,value2)
@prop2(value1,value2;key1=value11,value12,value13)
</pre>
<p>
Most of the properties use the default key with one value. Examples:

<pre class="ned">
@namespace(inet);
@class(Foo);
@unit(s);
</pre>
<p>
Property values have a liberal syntax (see Appendix <a href="#sec559">[20]</a>).
Values that do not fit the grammar (notably, those containing a comma or
a semicolon) need to be surrounded with double quotes.

<p>When interpreting a property value, one layer of quotes is removed
automatically, that is, <tt>foo</tt> and <tt>"foo"</tt> are the same.
Within quotes, escaping works in the same way as within string literals
(see <a href="#sec522">[19.1.6]</a>).

<p>Example:

<pre class="ned">
@prop(marks=the ! mark, "the , mark", "the ; mark", other marks); // 4 items
</pre>
<p>

<p><p class="subheading">Placement</p>

<p>Properties may be added to NED files, component types, parameters,
gates, submodules and connections. For the exact syntax, see
Appendix <a href="#sec559">[20]</a>.

<p>When a component type extends another component type(s), properties
are merged. This is described in section <a href="#sec550">[19.4.21]</a>.

<p>
<p class="subheading">Property Declarations</p>

<p>The <b><tt>property</tt></b> keyword is reserved for future use. It is
envisioned that accepted property names and property keys would need
to be pre-declared, so that the NED infrastructure can warn the user
about mistyped or unrecognized names.

<p>
<h3><a name="sec538"/>19.4.9 Parameters</h3>
<a name="ch-ned-ref:sec:parameters"></a>

<p>Parameters can be defined and assigned in the <b><tt>parameters</tt></b> section
of component types. In addition, parameters can also be assigned in the
<b><tt>parameters</tt></b> sections of submodule bodies and connection bodies,
but those places do not allow adding new parameters.

<p>The <b><tt>parameters</tt></b> keyword is optional, and can be omitted
without change in the meaning.

<p>The <b><tt>parameters</tt></b> section may also hold pattern assignments
(<a href="#sec539">[19.4.10]</a>) and properties
(<a href="#sec537">[19.4.8]</a>).

<p>A parameter is identified by a name, and has a data type. A parameter
may have value or default value, and may also have properties
(see <a href="#sec537">[19.4.8]</a>).

<p>Accepted parameter data types are <b><tt>double</tt></b>, <b><tt>int</tt></b>,
<b><tt>string</tt></b>, <b><tt>bool</tt></b>, and <b><tt>xml</tt></b>. Any
of the above types can be declared <b><tt>volatile</tt></b> as well
(<tt>volatile int</tt>, <tt>volatile string</tt>, etc.)

<p>The presence of a data type keyword determines whether the given line defines
a new parameter or refers to an existing parameter. One can assign a value or
default value to an existing parameter, and/or modify its properties or add
new properties.

<p>Examples:

<pre class="ned">
int a;           // defines new parameter
int b @foo;      // new parameter with property
int c = default(5); // new parameter with default value
int d = 5;       // new parameter with value assigned
int e @foo = 5;  // new parameter with property and value
f = 10;          // assignment to existing (e.g.inherited) parameter
g = default(10); // overrides default value of existing parameter
h;               // legal, but does nothing
i @foo(1);       // adds a property to existing parameter
j @foo(1) = 10;  // adds a property and value to existing parameter
</pre>
<p>
Parameter values are NED expressions. Expressions are described in section
<a href="#sec552">[19.5]</a>.

<p>For <b><tt>volatile</tt></b> parameters, the value expression is evaluated every
time the parameter value is accessed. Non-<b><tt>volatile</tt></b> parameters
are evaluated only once.

<p><ul class="note"><b>NOTE</b><br>
    The <b><tt>const</tt></b> keyword is reserved for future use within expressions
    to define constant subexpressions, i.e. to denote a part within
    an expression that should only be evaluated once. Constant subexpressions
    are not supported yet.
</ul>

<p>The following properties are recognized for parameters: <b><tt>@unit</tt></b>,
<b><tt>@prompt</tt></b>.

<p>
<p class="subheading">The @prompt Property</p>

<p>The <b><tt>@prompt</tt></b> property defines a prompt string for the parameter. The
prompt string is used when/if a simulation runtime user interface
interactively prompts the user for the parameter's value.

<p>The <b><tt>@prompt</tt></b> property is expected to contain one string value for the
default key.

<p>
<p class="subheading">The @unit Property</p>

<p>A parameter may have a <b><tt>@unit</tt></b> property to associate it with a measurement
unit. The <b><tt>@unit</tt></b> property should contain one string value for the default
key. Examples:

<pre class="ned">
@unit(s)
@unit(second)
</pre>
<p>
When present, values assigned to the parameter must be in the
same or in a compatible (that is, convertible) unit.
Examples:

<pre class="ned">
  double a @unit(s) = 5s;   // OK
  double a @unit(s) = 10ms; // OK; will be converted to seconds
  double a @unit(s) = 5;    // error: should be 5s
  double a @unit(s) = 5kg;  // error: incompatible unit
</pre>
<p>
<b><tt>@unit</tt></b> behavior for non-numeric parameters (boolean, string, XML)
is unspecified (may be ignored or may be an error).

<p>The <b><tt>@unit</tt></b> property of a parameter may not be modified via inheritance.

<p>Example:
<pre class="ned">
simple A {
    double p @unit(s);
}
simple B extends A {
    p @unit(mW);  // illegal: cannot override @unit
}
</pre>

<p>

<p><h3><a name="sec539"/>19.4.10 Pattern Assignments</h3>
<a name="ch-ned-ref:sec:pattern-assignments"></a>

<p>Pattern assignments allow one to set more than one parameter using
wildcards, and to assign parameters deeper down in a submodule tree.
Pattern assignments may occur in the <b><tt>parameters</tt></b>
section of component types, submodules and connections.

<p>The syntax of a pattern assignment is <i>&lt;pattern&gt; = &lt;value&gt;</i>.

<p>A pattern consists of two or more pattern elements, separated by dots.
The pattern element syntax is defined so that it can accomodate names of
parameters, submodules (optionally with index), gates (optionally with the
<tt>$i</tt>/<tt>$o</tt> suffix and/or index) and connections, and their
wildcard forms. (The default name of connection channel objects is
<b><tt>channel</tt></b>.)

<p>Wildcard forms may use:
<ol>
  <li> Asterisks: They match zero or more characters except dots.
  <li> Numeric ranges, <tt>{</tt><i>&lt;start&gt;</i>..<i>&lt;end&gt;</i><tt>}</tt>
    e.g. <tt>{5..120}</tt> or <tt>{..10}</tt>. They match numbers embedded
    in identifiers, that is, a sequence of decimal digit characters interpreted as a
    nonnegative integer that is within the specified <i>start..end</i>
    range (both limits are inclusive). Both <i>start</i> and <i>end</i>
    are optional.
  <li> Numeric index ranges,<tt>[</tt><i>&lt;start&gt;</i>..<i>&lt;end&gt;</i><tt>]</tt>.
    e.g. <tt>[5..120]</tt> or <tt>[..10]</tt>. They are intended for selecting
    submodule and gate index ranges. They match a nonnegative integer
    enclosed in square brackets that is within the specified
    <i>start..end</i> range (both limits are inclusive).
    Both <i>start</i> and <i>end</i> are optional.
  <li> Double asterisks: They match zero or more characters (including dots),
    and can be used to match more than one parameter path elements.
</ol>

<p>See the NED language grammar (Appendix <a href="#sec559">[20]</a>)
for a more formal definition of the pattern syntax.

<p>Examples:
<pre class="ned">
host1.tcp.mss = 512B;
host*.tcp.mss = 512B; // matches host, host1, host2, hostileHost, ...
host{9..11}.tcp.mss = 512B; // matches host9/host10/host11, but nothing else
host[9..11].tcp.mss = 512B; // matches host[9]/host[10]/host[11], but nothing else
**.mss = 512B; // matches foo.mss, host[1].transport.tcp[0].mss, ...
</pre>

<p>

<p><h3><a name="sec540"/>19.4.11 Gates</h3>
<a name="ch-ned-ref:sec:gates"></a>

<p>Gates can be defined in the <b><tt>gates</tt></b> section of component types.
The size of a gate vector (see below) may be specified at the place of
defining the gate, via inheritance in a derived type, and also in the
<b><tt>gates</tt></b> block of a submodule body. A submodule body does not allow
defining new gates.

<p>A gate is identified by a name, and is characterized by a type
(<b><tt>input</tt></b>, <b><tt>output</tt></b>, <b><tt>inout</tt></b>) and optionally a
vector size. Gates may also have properties (see
<a href="#sec537">[19.4.8]</a>).

<p>Gates may be scalar or vector. The vector size is specified with a numeric
expression inside square brackets. The vector size may also be left
unspecified by writing an empty pair of square brackets.

<p>An already specified gate vector size may not be overridden in subclasses or
in a submodule.

<p>The presence of a gate type keyword determines whether the given line defines
a new gate or refers to an existing gate. One can specify the gate vector
size for an existing gate vector, and/or modify its properties, or add new
properties.

<p>Examples:

<pre class="ned">
gates:
  input a;         // defines new gate
  input b @foo;    // new gate with property
  input c[];       // new gate vector with unspecified size
  input d[8];      // new gate vector with size=8
  e[10];           // set gate size for existing (e.g.inherited) gate vector
  f @foo(bar);     // add property to existing gate
  g[10] @foo(bar); // set gate size and add property to existing gate
</pre>
<p>
Gate vector sizes are NED expressions. Expressions are described in section
<a href="#sec552">[19.5]</a>.

<p>See the Connections section (<a href="#sec542">[19.4.13]</a>) for more
information on gates.

<p><p class="subheading">Recognized Gate Properties</p>

<p>The following properties are recognized for gates: <b><tt>@directIn</tt></b>
and <b><tt>@loose</tt></b>. They have the same effect: When either of them is
present on a gate, the gate is not required to be connected in the
connections section of a compound module (see <a href="#sec542">[19.4.13]</a>).

<p><b><tt>@directIn</tt></b> should be used when the gate is an <b><tt>input</tt></b> gate that is
intended for being used as a target for the <tt>sendDirect()</tt> method;
<b><tt>@loose</tt></b> should be used in any other case when the gate is not
required to be connected for some reason.

<p><ul class="note"><b>NOTE</b><br>
    The reason <b><tt>@directIn</tt></b> gates are not <i>required</i> to remain
    unconnected is that it is often useful to wrap such modules in a compound
    module, where the compound module also has a <b><tt>@directIn</tt></b> input gate
    that is internally connected to the submodule's corresponding gate.
</ul>

<p>Example:

<pre class="ned">
gates:
    input radioIn @directIn;
</pre>
<p>

<p>
<h3><a name="sec541"/>19.4.12 Submodules</h3>
<a name="ch-ned-ref:sec:submodules"></a>

<p>Submodules are defined in the <b><tt>submodules</tt></b> section of the compound
module.

<p>The type of the submodule may be specified statically or parametrically.

<p>Submodules may be scalar or vector. The size of submodule vectors must be
specified as a numeric expression inside square brackets.

<p>Submodules may also be conditional.

<p>A submodule definition may or may not have a body (a curly brace
delimited block). An empty submodule body is equivalent to a
missing one.

<p>Syntax examples:
<pre class="ned">
submodules:
    ip : IP;         // scalar submodule without body
    tcp : TCP {}     // scalar submodule with empty body
    app[10] : App;   // submodule vector
</pre>

<p>
<p class="subheading">Submodule Type</p>

<p>The simple or compound module type (<a href="#sec530">[19.4.1]</a>,
<a href="#sec531">[19.4.2]</a>) that will be instantiated as the
submodule may be specified either statically (with a concrete module type
name) or parametrically.

<p>
<p class="subheading">Static Submodule Type</p>

<p>Submodules with a statically defined type are those that contain a concrete
NED module type name. Example:

<pre class="ned">
tcp : TCP;
</pre>
<p>
See section <a href="#sec547">[19.4.18]</a> for the type resolution
rules.

<p>
<p class="subheading">Parametric Submodule Type</p>

<p>Parametric submodule type means that the NED type name is given in a string
expression. The string expression may be specified locally in the submodule
declaration, or elsewhere using typename patterns (see later).

<p>Parametric submodule types are syntactically denoted by the presence of a
pair of angle brackets and the <b><tt>like</tt></b> keyword. The angle brackets
contain the string expression; or if the type is not specified locally,
they may be empty or may contain a default value for the type name
(<tt>default(...)</tt> syntax). The syntax mandates that you also specify a
module interface type <a href="#sec534">[19.4.5]</a> (after the
<b><tt>like</tt></b> keyword), which the concrete module type must implement in
order for it to be eligible to be chosen.

<p>Examples:

<pre class="ned">
tcp : &lt;tcpType&gt; like ITCP;        // type comes from parent module parameter
tcp : &lt;"TCP_"+suffix&gt; like ITCP;  // expression using parent module parameter

tcp : &lt;&gt; like ITCP;               // type must be specified elsewhere

tcp : &lt;default("TCP")&gt; like ITCP; // type may be specified elsewhere;
                                  // if not, the default is "TCP"
tcp : &lt;default("TCP_"+suffix)&gt; like ITCP;
                                  // type may be specified elsewhere;
                                  // if not, the default is an expression
</pre>
<p>
See the NED Grammar (Appendix <a href="#sec559">[20]</a>) for the
formal syntax, and section <a href="#sec548">[19.4.19]</a>
for the type resolution rules.

<p>
<p class="subheading">Conditional Submodules</p>

<p>Submodules may be made conditional using the <b><tt>if</tt></b> keyword. The
condition expression must evaluate to a boolean; if the result is
<tt>false</tt>, the submodule is not created, and trying to connect its gates
or reference its parameters will be an error.

<p>An example:

<pre class="ned">
submodules:
  tcp : TCP if withTCP { ... }
</pre>
<p>

<p><p class="subheading">Parameters, Gates</p>

<p>A submodule body may contain parameters (<a href="#sec538">[19.4.9]</a>)
and gates (<a href="#sec534">[19.4.5]</a>).

<p>A submodule body cannot define new parameters or gates. It is only
allowed to assign existing parameters, and to set the vector
size of existing gate vectors.

<p>It is also allowed to add or modify submodule properties and
parameter/gate properties.

<p>

<p><h3><a name="sec542"/>19.4.13 Connections</h3>
<a name="ch-ned-ref:sec:connections"></a>

<p>Connections are defined in the <b><tt>connections</tt></b> section of the compound module.

<p>Connections may not span multiple hierarchy levels, that is, a connection
may be created between two submodules, a submodule and the compound module,
or between two gates of the compound module.

<p>Normally, all gates must be connected, including submodule gates and the gates
of the compound module. When the <b><tt>allowunconnected</tt></b> modifier is present
after <b><tt>connections</tt></b>, gates will be allowed to be left unconnected.

<p><ul class="note"><b>NOTE</b><br>
    The <b><tt>@directIn</tt></b> and <b><tt>@loose</tt></b> gate properties are alternatives to the
    <tt>connections allowunconnected</tt> syntax; see <a href="#sec540">[19.4.11]</a>.
</ul>

<p>Connections may be conditional, and may be created using loops (see
<a href="#sec543">[19.4.14]</a>).

<p>
<p class="subheading">Connection Syntax</p>

<p>The connection syntax uses arrows (<tt>--&gt;</tt>, <tt>&lt;--</tt>) to connect
<b><tt>input</tt></b> and <b><tt>output</tt></b> gates, and double arrows
(<tt>&lt;--&gt;</tt>) to connect <b><tt>inout</tt></b> gates. The latter is
also said to be a bidirectional connection.

<p>Arrows point from the source gate (a submodule output gate or a compound
module input gate) to the destination gate (a submodule input gate or a
compound module output gate). Connections may be written either left to right
or right to left, that is, <tt>a--&gt;b</tt> is equivalent to <tt>b&lt;--a</tt>.

<p>Gates are specified as <i>&lt;modulespec&gt;.&lt;gatespec&gt;</i> (to connect a submodule),
or as <i>&lt;gatespec&gt;</i> (to connect the compound module). <i>&lt;modulespec&gt;</i>
is either a submodule name (for scalar submodules), or a submodule name plus
an index in square brackets (for submodule vectors). For scalar gates,
<i>&lt;gatespec&gt;</i> is the gate name; for gate vectors it is either
the gate name plus a numeric index expression in square brackets,
or <i>&lt;gatename&gt;</i><tt>++</tt>.

<p>The <i>&lt;gatename&gt;</i><tt>++</tt> notation causes the first unconnected gate index
to be used. If all gates of the given gate vector are connected, the behavior
is different for submodules and for the enclosing compound module.
For submodules, the gate vector expands by one. For the compound module,
it is an error to use <tt>++</tt> on a gate vector with no unconnected gates.

<p>Syntax examples:

<pre class="ned">
connections:
   a.out --&gt; b.in;   // unidirectional between two submodules
   c.in[2] &lt;-- in;   // parent-to-child; gate vector with index
   d.g++ &lt;--&gt; e.g++; // bidirectional, auto-expanding gate vectors
</pre>
<p>
<ul class="rationale"><b>Rationale</b><br>
    The reason it is not supported to expand the gate vector of the compound
    module is that the module structure is built in top-down order: new gates
    would be left unconnected on the outside, as there is no way in NED to
    "go back" and connect them afterwards.
</ul>

<p>When the <tt>++</tt> operator is used with <tt>$i</tt> or <tt>$o</tt>
(e.g. <tt>g$i++</tt> or <tt>g$o++</tt>, see later), it will actually add
a gate pair (input+output) to maintain equal gate size for the two
directions.

<p>The syntax to associate a channel (see <a href="#sec533">[19.4.4]</a>)
with the connection is to use two arrows with a channel specification
in between (see later). The same syntax is used to add properties such as
<b><tt>@display</tt></b> to the connection.

<p>


<p><p class="subheading">Inout Gates</p>

<p>An inout gate is represented as a gate pair: an input gate and an output gate.
The two sub-gates may also be referenced and connected individually, by adding
the <tt>$i</tt> and <tt>$o</tt> suffix to the name of the inout gate.

<p>A bidirectional connection (which uses a double arrow to connect two inout gates),
is also a shorthand for two uni-directional connections; that is,

<pre class="ned">
a.g &lt;--&gt; b.g;
</pre>
<p>
is equivalent to
<pre class="ned">
a.g<i>o --&gt; b.g</i>i;
a.g<i>i &lt;-- b.g</i>o;
</pre>

<p>In inout gate vectors, gates are always in pairs, that is,
<tt>sizeof(g$i)==sizeof(g$o)</tt> always holds. It is maintained even
when <tt>g$i++</tt> or <tt>g$o++</tt> is used: the <tt>++</tt> operator will
add a gate pair, not just an input or an output gate.

<p>
<p class="subheading">Specifying Channels</p>

<p>A channel specification associates a channel object with the connection.
A channel object is an instance of a channel type (see <a href="#sec533">[19.4.4]</a>).

<p><ul class="note"><b>NOTE</b><br>
As bidirectional connections are a shorthand for a pair of uni-directional
connections, they will actually create <i>two</i> channel objects, one
for each direction.
</ul>

<p>The channel type to be instantiated may be implicit, or may be specified
statically or parametrically.

<p>A connection may have a body (a curly brace delimited block) for setting
properties and/or parameters of the channel.

<p>A connection syntax allows one to specify a name for the channel object.
When not specified, the channel name will be taken from the <tt>@defaultname</tt>
property of the channel type; when there is no such property, it will be
<tt>"channel"</tt>. Custom connection names can be useful for easier addressing of
channel objects when assigning parameters using patterns.

<p>See subsequent sections for details.

<p>
<p class="subheading">Implicit Channel Type</p>

<p>If the connection syntax does not say anything about the channel type, it
is implicitly determined from the set of connection parameters used.

<p>Syntax examples for connections with implicit channel types:

<pre class="ned">
a.g &lt;--&gt; b.g; // no parameters
a.g &lt;--&gt; {delay = 1ms;} &lt;--&gt; b.g;  // assigns delay
a.g &lt;--&gt; {datarate = 100Mbps; delay = 50ns;} &lt;--&gt; b.g; // assigns delay and datarate
</pre>
<p>
For such connections, the actual NED type to be used will depend on the
parameters set in the connection:

<p><ol>
  <li> When no parameters are set, <tt>ned.IdealChannel</tt> is chosen.
  <li> When only <tt>ned.DelayChannel</tt> parameters are used (<tt>delay</tt>
        and <tt>disabled</tt>), <tt>ned.DelayChannel</tt> is chosen.
  <li> When only <tt>ned.DatarateChannel</tt> parameters are used
        (<tt>datarate</tt>, <tt>delay</tt>, <tt>ber</tt>, <tt>per</tt>, <tt>disabled</tt>),
        the chosen channel type will be <tt>ned.DatarateChannel</tt>.
</ol>

<p>Connections with implicit channel types may not use any other parameter.

<p><p class="subheading">Static Channel Type</p>

<p>Connections with a statically defined channel type are those that
contain a concrete NED channel type name.

<p>Examples:

<pre class="ned">
a.g &lt;--&gt; FastEthernet &lt;--&gt; b.g;
a.g &lt;--&gt; FastEthernet {per = 1e-6;} &lt;--&gt; b.g;
</pre>
<p>
See section <a href="#sec547">[19.4.18]</a> for the type resolution
rules.

<p>
<p class="subheading">Parametric Channel Type</p>

<p>Parametric channel types are similar to parametric submodule types,
described in section <a href="#sec541">[19.4.12]</a>.

<p>Parametric channel type means that the NED type name is given in a string
expression. The string expression may be specified locally in the connection
declaration, or elsewhere using typename patterns (see later).

<p>Parametric channel types are syntactically denoted by the presence of a
pair of angle brackets and the <b><tt>like</tt></b> keyword. The angle brackets
contain the string expression; or if the type is not specified locally,
they may be empty or may contain a default value for the type name
(<tt>default(...)</tt> syntax). The syntax mandates that you also specify a
channel interface type <a href="#sec534">[19.4.5]</a> (after the
<b><tt>like</tt></b> keyword), which the concrete channel type must implement in
order for it to be eligible to be chosen.

<p>Examples:

<pre class="ned">
a.g++ &lt;--&gt; &lt;channelType&gt; like IMyChannel &lt;--&gt; b.g++;
                                  // type comes from parent module parameter
a.g++ &lt;--&gt; &lt;"Ch_"+suffix&gt; like IMyChannel &lt;--&gt; b.g++;
                                  // expression using parent module parameter
a.g++ &lt;--&gt; &lt;&gt; like IMyChannel &lt;--&gt; b.g++;
                                  // type must be specified elsewhere
a.g++ &lt;--&gt; &lt;default("MyChannel")&gt; like IMyChannel &lt;--&gt; b.g++;
                                  // type may be specified elsewhere;
                                  // if not, the default is "MyChannel"
a.g++ &lt;--&gt; &lt;default("Ch_"+suffix)&gt; like IMyChannel &lt;--&gt; b.g++;
                                  // type may be specified elsewhere;
                                  // if not, the default is an expression
</pre>
<p>
See the NED Grammar (Appendix <a href="#sec559">[20]</a>) for the
formal syntax, and section <a href="#sec548">[19.4.19]</a>
for the type resolution rules.

<p>
<p class="subheading">Channel Parameters and Properties</p>

<p>A channel definition may or may not have a body (a curly brace
delimited block). An empty channel body (<tt>{ }</tt>) is equivalent
to a missing one.

<p>A channel body may contain parameters (<a href="#sec538">[19.4.9]</a>).

<p>A channel body cannot define new parameters. It is only
allowed to assign existing parameters.

<p>It is also allowed to add or modify properties and parameter properties.

<p>
<h3><a name="sec543"/>19.4.14 Conditional and Loop Connections, Connection Groups</h3>
<a name="ch-ned-ref:sec:connection-groups"></a>

<p>The connections section may contain any number of connections and
connection groups. A connection group is one or more connections
grouped with curly braces.

<p>Both connections and connection groups may be conditional (<b><tt>if</tt></b>
keyword) or may be multiple (<b><tt>for</tt></b> keyword).

<p>Any number of <b><tt>for</tt></b> and <b><tt>if</tt></b> clauses may be added to
a connection or connection loop; they are interpreted as if they were
nested in the given order. Loop variables of a <b><tt>for</tt></b> may be
referenced from subsequent conditions and loops as well as in module and
gate index expressions in the connections.

<p>See the NED Grammar (<a href="#sec559">[20]</a>) for the exact syntax.

<p>Example connections:

<pre class="ned">
a.out --&gt; b.in;
c.out --&gt; d.in if p&gt;0;
e.out[i] --&gt; f[i].in for i=0..sizeof(f)-1, if i%2==0;
</pre>
<p>
Example connection groups:

<pre class="ned">
if p&gt;0 {
    a.out --&gt; b.in;
    a.in &lt;-- b.out;
}
for i=0..sizeof(c)-1, if i%2==0 {
    c[i].out --&gt; out[i];
    c[i].in &lt;-- in[i];
}
for i=0..sizeof(d)-1, for j=0..sizeof(d)-1, if i!=j {
    d[i].out[j] --&gt; d[j].in[i];
}
for i=0..sizeof(e)-1, for j=0..sizeof(e)-1 {
    e[i].out[j] --&gt; e[j].in[i] if i!=j;
}
</pre>
<p>

<p>
<h3><a name="sec544"/>19.4.15 Inner Types</h3>
<a name="ch-ned-ref:sec:inner-types"></a>

<p>Inner types can be defined in the <b><tt>types</tt></b> section of compound
modules, with the same syntax as toplevel (i.e. non-inner) types.

<p>Inner types may not contain further inner types, that is, type nesting
is limited to two levels.

<p>Inner types are only visible inside the enclosing component type
and its subclasses.

<p>

<p><h3><a name="sec545"/>19.4.16 Name Uniqueness</h3>

<p>Identifier names within a component must be unique. That is, the following
items in a component are considered to be in the same name space and must
not have colliding names:

<p><ul>
  <li> parameters
  <li> gates
  <li> submodules
  <li> inner types
  <li> the above items of super type(s)
</ul>

<p>For example, a gate and a submodule cannot have the same name.

<p>
<h3><a name="sec546"/>19.4.17 Parameter Assignment Order</h3>
<a name="ch-ned-ref:sec:param-assignment-order"></a>

<p>A module or channel parameter may be assigned in <b><tt>parameters</tt></b>
blocks (see <a href="#sec538">[19.4.9]</a>) at various places in NED: in
the module or channel type that defines it; in the type's subclasses; in
the submodule or connection that instantiates the type. The parameter may
also be assigned using pattern assignments (see
<a href="#sec539">[19.4.10]</a>) in any compound module that uses
the given module or channel type directly or indirectly.

<p>Patterns are matched against the relative path of the parameter, which is
the relative path of its submodule or connection, with a dot and the
parameter name appended. The relative path is composed of a list of
submodule names (name plus index) separated by dots; a connection is
identified by the full name of its source gate plus the name of the channel
object (which is currently always <tt>channel</tt>) separated by a dot.

<p><ul class="note"><b>NOTE</b><br>
As bidirectional connections are a shorthand for two unidirectional
connections, the source gate name is qualified with <tt>$i</tt> or
<tt>$o</tt> in the relative path.
</ul>

<p>Note that the <b><tt>parameters</tt></b> keyword itself is optional,
and is usually not written out in submodules and connections.

<p>This section describes the module and channel parameter assignments procedure.

<p>The general rules are the following:

<p><ol>
  <li> A (non-default) parameter assignment may not be overridden later;
    that is, if there are assignments in multiple places, the assignment
    &#8220;closest&#8221; to the parameter declaration will be effective; others
    will be flagged as errors.
  <li> A default value is only used if a non-default value is not present
    for the given parameter. A non-default value may also come from a source
    external to NED, namely the simulation configuration (<tt>omnetpp.ini</tt>).
  <li> Unlike non-default values, a default value <i>may</i> be overridden;
    that is, if there are default value assignments in multiple places,
    the assignment &#8220;farthest&#8221; from the parameter declaration will win.
  <li> Among pattern assignments within the same <b><tt>parameters</tt></b>
    block, the first match will win. Pattern assignments with default and
    non-default values are considered to be two disjoint sets, only one of
    which are searched at a time.
</ol>

<p>This yields the following conceptual search order for non-default parameter
assignments:

<p><ol>
  <li> First, the NED type that contains the parameter declaration is checked;
  <li> Then its subclasses are checked;
  <li> Then the submodule or connection that instantiates the type is checked;
  <li> Then the compound module that contains the submodule or connection is
    checked for matching pattern assignments;
  <li> Then, assuming the compound module is part of a network, the search
    for matching pattern assignments continues up on the module tree until the root
    (the module that represents the network). At each level (compound module),
    first the specific submodule definition is checked, then the (parent) compound module.
    If a compound module is subclassed before instantiated, the base type is checked
    first.
</ol>

<p>When no (non-default) assignment is found, the same places are searched in the
<i>reverse order</i> for default value assignments. If no default value is
found, an error may be raised or the user may be interactively prompted.

<p>To illustrate the above rules, consider the following example where we
want to assign parameter <i>p</i>:

<pre class="ned">
simple A { double p; }
simple A2 extends A {...}
module B { submodules: a2: A2 {...} }
module B2 extends B {...}
network C { submodules: b2: B2 {...} }
</pre>
<p>
Here, the search order is: <i>A, A2, a2, B, B2, b2, C</i>. NED
conceptually searches the <b><tt>parameters</tt></b> blocks in that order for a
(non-default) value, and then in reverse order for a default value.

<p>The full search order and the form of assignment expected on each level:

<p><ol>
  <li> <tt>A  { p = ...; }</tt>
  <li> <tt>A2 { p = ...; }</tt>
  <li> <tt>a2 { p = ...; }</tt>
  <li> <tt>B  { a2.p = ...; }</tt>
  <li> <tt>B2 { a2.p = ...; }</tt>
  <li> <tt>b2 { a2.p = ...; }</tt>
  <li> <tt>C  { b2.a2.p = ...; }</tt>
  <li> <tt>C  { b2.a2.p = default(...); }</tt>
  <li> <tt>b2 { a2.p = default(...); }</tt>
  <li> <tt>B2 { a2.p = default(...); }</tt>
  <li> <tt>B  { a2.p = default(...); }</tt>
  <li> <tt>a2 { p = default(...); }</tt>
  <li> <tt>A2 { p = default(...); }</tt>
  <li> <tt>A  { p = default(...); }</tt>
</ol>

<p>If only a default value is found or not even that, external configuration
has a say. The configuration may contain an assignment for <tt>C.b2.a2.p</tt>;
it may apply the default if there is one; it may ask the user interactively
to enter a value; or if there is no default, it may raise an error
<i>&#8220;no value for parameter&#8221;</i>.

<p>

<p><h3><a name="sec547"/>19.4.18 Type Name Resolution</h3>
<a name="ch-ned-ref:sec:type-name-resolution"></a>

<p>Names from other NED files can be referred to either by fully qualified
name (&#8220;<tt>inet.networklayer.ip.RoutingTable</tt>&#8221;), or by short name
(&#8220;<tt>RoutingTable</tt>&#8221;) if the name is visible.

<p>Visible names are:

<p><ul>
  <li> inner types of the same type or its super types;
  <li> anything from the same package;
  <li> imported names.
</ul>

<p><p class="subheading">Imports</p>

<p>Imports have a similar syntax to Java, but they are more flexible with wildcards.
All of the following are legal:

<pre class="ned">
import inet.networklayer.ipv4.RoutingTable;
import inet.networklayer.ipv4.*;
import inet.networklayer.ipv4.Ro*Ta*;
import inet.*.ipv4.*;
import inet.**.RoutingTable;
</pre>
<p>
One asterisk stands for any character sequence not containing dots; and a
double asterisk stands for any character sequence (which may contain dots).
No other wildcards are recognized.

<p>An import not containing a wildcard must match an existing NED type.
However, it is legal for an import that does contain wildcards
not to match any NED type (although that might generate a warning.)

<p>Inner types may not be referenced outside their enclosing types and
their subclasses.

<p><p class="subheading">Base Types and Submodules</p>

<p>Fully qualified names and simple names are accepted. Simple names
are looked up among the inner types of the enclosing type (compound
module), then using imports, then in the same package.

<p><p class="subheading">Network Name in the Ini File</p>

<p>The network name in the ini file may be given as a fully qualified name
or as a simple (unqualified) name.

<p>Simple (unqualified) names are tried with the same package as the
ini file is in (provided it is in a NED directory).

<p>
<h3><a name="sec548"/>19.4.19 Resolution of Parametric Types</h3>
<a name="ch-ned-ref:sec:parameteric-type-resolution"></a>

<p>This section describes the type resolution for submodules and connections
that are defined using the <b><tt>like</tt></b> keyword.

<p>Type resolution is done in two steps. In the first step, the type name
string expression is found and evaluated. Then in the second step, the
resulting type name string is resolved to an actual NED type.

<p><b>Step 1.</b> The lookup of the type name string expression is similar to
that of a parameter value lookup (<a href="#sec546">[19.4.17]</a>).

<p>The expression may be specified locally (between the angle brackets), or
using typename pattern assignments in any compound module that
contains the submodule or connection directly or indirectly. A
typename pattern is a pattern that ends in <tt>.typename</tt>.

<p>Patterns are matched against the relative path of the submodule or
connection, with <tt>.typename</tt> appended. The relative path is
composed of a list of submodule names (name plus index) separated
by dots; a connection is identified by the full name of its source
gate plus the name of the channel object (which is currently always
<tt>channel</tt>) separated by a dot.

<p><ul class="note"><b>NOTE</b><br>
As bidirectional connections are a shorthand for two unidirectional
connections, the source gate name is qualified with <tt>$i</tt> or
<tt>$o</tt> in the relative path.
</ul>

<p>An example that uses typename pattern assignment:

<pre class="ned">
module Host {
    submodules:
        tcp: &lt;&gt; like ITCP;;
        ...
    connections:
        tcp.ipOut --&gt; &lt;&gt; like IMyChannel --&gt; ip.tcpIn;
}

network Network {
    parameters:
        host[*].tcp.typename = "TCP_lwIP";
        host[*].tcp.ipOut.channel.typename = "DebugChannel";
    submodules:
        host[10] : Host;
        ...
}
</pre>
<p>
The general rules are the following:

<p><ol>
  <li> A (non-default) parameter assignment may not be overridden later;
    that is, if there are assignments in multiple places, the assignment
    &#8220;closest&#8221; to the submodule or connection definition will be effective;
    others will be flagged as errors.
  <li> A default value is only used if a non-default value is not present.
    A non-default value may also come from a source external to NED, namely
    the simulation configuration (<tt>omnetpp.ini</tt>).
  <li> Unlike non-default values, a default value <i>may</i> be overridden;
    that is, if there are default value assignments in multiple places,
    the assignment &#8220;farthest&#8221; from the submodule or connection definition will win.
  <li> Among pattern assignments within the same <b><tt>parameters</tt></b>
    block, the first match will win. Patterns assignments with default and
    non-default values are considered to be two disjoint sets, only one of
    which are searched at a time.
</ol>

<p>This yields the following conceptual search order for typename assignments:

<p><ol>
   <li> First, the submodule or connection definition is checked (angle brackets);
   <li> Then the compound module that contains the submodule or connection is
     checked for matching pattern assignments;
   <li> Then, assuming the compound module is part of a network, the search
     for matching pattern assignments continues up on the module tree until the root
     (the module that represents the network). At each level (compound module),
     first the specific submodule definition is checked, then the (parent) compound module.
     If a compound module is subclassed before instantiated, the base type is checked
     first.
</ol>

<p>When no (non-default) assignment is found, the same places are searched in the
<i>reverse order</i> for default value assignments. If no default value is
found, an error may be raised or the user may be interactively prompted.

<p>To illustrate the above rules, consider the following example:

<pre class="ned">
module A { submodules: h: &lt;&gt; like IFoo; }
module A2 extends A {...}
module B { submodules: a2: A2 {...} }
module B2 extends B {...}
network C { submodules: b2: B2 {...} }
</pre>
<p>
Here, the search order is: <i>h, A, A2, a2, B, B2, b2, C</i>. NED
conceptually searches the <b><tt>parameters</tt></b> blocks in that order for a
(non-default) value, and then in reverse order for a default value.

<p>The full search order and the form of assignment expected on each level:

<p><ol>
  <li> <tt>h: &lt;...&gt; like IFoo;</tt>
  <li> <tt>A  { h.typename = ...; }</tt>
  <li> <tt>A2 { h.typename = ...; }</tt>
  <li> <tt>a2 { h.typename = ...; }</tt>
  <li> <tt>B  { a2.h.typename = ...; }</tt>
  <li> <tt>B2 { a2.h.typename = ...; }</tt>
  <li> <tt>b2 { a2.h.typename = ...; }</tt>
  <li> <tt>C  { b2.a2.h.typename = ...; }</tt>
  <li> <tt>C  { b2.a2.h.typename = default(...); }</tt>
  <li> <tt>b2 { a2.h.typename = default(...); }</tt>
  <li> <tt>B2 { a2.h.typename = default(...); }</tt>
  <li> <tt>B  { a2.h.typename = default(...); }</tt>
  <li> <tt>a2 { h.typename = default(...); }</tt>
  <li> <tt>A2 { h.typename = default(...); }</tt>
  <li> <tt>A  { h.typename = default(...); }</tt>
  <li> <tt>h: &lt;default(...)&gt; like IFoo;</tt>
</ol>

<p>If only a default value is found or not even that, external configuration
has a say. The configuration may contain an assignment for
<tt>C.b2.a2.h.typename</tt>; it may apply the default value if there is one;
it may ask the user interactively to enter a value; or if there is no
default value, it may raise an error <i>&#8220;cannot determine submodule
type&#8221;</i>.

<p>
<b>Step 2.</b> The type name string is expected to hold the simple name or
fully qualified name of the desired NED type. Resolving the type name
string to an actual NED type differs from normal type name lookups in that
it ignores the imports in the file altogether. Instead, a list of NED types
that have the given simple name or fully qualified name <i>and</i>
implement the given interface is collected. The result must be exactly one
module or channel type.

<p>
<h3><a name="sec549"/>19.4.20 Implementing an Interface</h3>
<a name="ch-ned-ref:sec:implementing-an-interface"></a>

<p>A module type may implement one or more module interfaces, and a channel type
may implement one or more channel interfaces, using the <b><tt>like</tt></b>
keyword.

<p>The module or channel type is required to have <i>at least</i> those
parameters and gates that the interface has.

<p>Regarding component properties, parameter properties and gate properties
defined in the interface: the module or channel type is required to have at
least the properties of the interface, with at least the same values.
The component may have additional properties, and properties may add more
keys and values.

<p><ul class="note"><b>NOTE</b><br>
  Implementing an interface does not cause the properties, parameters and
  gates to be interited by the module or channel type; they have to be added
  explicitly.
</ul>

<p><ul class="note"><b>NOTE</b><br>
  A module or channel type may have extra properties, parameters and gates
  in addition to those in the interface.
</ul>

<p>

<p><h3><a name="sec550"/>19.4.21 Inheritance</h3>
<a name="ch-ned-ref:sec:inheritance"></a>

<p>Component inheritance is governed by the following rules:

<p><ul>
  <li> A simple module may only extend a simple module.
  <li> A compound module may only extend a compound module.
  <li> A channel may only extend a channel.
  <li> A module interface may only extend a module interface (or several module
        interfaces).
  <li> A channel interface may only extend a channel interface (or several
        channel interfaces).
</ul>

<p>A network is a shorthand for a compound module with the <b><tt>@isNetwork</tt></b>
property set, so the same rules apply to it as to compound modules.

<p>Inheritance may:
<ul>
    <li> add new properties, parameters, gates, inner types, submodules,
          connections, as long as names do not conflict with inherited names
    <li> modify inherited properties, and properties of inherited parameters and
          gates
    <li> it may not modify inherited submodules, connections and inner types
</ul>

<p>Other inheritance rules:
<ul>
    <li>  for inner types:
       new inner types can be added, but inherited ones cannot be changed
    <li>  for properties:
       contents will be merged (rules like for display strings: values on
       same key and same position will overwrite old ones)
    <li> for parameters:
       type cannot be redefined;
       value may be redefined in subclasses or at place of usage
    <li>  for gates:
       type cannot be redefined;
       vector size may be specified in subclasses or at place of usage if it was unspecified
    <li>  for gate/parameter properties:
       extra properties can be added;
       existing properties can be overridden/extended as for standalone properties
    <li>  for submodules:
       new submodules may be added, but inherited ones cannot be modified
    <li>  for connections:
       new connections may be added, but inherited ones cannot be modified
</ul>

<p>The following sections will elaborate on the above rules.

<p><p class="subheading">Property Inheritance</p>

<p>Generally, properties may be modified via inheritance. Inheritance may:

<p><ul>
    <li> add new keys
    <li> add/overwrite values for existing keys
    <li> remove a value from an existing key by using hyphen as a special value
</ul>

<p>
<p class="subheading">Parameter Inheritance</p>

<p>Default values for parameters may be overridden in subclasses.

<p><p class="subheading">Gate Inheritance</p>

<p>Gate vector size may not be overridden in subclasses.

<p>
<h3><a name="sec551"/>19.4.22 Network Build Order</h3>
<a name="ch-ned-ref:sec:build-order"></a>

<p>When a network is instantiated for simulation, the module tree is built in
a top-down preorder fashion. This means that starting from an empty system
module, all submodules are created, their parameters and vector sizes are
assigned, and they get fully connected before proceeding to go into the
submodules to build their internals.

<p>This implies that inside a compound module definition (including in
submodules and connections), one can refer to the compound module's
parameters and gate sizes, because they are already built at the time of
usage.

<p>The same rules apply to compound or simple modules created dynamically during
runtime.

<p>
<h2><a name="sec552"/>19.5 Expressions</h2>
<a name="ch-ned-ref:sec:expressions"></a>

<p>NED language expressions<!--ned!expressions--> have a C-like syntax, with
some variations on operator names (see <tt>^</tt>, <tt>#</tt>, <tt>##</tt>).
Expressions may refer to module parameters, loop variables (inside connection
<b><tt>for</tt></b> loops), gate vector and module vector sizes, and other attributes
of the model. Expressions can use built-in and user-defined functions as well.

<p><ul class="note"><b>NOTE</b><br>
New NED functions can be defined in C++; see section <a href="#sec301">[7.11]</a>.
</ul>

<p>
<h3><a name="sec553"/>19.5.1 Operators</h3>
<!--ned!expressions!operators-->

<p>The following operators are supported (in order of decreasing precedence):

<p><table border>
<TR> <TD align=left>

<p><b>Operator</b>                   </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> <tt>-</tt>, <tt>!</tt>, <it>~</it> </TD> <TD align=left> unary minus, negation, bitwise complement </TD></TR>
<TR> <TD align=left> <tt>^</tt>         </TD> <TD align=left> power-of </TD></TR>
<TR> <TD align=left> <tt>*</tt>, <tt>/</tt>, <tt>%</tt>       </TD> <TD align=left> multiply, divide, integer modulo </TD></TR>
<TR> <TD align=left> <tt>+</tt>, <tt>-</tt>                 </TD> <TD align=left> add, subtract, string concatenation </TD></TR>
<TR> <TD align=left> <tt>&lt;&lt;</tt>, <tt>&gt;&gt;</tt>               </TD> <TD align=left> bitwise shift </TD></TR>
<TR> <TD align=left> <tt>&amp;</tt>, <tt>|</tt>, <tt>#</tt>      </TD> <TD align=left> bitwise and, or, xor </TD></TR>
<TR> <TD align=left> <tt>==</tt>                         </TD> <TD align=left> equal </TD></TR>
<TR> <TD align=left> <tt>!=</tt>                         </TD> <TD align=left> not equal </TD></TR>
<TR> <TD align=left> <tt>&gt;</tt>, <tt>&gt;=</tt>                </TD> <TD align=left> greater than, greater than or equal to</TD></TR>
<TR> <TD align=left> <tt>&lt;</tt>, <tt>&lt;=</tt>                </TD> <TD align=left> less than, less than or equal to </TD></TR>
<TR> <TD align=left> <tt>&amp;&amp;</tt>, <tt>||</tt>, <tt>##</tt> </TD> <TD align=left> logical operators and, or, xor </TD></TR>
<TR> <TD align=left> <tt>?:</tt>                         </TD> <TD align=left> the C/C++ &#8220;inline if&#8221; </TD></TR>
</table>

<p><p class="subheading">Conversions</p>

<p>Values may have the same types as NED parameters: boolean, integer, double, string, or XML element.
An integer or double value may have an associated measurement unit (<tt>s</tt>, <tt>mW</tt>, etc.)

<p>Integer and double values are implicitly converted to one another where needed.

<p>There is no implicit conversion between boolean and numeric types, so <tt>0</tt>
is not a synonym for <b><tt>false</tt></b>, and nonzero numbers are not a synonym
for <b><tt>true</tt></b>.

<p>There is also no conversion between string and numeric types, so e.g. <tt>"foo"+5</tt>
is illegal. There are functions for converting a number to string and vice versa.

<p>For bitwise operators and modulo (%), doubles are converted to integers.

<p><ul class="note"><b>NOTE</b><br>
Integers are represented with the C++ type <tt>long</tt>. <tt>double</tt>-to-<tt>long</tt>
conversions are performed using the C++ language's built-in typecast operator.
As <tt>long</tt> is 32 bits on most 32-bit architectures, for portability reasons
it is not recommended to use integers that do not fit into 32 bits.
</ul>

<p>
<p class="subheading">Unit Handling</p>

<p>Operations involving numbers with units work in the following way:

<p>Addition, subtraction, and numeric comparisons require their arguments to
have the same unit or compatible units; in the latter case a unit conversion
is performed before the operation. Incompatible units cause an error.

<p>
Modulo, power-of and the bitwise operations require their arguments to be
dimensionless, otherwise the result would depend on the choice of the unit.

<p><ul class="note"><b>NOTE</b><br>
If you need a floating-point modulo operator that handles units as well, use
the <tt>fmod()</tt> function.
</ul>

<p>
Multiplying two numbers with units is not supported.

<p>
For division, dividing two numbers with units is only supported if the two
units are convertible (i.e. the result will be dimensionless). Dividing
a dimensionless number with a number with unit is not supported.

<p>

<p><h3><a name="sec554"/>19.5.2 Referencing Parameters and Loop Variables</h3>

<p>Identifiers in expressions occurring <i>anywhere</i> in component definitions
are interpreted as referring to parameters of the given component. For example,
identifiers inside submodule bodies refer to the parameters of the compound
module.

<p>Expressions may also refer to parameters of submodules defined earlier
in the NED file, using the <tt>submoduleName.paramName</tt> or the
<tt>submoduleName[index].paramName</tt> syntax. To refer to parameters
of the local submodule inside a submodule body, use the
<b><tt>this</tt></b> qualifier: <tt>this.destAddress</tt>.

<p>Exception: if an identifier occurs in a connection <b><tt>for</tt></b> loop and names
a previously defined loop variable, then it is understood as referring to
the loop variable.

<p>
<h3><a name="sec555"/>19.5.3 The <b><tt>index</tt></b> Operator</h3>

<p>The <b><tt>index</tt></b> operator is only allowed in a vector submodule's body,
and yields the index of the submodule instance.

<p>
<h3><a name="sec556"/>19.5.4 The <b><tt>sizeof()</tt></b> Operator</h3>

<p>The <b><tt>sizeof()</tt></b> operator expects one argument, and it is only accepted
in compound module definitions.

<p>The <tt>sizeof(identifier)</tt> syntax occurring <i>anywhere</i> in a compound
module yields the size of the named submodule or gate vector of the
compound module.

<p>Inside submodule bodies, the size of a gate vector of the same submodule
can be referred to with the <b><tt>this</tt></b> qualifier: <tt>sizeof(this.out)</tt>.

<p>To refer to the size of a submodule's gate vector defined earlier in the
NED file, use the <tt>sizeof(submoduleName.gateVectorName)</tt> or
<tt>sizeof(submoduleName[index].gateVectorName)</tt> syntax.

<p>
<h3><a name="sec557"/>19.5.5 Functions</h3>
<!--ned!functions-->

<p>The functions available in NED are listed in Appendix
<a href="#sec561">[22]</a>.

<p>Selected functions are documented below.

<p><p class="subheading">The <b><tt>xmldoc()</tt></b> Function</p>

<p>The <b><tt>xmldoc()</tt></b> NED function can be used to assign <b><tt>xml</tt></b> parameters,
that is, point them to XML files or to specific elements inside XML files.

<p><b><tt>xmldoc()</tt></b> accepts a file name as well as an optional second string argument
that contains an XPath-like expression.

<p>
The XPath expression is used to select an element within the document.
If the expression matches several elements, the first element
(in preorder depth-first traversal) will be selected. (This is
unlike XPath, which selects all matching nodes.)

<p>The expression syntax is the following:
<ul>
  <li> An expression consists of <i>path components</i> (or "steps")
        separated by "<tt>/</tt>" or "<tt>//</tt>".
  <li> A path component can be an element tag name, "<tt>*</tt>", "<tt>.</tt>"
        or "<tt>..</tt>".
  <li> "<tt>/</tt>" means child element (just as in <tt>/usr/bin/gcc</tt>);
        "<tt>//</tt>" means an element any number of levels under the current element.
  <li> "<tt>.</tt>", "<tt>..</tt>" and "<tt>*</tt>" mean the current element,
        the parent element, and an element with any tag name, respectively.
  <li> Element tag names and "<tt>*</tt>" can have an optional predicate
        in the form "<tt>[position]</tt>" or "<tt>[@attribute='value']</tt>".
        Positions start from zero.
  <li> Predicates of the form "<tt>[@attribute=<i>$param</i>]</tt>" are also
        accepted, where <tt><i>$param</i></tt> can be one of:
        <tt>$MODULE_FULLPATH</tt>,
        <tt>$MODULE_FULLNAME</tt>,
        <tt>$MODULE_NAME</tt>,
        <tt>$MODULE_INDEX</tt>,
        <tt>$MODULE_ID</tt>,
        <tt>$PARENTMODULE_FULLPATH</tt>,
        <tt>$PARENTMODULE_FULLNAME</tt>,
        <tt>$PARENTMODULE_NAME</tt>,
        <tt>$PARENTMODULE_INDEX</tt>,
        <tt>$PARENTMODULE_ID</tt>,
        <tt>$GRANDPARENTMODULE_FULLPATH</tt>,
        <tt>$GRANDPARENTMODULE_FULLNAME</tt>,
        <tt>$GRANDPARENTMODULE_NAME</tt>,
        <tt>$GRANDPARENTMODULE_INDEX</tt>,
        <tt>$GRANDPARENTMODULE_ID</tt>.
</ul>

<p><p class="subheading">The <b><tt>xml()</tt></b> Function</p>

<p>The <b><tt>xml()</tt></b> NED function can be used to parse a string as an
XML document, and assign the result to an <b><tt>xml</tt></b> parameter.

<p><b><tt>xml()</tt></b> accepts the string to be parsed as well as an optional
second string argument that contains an XPath-like expression.

<p>The XPath expression is used in the same manner as with the
<b><tt>xmldoc()</tt></b> function.

<p>
<h3><a name="sec558"/>19.5.6 Units of Measurement</h3>
<a name="ch-ned-ref:sec:units"></a>

<p>The following measurements units are recognized in constants. Other units can
be used as well, but there are no conversions available for them (i.e.
<tt>parsec</tt> and <tt>kiloparsec</tt> will be treated as two completely unrelated
units.)

<p><table border>
<TR> <TD align=center>
  
<p>  <b>Unit</b> </TD> <TD align=center> <b>Name</b> </TD> <TD align=right> <b>Value</b> </TD></TR>
<TR> <TD align=center>   s </TD> <TD align=center> second </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   d </TD> <TD align=center> day </TD> <TD align=right> 86400s </TD></TR>
<TR> <TD align=center>   h </TD> <TD align=center> hour </TD> <TD align=right> 3600s </TD></TR>
<TR> <TD align=center>   min </TD> <TD align=center> minute </TD> <TD align=right> 60s </TD></TR>
<TR> <TD align=center>   ms </TD> <TD align=center> millisecond </TD> <TD align=right> 1e-3s </TD></TR>
<TR> <TD align=center>   us </TD> <TD align=center> microsecond </TD> <TD align=right> 1e-6s </TD></TR>
<TR> <TD align=center>   ns </TD> <TD align=center> nanosecond </TD> <TD align=right> 1e-9s </TD></TR>
<TR> <TD align=center>   ps </TD> <TD align=center> picosecond </TD> <TD align=right> 1e-12s </TD></TR>
<TR> <TD align=center>   bps </TD> <TD align=center> bit/sec </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kbps </TD> <TD align=center> kilobit/sec </TD> <TD align=right> 1e3bps </TD></TR>
<TR> <TD align=center>   Mbps </TD> <TD align=center> megabit/sec </TD> <TD align=right> 1e6bps </TD></TR>
<TR> <TD align=center>   Gbps </TD> <TD align=center> gigabit/sec </TD> <TD align=right> 1e9bps </TD></TR>
<TR> <TD align=center>   Tbps </TD> <TD align=center> terabit/sec </TD> <TD align=right> 1e12bps </TD></TR>
<TR> <TD align=center>   B </TD> <TD align=center> byte </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   KiB </TD> <TD align=center> kilo (kibi) byte </TD> <TD align=right> 1024B </TD></TR>
<TR> <TD align=center>   MiB </TD> <TD align=center> mega (mebi) byte </TD> <TD align=right> 1.04858e6B </TD></TR>
<TR> <TD align=center>   GiB </TD> <TD align=center> giga (gibi) byte </TD> <TD align=right> 1.07374e9B </TD></TR>
<TR> <TD align=center>   TiB </TD> <TD align=center> tera (tebi) byte </TD> <TD align=right> 1.09951e12B </TD></TR>
<TR> <TD align=center>   b </TD> <TD align=center> bit </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   m </TD> <TD align=center> meter </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   km </TD> <TD align=center> kilometer </TD> <TD align=right> 1e3m </TD></TR>
<TR> <TD align=center>   cm </TD> <TD align=center> centimeter </TD> <TD align=right> 1e-2m </TD></TR>
<TR> <TD align=center>   mm </TD> <TD align=center> millimeter </TD> <TD align=right> 1e-3m </TD></TR>
<TR> <TD align=center>   W </TD> <TD align=center> watt </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   mW </TD> <TD align=center> milliwatt </TD> <TD align=right> 1e-3W </TD></TR>
<TR> <TD align=center>   Hz </TD> <TD align=center> hertz </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kHz </TD> <TD align=center> kilohertz </TD> <TD align=right> 1e3Hz </TD></TR>
<TR> <TD align=center>   MHz </TD> <TD align=center> megahertz </TD> <TD align=right> 1e6Hz </TD></TR>
<TR> <TD align=center>   GHz </TD> <TD align=center> gigahertz </TD> <TD align=right> 1e9Hz </TD></TR>
<TR> <TD align=center>   g </TD> <TD align=center> gram </TD> <TD align=right> 1e-3kg </TD></TR>
<TR> <TD align=center>   kg </TD> <TD align=center> kilogram </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   J </TD> <TD align=center> joule </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kJ </TD> <TD align=center> kilojoule </TD> <TD align=right> 1e3J </TD></TR>
<TR> <TD align=center>   MJ </TD> <TD align=center> megajoule </TD> <TD align=right> 1e6J </TD></TR>
<TR> <TD align=center>   V </TD> <TD align=center> volt </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kV </TD> <TD align=center> kilovolt </TD> <TD align=right> 1e3V </TD></TR>
<TR> <TD align=center>   mV </TD> <TD align=center> millivolt </TD> <TD align=right> 1e-3V </TD></TR>
<TR> <TD align=center>   A </TD> <TD align=center> ampere </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   mA </TD> <TD align=center> milliampere </TD> <TD align=right> 1e-3A </TD></TR>
<TR> <TD align=center>   uA </TD> <TD align=center> microampere </TD> <TD align=right> 1e-6A </TD></TR>
<TR> <TD align=center>   mps </TD> <TD align=center> meter/sec </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kmph </TD> <TD align=center> kilometer/hour </TD> <TD align=right> (1/3.6)mps </TD></TR>
</table>

<p>

<hr class='pgbr'><h1><a name="sec559"/>20 Appendix&#58; NED Language Grammar</h1>
<a name="cha:ned-language-grammar"></a>

<p>This appendix contains the grammar for the NED language<!--ned!language-->.

<p>In the NED language, space, horizontal tab and new line characters count
as delimiters, so one or more of them is required between two elements of the
description which would otherwise be unseparable.

<p>'//' (two slashes) may be used to write comments that last to the end of the line.

<p>The language is fully case sensitive.

<p>Notation:
<ul>
  <li>rule syntax is that of <i>bison</i>/<i>yacc</i>
  <li>uppercase words are terminals, lowercase words are nonterminals
  <li><tt>NAME</tt>, <tt>STRINGCONSTANT</tt>, <tt>INTCONSTANT</tt>,
        <tt>REALCONSTANT</tt> represent identifier names and string,
        integer and real number literals (defined as in the C language,
        except that a <tt>0</tt> prefix does not stand for octal notation)
  <li>other terminals represent keywords in all lowercase
</ul>

<p>

<pre class="verbatim">
nedfile
        : definitions
        |
        ;

definitions
        : definitions definition
        | definition
        ;

definition
        : packagedeclaration
        | import
        | propertydecl
        | fileproperty
        | channeldefinition
        | channelinterfacedefinition
        | simplemoduledefinition
        | compoundmoduledefinition
        | networkdefinition
        | moduleinterfacedefinition
        | ';'
        ;

packagedeclaration
        : PACKAGE dottedname ';'
        ;

dottedname
        : dottedname '.' NAME
        | NAME
        ;

import
        : IMPORT importspec ';'
        ;

importspec
        : importspec '.' importname
        | importname
        ;

importname
        : importname NAME
        | importname '*'
        | importname '**'
        | NAME
        | '*'
        | '**'
        ;

propertydecl
        : propertydecl_header opt_inline_properties ';'
        | propertydecl_header '(' opt_propertydecl_keys ')' opt_inline_properties ';'
        ;

propertydecl_header
        : PROPERTY '@' PROPNAME
        | PROPERTY '@' PROPNAME '[' ']'
        ;

opt_propertydecl_keys
        : propertydecl_keys
        |
        ;

propertydecl_keys
        : propertydecl_keys ';' propertydecl_key
        | propertydecl_key
        ;

propertydecl_key
        : property_literal
        ;

fileproperty
        : property_namevalue ';'
        ;

channeldefinition
        : channelheader '{'
            opt_paramblock
          '}'
        ;

channelheader
        : CHANNEL NAME
           opt_inheritance
        ;

opt_inheritance
        :
        | EXTENDS extendsname
        | LIKE likenames
        | EXTENDS extendsname LIKE likenames
        ;

extendsname
        : dottedname
        ;

likenames
        : likenames ',' likename
        | likename
        ;

likename
        : dottedname
        ;

channelinterfacedefinition
        : channelinterfaceheader '{'
            opt_paramblock
          '}'
        ;

channelinterfaceheader
        : CHANNELINTERFACE NAME
           opt_interfaceinheritance
        ;

opt_interfaceinheritance
        : EXTENDS extendsnames
        |
        ;

extendsnames
        : extendsnames ',' extendsname
        | extendsname
        ;

simplemoduledefinition
        : simplemoduleheader '{'
            opt_paramblock
            opt_gateblock
          '}'
        ;

simplemoduleheader
        : SIMPLE NAME
          opt_inheritance
        ;

compoundmoduledefinition
        : compoundmoduleheader '{'
            opt_paramblock
            opt_gateblock
            opt_typeblock
            opt_submodblock
            opt_connblock
          '}'
        ;

compoundmoduleheader
        : MODULE NAME
          opt_inheritance
        ;

networkdefinition
        : networkheader '{'
            opt_paramblock
            opt_gateblock
            opt_typeblock
            opt_submodblock
            opt_connblock
          '}'
        ;

networkheader
        : NETWORK NAME
          opt_inheritance
        ;

moduleinterfacedefinition
        : moduleinterfaceheader '{'
            opt_paramblock
            opt_gateblock
          '}'
        ;

moduleinterfaceheader
        : MODULEINTERFACE NAME
           opt_interfaceinheritance
        ;

opt_paramblock
        : opt_params
        | PARAMETERS ':'
          opt_params
        ;

opt_params
        : params
        |
        ;

params
        : params paramsitem
        | paramsitem
        ;

paramsitem
        : param
        | property
        ;

param
        : param_typenamevalue
        | pattern_value
        ;

param_typenamevalue
        : param_typename opt_inline_properties ';'
        | param_typename opt_inline_properties '=' paramvalue opt_inline_properties ';'
        ;

param_typename
        : opt_volatile paramtype NAME
        | NAME
        ;

pattern_value
        : pattern '=' paramvalue ';'
        ;

paramtype
        : DOUBLE
        | INT
        | STRING
        | BOOL
        | XML
        ;

opt_volatile
        : VOLATILE
        |
        ;

paramvalue
        : expression
        | DEFAULT '(' expression ')'
        | DEFAULT
        | ASK
        ;

opt_inline_properties
        : inline_properties
        |
        ;

inline_properties
        : inline_properties property_namevalue
        | property_namevalue
        ;

pattern
        : pattern2 '.' pattern_elem
        | pattern2 '.' TYPENAME
        ;

pattern2
        : pattern2 '.' pattern_elem
        | pattern_elem
        ;

pattern_elem
        : pattern_name
        | pattern_name '[' pattern_index ']'
        | pattern_name '[' '*' ']'
        | '**'
        ;

pattern_name
        : NAME
        | NAME '$' NAME
        | CHANNEL
        | '{' pattern_index '}'
        | '*'
        | pattern_name NAME
        | pattern_name '{' pattern_index '}'
        | pattern_name '*'
        ;

pattern_index
        : INTCONSTANT
        | INTCONSTANT '..' INTCONSTANT
        | '..' INTCONSTANT
        | INTCONSTANT '..'
        ;

property
        : property_namevalue ';'
        ;

property_namevalue
        : property_name
        | property_name '(' opt_property_keys ')'
        ;

property_name
        : '@' PROPNAME
        | '@' PROPNAME '[' PROPNAME ']'
        ;

opt_property_keys
        : property_keys
        ;

property_keys
        : property_keys ';' property_key
        | property_key
        ;

property_key
        : property_literal '=' property_values
        | property_values
        ;

property_values
        : property_values ',' property_value
        | property_value
        ;

property_value
        : property_literal
        |
        ;

property_literal
        : property_literal CHAR
        | property_literal STRINGCONSTANT
        | CHAR
        | STRINGCONSTANT
        ;

opt_gateblock
        : gateblock
        |
        ;

gateblock
        : GATES ':'
          opt_gates
        ;

opt_gates
        : gates
        |
        ;

gates
        : gates gate
        | gate
        ;

gate
        : gate_typenamesize
          opt_inline_properties ';'
        ;

gate_typenamesize
        : gatetype NAME
        | gatetype NAME '[' ']'
        | gatetype NAME vector
        | NAME
        | NAME '[' ']'
        | NAME vector
        ;

gatetype
        : INPUT
        | OUTPUT
        | INOUT
        ;

opt_typeblock
        : typeblock
        |
        ;

typeblock
        : TYPES ':'
           opt_localtypes
        ;

opt_localtypes
        : localtypes
        |
        ;

localtypes
        : localtypes localtype
        | localtype
        ;

localtype
        : propertydecl
        | channeldefinition
        | channelinterfacedefinition
        | simplemoduledefinition
        | compoundmoduledefinition
        | networkdefinition
        | moduleinterfacedefinition
        | ';'
        ;

opt_submodblock
        : submodblock
        |
        ;

submodblock
        : SUBMODULES ':'
          opt_submodules
        ;

opt_submodules
        : submodules
        |
        ;

submodules
        : submodules submodule
        | submodule
        ;

submodule
        : submoduleheader ';'
        | submoduleheader '{'
          opt_paramblock
          opt_gateblock
          '}' opt_semicolon
        ;

submoduleheader
        : submodulename ':' dottedname opt_condition
        | submodulename ':' likeexpr LIKE dottedname opt_condition
        ;

submodulename
        : NAME
        |  NAME vector
        ;

likeexpr
        : '&lt;' '&gt;'
        | '&lt;' expression '&gt;'
        | '&lt;' DEFAULT '(' expression ')' '&gt;'
        ;

opt_condition
        : condition
        |
        ;

opt_connblock
        : connblock
        |
        ;

connblock
        : CONNECTIONS ALLOWUNCONNECTED ':'
          opt_connections
        | CONNECTIONS ':'
          opt_connections
        ;

opt_connections
        : connections
        |
        ;

connections
        : connections connectionsitem
        | connectionsitem
        ;

connectionsitem
        : connectiongroup
        | connection opt_loops_and_conditions ';'
        ;

connectiongroup
        : opt_loops_and_conditions '{'
          connections '}' opt_semicolon
        ;

opt_loops_and_conditions
        : loops_and_conditions
        |
        ;

loops_and_conditions
        : loops_and_conditions ',' loop_or_condition
        | loop_or_condition
        ;

loop_or_condition
        : loop
        | condition
        ;

loop
        : FOR NAME '=' expression '..' expression
        ;

connection
        : leftgatespec '--&gt;' rightgatespec
        | leftgatespec '--&gt;' channelspec '--&gt;' rightgatespec
        | leftgatespec '&lt;--' rightgatespec
        | leftgatespec '&lt;--' channelspec '&lt;--' rightgatespec
        | leftgatespec '&lt;--&gt;' rightgatespec
        | leftgatespec '&lt;--&gt;' channelspec '&lt;--&gt;' rightgatespec
        ;

leftgatespec
        : leftmod '.' leftgate
        | parentleftgate
        ;

leftmod
        : NAME vector
        | NAME
        ;

leftgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

parentleftgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

rightgatespec
        : rightmod '.' rightgate
        | parentrightgate
        ;

rightmod
        : NAME
        | NAME vector
        ;

rightgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

parentrightgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

opt_subgate
        : '$' NAME
        |
        ;

channelspec
        : channelspec_header
        | channelspec_header '{'
            opt_paramblock
          '}'
        ;

channelspec_header
        : opt_channelname
        | opt_channelname dottedname
        | opt_channelname likeexpr LIKE dottedname
        ;

opt_channelname
        :
        | NAME ':'
        ;

condition
        : IF expression
        ;

vector
        : '[' expression ']'
        ;

expression
        :
          expr
        ;

expr
        : simple_expr
        | '(' expr ')'
        | CONST '(' expr ')'
        | expr '+' expr
        | expr '-' expr
        | expr '*' expr
        | expr '/' expr
        | expr '%' expr
        | expr '^' expr
        | '-' expr
        | expr '==' expr
        | expr '!=' expr
        | expr '&gt;' expr
        | expr '&gt;=' expr
        | expr '&lt;' expr
        | expr '&lt;=' expr
        | expr '&&' expr
        | expr '||' expr
        | expr '##' expr
        | '!' expr
        | expr '&' expr
        | expr '|' expr
        | expr '#' expr
        | '~' expr
        | expr '&lt;&lt;' expr
        | expr '&gt;&gt;' expr
        | expr '?' expr ':' expr
        | INT '(' expr ')'
        | DOUBLE '(' expr ')'
        | STRING '(' expr ')'
        | funcname '(' ')'
        | funcname '(' expr ')'
        | funcname '(' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | funcname '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        ;

simple_expr
        : identifier
        | special_expr
        | literal
        ;

funcname
        : NAME
        | XMLDOC
        | XML
        ;

identifier
        : NAME
        | THIS '.' NAME
        | NAME '.' NAME
        | NAME '[' expr ']' '.' NAME
        ;

special_expr
        : INDEX
        | INDEX '(' ')'
        | SIZEOF '(' identifier ')'
        ;

literal
        : stringliteral
        | boolliteral
        | numliteral
        ;

stringliteral
        : STRINGCONSTANT
        ;

boolliteral
        : TRUE
        | FALSE
        ;

numliteral
        : INTCONSTANT
        | REALCONSTANT
        | quantity
        ;

quantity
        : quantity INTCONSTANT NAME
        | quantity REALCONSTANT NAME
        | INTCONSTANT NAME
        | REALCONSTANT NAME
        ;

opt_semicolon
        : ';'
        |
        ;
</pre>

<p>
<hr class='pgbr'><h1><a name="sec560"/>21 Appendix&#58; NED XML Binding</h1>
<a name="cha:ned-xml-binding"></a>

<p>This appendix shows the DTD for the XML binding of the NED language and
message definitions.


<pre class="verbatim">
&lt;!ELEMENT files ((ned-file|msg-file)*)&gt;

&lt;!--
  **  NED-2.
  --&gt;

&lt;!ELEMENT ned-file (comment*, (package|import|property-decl|property|
                    simple-module|compound-module|module-interface|
                    channel|channel-interface)*)&gt;
&lt;!ATTLIST ned-file
     filename           CDATA     #REQUIRED
     version            CDATA     "2"&gt;

&lt;!-- comments and whitespace; comments include '//' marks. Note that although
     nearly all elements may contain comment elements, there are places
     (e.g. within expressions) where they are ignored by the implementation.
     Default value is a space or a newline, depending on the context.
 --&gt;
&lt;!ELEMENT comment EMPTY&gt;
&lt;!ATTLIST comment
     locid              NMTOKEN   #REQUIRED
     content            CDATA     #IMPLIED&gt;

&lt;!ELEMENT package (comment*)&gt;
&lt;!ATTLIST package
     name               CDATA     #REQUIRED&gt;

&lt;!ELEMENT import (comment*)&gt;
&lt;!ATTLIST import
     import-spec        CDATA     #REQUIRED&gt;

&lt;!ELEMENT property-decl (comment*, property-key*, property*)&gt;
&lt;!ATTLIST property-decl
     name               NMTOKEN   #REQUIRED
     is-array           (true|false) "false"&gt;

&lt;!ELEMENT extends (comment*)&gt;
&lt;!ATTLIST extends
     name               CDATA     #REQUIRED&gt;

&lt;!ELEMENT interface-name (comment*)&gt;
&lt;!ATTLIST interface-name
     name               CDATA     #REQUIRED&gt;

&lt;!ELEMENT simple-module (comment*, extends?, interface-name*, parameters?, gates?)&gt;
&lt;!ATTLIST simple-module
     name               NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT module-interface (comment*, extends*, parameters?, gates?)&gt;
&lt;!ATTLIST module-interface
     name               NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT compound-module (comment*, extends?, interface-name*,
                           parameters?, gates?, types?, submodules?, connections?)&gt;
&lt;!ATTLIST compound-module
     name               NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT channel-interface (comment*, extends*, parameters?)&gt;
&lt;!ATTLIST channel-interface
     name                NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT channel (comment*, extends?, interface-name*, parameters?)&gt;
&lt;!ATTLIST channel
     name                NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT parameters (comment*, (property|param)*)&gt;
&lt;!ATTLIST parameters
    is-implicit         (true|false)  "false"&gt;

&lt;!ELEMENT param (comment*, expression?, property*)&gt;
&lt;!ATTLIST param
     type               (double|int|string|bool|xml) #IMPLIED
     is-volatile        (true|false)  "false"
     name               CDATA     #REQUIRED
     value              CDATA     #IMPLIED
     is-pattern         (true|false)  "false"
     is-default         (true|false)  "false"&gt;

&lt;!ELEMENT property (comment*, property-key*)&gt;
&lt;!ATTLIST property
     is-implicit        (true|false) "false"
     name               NMTOKEN   #REQUIRED
     index              NMTOKEN   #IMPLIED&gt;

&lt;!ELEMENT property-key (comment*, literal*)&gt;
&lt;!ATTLIST property-key
     name               CDATA     #IMPLIED&gt;

&lt;!ELEMENT gates (comment*, gate*)&gt;

&lt;!ELEMENT gate (comment*, expression?, property*)&gt;
&lt;!ATTLIST gate
     name               NMTOKEN   #REQUIRED
     type               (input|output|inout) #IMPLIED
     is-vector          (true|false) "false"
     vector-size        CDATA     #IMPLIED&gt;

&lt;!ELEMENT types (comment*, (channel|channel-interface|simple-module|
                               compound-module|module-interface)*)&gt;

&lt;!ELEMENT submodules (comment*, submodule*)&gt;

&lt;!ELEMENT submodule (comment*, expression*, condition?, parameters?, gates?)&gt;
&lt;!ATTLIST submodule
     name               NMTOKEN   #REQUIRED
     type               CDATA     #IMPLIED
     like-type          CDATA     #IMPLIED
     like-expr          CDATA     #IMPLIED
     is-default         (true|false) "false"
     vector-size        CDATA     #IMPLIED&gt;

&lt;!ELEMENT connections (comment*, (connection|connection-group)*)&gt;
&lt;!ATTLIST connections
     allow-unconnected (true|false) "false"&gt;

&lt;!ELEMENT connection (comment*, expression*, parameters?, (loop|condition)*)&gt;
&lt;!ATTLIST connection
     src-module          NMTOKEN   #IMPLIED
     src-module-index    CDATA     #IMPLIED
     src-gate            NMTOKEN   #REQUIRED
     src-gate-plusplus  (true|false) "false"
     src-gate-index      CDATA     #IMPLIED
     src-gate-subg       (i|o)     #IMPLIED
     dest-module         NMTOKEN   #IMPLIED
     dest-module-index   CDATA     #IMPLIED
     dest-gate           NMTOKEN   #REQUIRED
     dest-gate-plusplus (true|false) "false"
     dest-gate-index     CDATA     #IMPLIED
     dest-gate-subg      (i|o)     #IMPLIED
     name                NMTOKEN   #IMPLIED
     type                CDATA     #IMPLIED
     like-type           CDATA     #IMPLIED
     like-expr           CDATA     #IMPLIED
     is-default         (true|false) "false"
     is-bidirectional   (true|false) "false"
     is-forward-arrow   (true|false) "true"&gt;

&lt;!ELEMENT connection-group (comment*, (loop|condition)*, connection*)&gt;

&lt;!ELEMENT loop (comment*, expression*)&gt;
&lt;!ATTLIST loop
     param-name          NMTOKEN   #REQUIRED
     from-value          CDATA     #IMPLIED
     to-value            CDATA     #IMPLIED&gt;

&lt;!ELEMENT condition (comment*, expression?)&gt;
&lt;!ATTLIST condition
     condition           CDATA     #IMPLIED&gt;

&lt;!--
  **  Expressions
  --&gt;

&lt;!ELEMENT expression (comment*, (operator|function|ident|literal))&gt;
&lt;!ATTLIST expression
     target              CDATA     #IMPLIED&gt;

&lt;!ELEMENT operator (comment*, (operator|function|ident|literal)+)&gt;
&lt;!ATTLIST operator
     name                CDATA     #REQUIRED&gt;

&lt;!-- functions, "index", "const" and "sizeof" --&gt;
&lt;!ELEMENT function (comment*, (operator|function|ident|literal)*)&gt;
&lt;!ATTLIST function
     name                NMTOKEN   #REQUIRED&gt;

&lt;!-- Ident is either a parameter reference or an argument for the "sizeof"
     operator; its NED source form is one of the following: "name", "module.name",
     "module[n].name". If there is a child, it represents the module index n.
     A reserved module name (with special meaning) is "this".
--&gt;
&lt;!ELEMENT ident (comment*, (operator|function|ident|literal)?)&gt;
&lt;!ATTLIST ident
     module              CDATA     #IMPLIED
     name                NMTOKEN   #REQUIRED&gt;


&lt;!ELEMENT literal (comment*)&gt;
&lt;!-- Note: value is in fact REQUIRED, but empty attr value should
     also be accepted because that represents the "" string literal;
     "spec" is for properties, to store the null value and "-",
     the antivalue. Unit can only be present with "double".
 --&gt;
&lt;!ATTLIST literal
     type  (double|int|string|bool|spec)  #REQUIRED
     unit                CDATA     #IMPLIED
     text                CDATA     #IMPLIED
     value               CDATA     #IMPLIED&gt;

&lt;!--**********************************************************************--&gt;

&lt;!--
**
** OMNeT++/OMNEST Message Definitions (MSG)
**
--&gt;

&lt;!ELEMENT msg-file (comment*, (namespace|property-decl|property|cplusplus|
                    struct-decl|class-decl|message-decl|packet-decl|enum-decl|
                    struct|class|message|packet|enum)*)&gt;

&lt;!ATTLIST msg-file
     filename            CDATA     #IMPLIED
     version             CDATA     "2"&gt;

&lt;!ELEMENT namespace (comment*)&gt;
&lt;!ATTLIST namespace
     name                CDATA     #REQUIRED&gt;  &lt;!-- note: not NMTOKEN because it may contain "::" --&gt;

&lt;!ELEMENT cplusplus (comment*)&gt;
&lt;!ATTLIST cplusplus
     body                CDATA     #REQUIRED&gt;

&lt;!-- C++ type announcements --&gt;

&lt;!ELEMENT struct-decl (comment*)&gt;
&lt;!ATTLIST struct-decl
     name                CDATA     #REQUIRED&gt;

&lt;!ELEMENT class-decl (comment*)&gt;
&lt;!ATTLIST class-decl
     name                CDATA     #REQUIRED
     is-cobject      (true|false)  "false"
     extends-name        CDATA     #IMPLIED&gt;

&lt;!ELEMENT message-decl (comment*)&gt;
&lt;!ATTLIST message-decl
     name                CDATA     #REQUIRED&gt;

&lt;!ELEMENT packet-decl (comment*)&gt;
&lt;!ATTLIST packet-decl
     name                CDATA     #REQUIRED&gt;

&lt;!ELEMENT enum-decl (comment*)&gt;
&lt;!ATTLIST enum-decl
     name                CDATA     #REQUIRED&gt;

&lt;!-- Enums --&gt;

&lt;!ELEMENT enum (comment*, enum-fields?)&gt;
&lt;!ATTLIST enum
     name                NMTOKEN   #REQUIRED
     extends-name        CDATA     #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT enum-fields (comment*, enum-field*)&gt;

&lt;!ELEMENT enum-field (comment*)&gt;
&lt;!ATTLIST enum-field
     name                NMTOKEN   #REQUIRED
     value               CDATA     #IMPLIED&gt;

&lt;!-- Message, class, struct --&gt;

&lt;!ELEMENT message (comment*, (property|field)*)&gt;
&lt;!ATTLIST message
     name                NMTOKEN   #REQUIRED
     extends-name        CDATA     #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT packet (comment*, (property|field)*)&gt;
&lt;!ATTLIST packet
     name                NMTOKEN   #REQUIRED
     extends-name        CDATA     #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT class (comment*, (property|field)*)&gt;
&lt;!ATTLIST class
     name                NMTOKEN   #REQUIRED
     extends-name        CDATA     #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT struct (comment*, (property|field)*)&gt;
&lt;!ATTLIST struct
     name                NMTOKEN   #REQUIRED
     extends-name        CDATA     #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT field (comment*, property*)&gt;
&lt;!ATTLIST field
     name                NMTOKEN   #REQUIRED
     data-type           CDATA     #IMPLIED
     is-abstract     (true|false)  "false"
     is-readonly     (true|false)  "false"
     is-vector       (true|false)  "false"
     vector-size         CDATA     #IMPLIED
     default-value       CDATA     #IMPLIED&gt;

&lt;!--
  **  'unknown' is used internally to represent elements not in this NED DTD
  --&gt;
&lt;!ELEMENT unknown        ANY&gt;
&lt;!ATTLIST unknown
     element             CDATA     #REQUIRED&gt;
</pre>
<p>

<hr class='pgbr'><h1><a name="sec561"/>22 Appendix&#58; NED Functions</h1>
<a name="cha:ned-functions"></a>

<p>The functions that can be used in NED expressions and ini files are the
following. The question mark (as in &#8220;<tt>rng?</tt>&#8221;) marks optional arguments.


<p class="subheading">Category "conversion":</p>

<p><dl>
<li><b>double</b> : <tt>double double(any x)</tt> <br>
    Converts x to double, and returns the result. A boolean argument becomes 0 or 1; a string is interpreted as number; an XML argument causes an error.
<li><b>int</b> : <tt>int int(any x)</tt> <br>
    Converts x to an integer (C++ long), and returns the result. A boolean argument becomes 0 or 1; a double is converted using floor(); a string is interpreted as number; an XML argument causes an error.
<li><b>string</b> : <tt>string string(any x)</tt> <br>
    Converts x to string, and returns the result.

<p></dl>

<p><p class="subheading">Category "math":</p>

<p><dl>
<li><b>acos</b> : <tt>double acos(double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>asin</b> : <tt>double asin(double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>atan</b> : <tt>double atan(double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>atan2</b> : <tt>double atan2(double, double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>ceil</b> : <tt>double ceil(double)</tt> <br>
    Rounds down; see standard C function of the same name
<li><b>cos</b> : <tt>double cos(double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>exp</b> : <tt>double exp(double)</tt> <br>
    Exponential; see standard C function of the same name
<li><b>fabs</b> : <tt>quantity fabs(quantity x)</tt> <br>
    Returns the absolute value of the quantity.
<li><b>floor</b> : <tt>double floor(double)</tt> <br>
    Rounds up; see standard C function of the same name
<li><b>fmod</b> : <tt>quantity fmod(quantity x, quantity y)</tt> <br>
    Returns the floating-point remainder of x/y; unit conversion takes place if needed.
<li><b>hypot</b> : <tt>double hypot(double, double)</tt> <br>
    Length of the hypotenuse; see standard C function of the same name
<li><b>log</b> : <tt>double log(double)</tt> <br>
    Natural logarithm; see standard C function of the same name
<li><b>log10</b> : <tt>double log10(double)</tt> <br>
    Base-10 logarithm; see standard C function of the same name
<li><b>max</b> : <tt>quantity max(quantity a, quantity b)</tt> <br>
    Returns the greater one of the two quantities; unit conversion takes place if needed.
<li><b>min</b> : <tt>quantity min(quantity a, quantity b)</tt> <br>
    Returns the smaller one of the two quantities; unit conversion takes place if needed.
<li><b>pow</b> : <tt>double pow(double, double)</tt> <br>
    Power; see standard C function of the same name
<li><b>sin</b> : <tt>double sin(double)</tt> <br>
    Trigonometric function; see standard C function of the same name
<li><b>sqrt</b> : <tt>double sqrt(double)</tt> <br>
    Square root; see standard C function of the same name
<li><b>tan</b> : <tt>double tan(double)</tt> <br>
    Trigonometric function; see standard C function of the same name

<p></dl>

<p><p class="subheading">Category "misc":</p>

<p><dl>
<li><b>firstAvailable</b> : <tt>string firstAvailable(...)</tt> <br>
    Accepts any number of strings, interprets them as NED type names (qualified or unqualified), and returns the first one that exists and its C++ implementation class is also available. Throws an error if none of the types are available.
<li><b>simTime</b> : <tt>quantity simTime()</tt> <br>
    Returns the current simulation time.
<li><b>select</b> : <tt>any select(int index, ...)</tt> <br>
    Returns the &lt;index&gt;th item from the rest of the argument list; numbering starts from 0.
</dl>

<p><p class="subheading">Category "ned":</p>

<p><dl>
<li><b>ancestorIndex</b> : <tt>int ancestorIndex(int numLevels)</tt> <br>
    Returns the index of the ancestor module numLevels levels above the module or channel in context.
<li><b>fullName</b> : <tt>string fullName()</tt> <br>
    Returns the full name of the module or channel in context.
<li><b>fullPath</b> : <tt>string fullPath()</tt> <br>
    Returns the full path of the module or channel in context.
<li><b>parentIndex</b> : <tt>int parentIndex()</tt> <br>
    Returns the index of the parent module, which has to be part of module vector.

<p></dl>

<p><p class="subheading">Category "random/continuous":</p>

<p><dl>
<li><b>beta</b> : <tt>double beta(double alpha1, double alpha2, int rng?)</tt> <br>
    Returns a random number from the Beta distribution
<li><b>cauchy</b> : <tt>quantity cauchy(quantity a, quantity b, int rng?)</tt> <br>
    Returns a random number from the Cauchy distribution
<li><b>chi_square</b> : <tt>double chi_square(int k, int rng?)</tt> <br>
    Returns a random number from the Chi-square distribution
<li><b>erlang_k</b> : <tt>quantity erlang_k(int k, quantity mean, int rng?)</tt> <br>
    Returns a random number from the Erlang distribution
<li><b>exponential</b> : <tt>quantity exponential(quantity mean, int rng?)</tt> <br>
    Returns a random number from the Exponential distribution
<li><b>gamma_d</b> : <tt>quantity gamma_d(double alpha, quantity theta, int rng?)</tt> <br>
    Returns a random number from the Gamma distribution
<li><b>lognormal</b> : <tt>double lognormal(double m, double w, int rng?)</tt> <br>
    Returns a random number from the Lognormal distribution
<li><b>normal</b> : <tt>quantity normal(quantity mean, quantity stddev, int rng?)</tt> <br>
    Returns a random number from the Normal distribution
<li><b>pareto_shifted</b> : <tt>quantity pareto_shifted(double a, quantity b, quantity c, int rng?)</tt> <br>
    Returns a random number from the Pareto-shifted distribution
<li><b>student_t</b> : <tt>double student_t(int i, int rng?)</tt> <br>
    Returns a random number from the Student-t distribution
<li><b>triang</b> : <tt>quantity triang(quantity a, quantity b, quantity c, int rng?)</tt> <br>
    Returns a random number from the Triangular distribution
<li><b>truncnormal</b> : <tt>quantity truncnormal(quantity mean, quantity stddev, int rng?)</tt> <br>
    Returns a random number from the truncated Normal distribution
<li><b>uniform</b> : <tt>quantity uniform(quantity a, quantity b, int rng?)</tt> <br>
    Returns a random number from the Uniform distribution
<li><b>weibull</b> : <tt>quantity weibull(quantity a, quantity b, int rng?)</tt> <br>
    Returns a random number from the Weibull distribution

<p></dl>

<p><p class="subheading">Category "random/discrete":</p>

<p><dl>
<li><b>bernoulli</b> : <tt>int bernoulli(double p, int rng?)</tt> <br>
    Returns a random number from the Bernoulli distribution
<li><b>binomial</b> : <tt>int binomial(int n, double p, int rng?)</tt> <br>
    Returns a random number from the Binomial distribution
<li><b>geometric</b> : <tt>int geometric(double p, int rng?)</tt> <br>
    Returns a random number from the Geometric distribution
<li><b>intuniform</b> : <tt>int intuniform(int a, int b, int rng?)</tt> <br>
    Returns a random number from the Intuniform distribution
<li><b>negbinomial</b> : <tt>int negbinomial(int n, double p, int rng?)</tt> <br>
    Returns a random number from the Negbinomial distribution
<li><b>poisson</b> : <tt>int poisson(double lambda, int rng?)</tt> <br>
    Returns a random number from the Poisson distribution

<p></dl>

<p><p class="subheading">Category "strings":</p>

<p><dl>
<li><b>choose</b> : <tt>string choose(int index, string list)</tt> <br>
    Interprets list as a space-separated list, and returns the item at the given index. Negative and out-of-bounds indices cause an error.
<li><b>contains</b> : <tt>bool contains(string s, string substr)</tt> <br>
    Returns true if string s contains substr as substring
<li><b>endsWith</b> : <tt>bool endsWith(string s, string substr)</tt> <br>
    Returns true if s ends with the substring substr.
<li><b>expand</b> : <tt>string expand(string s)</tt> <br>
    Expands $ variables ($configname, $runnumber, etc.) in the given string, and returns the result.
<li><b>indexOf</b> : <tt>int indexOf(string s, string substr)</tt> <br>
    Returns the position of the first occurrence of substring substr in s, or -1 if s does not contain substr.
<li><b>length</b> : <tt>int length(string s)</tt> <br>
    Returns the length of the string
<li><b>replace</b> : <tt>string replace(string s, string substr, string repl, int startPos?)</tt> <br>
    Replaces all occurrences of substr in s with the string repl. If startPos is given, search begins from position startPos in s.
<li><b>replaceFirst</b> : <tt>string replaceFirst(string s, string substr, string repl, int startPos?)</tt> <br>
    Replaces the first occurrence of substr in s with the string repl. If startPos is given, search begins from position startPos in s.
<li><b>startsWith</b> : <tt>bool startsWith(string s, string substr)</tt> <br>
    Returns true if s begins with the substring substr.
<li><b>substring</b> : <tt>string substring(string s, int pos, int len?)</tt> <br>
    Return the substring of s starting at the given position, either to the end of the string or maximum len characters
<li><b>substringAfter</b> : <tt>string substringAfter(string s, string substr)</tt> <br>
    Returns the substring of s after the first occurrence of substr, or the empty string if s does not contain substr.
<li><b>substringAfterLast</b> : <tt>string substringAfterLast(string s, string substr)</tt> <br>
    Returns the substring of s after the last occurrence of substr, or the empty string if s does not contain substr.
<li><b>substringBefore</b> : <tt>string substringBefore(string s, string substr)</tt> <br>
    Returns the substring of s before the first occurrence of substr, or the empty string if s does not contain substr.
<li><b>substringBeforeLast</b> : <tt>string substringBeforeLast(string s, string substr)</tt> <br>
    Returns the substring of s before the last occurrence of substr, or the empty string if s does not contain substr.
<li><b>tail</b> : <tt>string tail(string s, int len)</tt> <br>
    Returns the last len character of s, or the full s if it is shorter than len characters.
<li><b>toLower</b> : <tt>string toLower(string s)</tt> <br>
    Converts s to all lowercase, and returns the result.
<li><b>toUpper</b> : <tt>string toUpper(string s)</tt> <br>
    Converts s to all uppercase, and returns the result.
<li><b>trim</b> : <tt>string trim(string s)</tt> <br>
    Discards whitespace from the start and end of s, and returns the result.

<p></dl>

<p><p class="subheading">Category "units":</p>

<p><dl>
<li><b>convertUnit</b> : <tt>quantity convertUnit(quantity x, string unit)</tt> <br>
    Converts x to the given unit.
<li><b>dropUnit</b> : <tt>double dropUnit(quantity x)</tt> <br>
    Removes the unit of measurement from quantity x.
<li><b>replaceUnit</b> : <tt>quantity replaceUnit(quantity x, string unit)</tt> <br>
    Replaces the unit of x with the given unit.
<li><b>unitOf</b> : <tt>string unitOf(quantity x)</tt> <br>
    Returns the unit of the given quantity.

<p></dl>

<p><p class="subheading">Category "xml":</p>

<p><dl>
<li><b>xml</b> : <tt>xml xml(string xmlstring, string xpath?)</tt> <br>
    Parses the given XML string into a <a href="../api/classcXMLElement.html">cXMLElement</a> tree, and returns the root element. When called with two arguments, it returns the first element from the tree that matches the expression given in simplified XPath syntax.
<li><b>xmldoc</b> : <tt>xml xmldoc(string filename, string xpath?)</tt> <br>
    Parses the given XML file into a <a href="../api/classcXMLElement.html">cXMLElement</a> tree, and returns the root element. When called with two arguments, it returns the first element from the tree that matches the expression given in simplified XPath syntax.
</dl>

<hr class='pgbr'><h1><a name="sec562"/>23 Appendix&#58; Message Definitions Grammar</h1>
<a name="cha:msg-language-grammar"></a>

<p>This appendix contains the grammar for the message definitions
language.

<p>In the language, space, horizontal tab and new line characters count
as delimiters, so one or more of them is required between two elements of the
description which would otherwise be unseparable.

<p>'//' (two slashes) may be used to write comments that last to the end of the line.

<p>The language is fully case sensitive.

<p>Notation:
<ul>
  <li>rule syntax is that of <i>bison</i>/<i>yacc</i>
  <li>uppercase words are terminals, lowercase words are nonterminals
  <li><tt>NAME</tt>, <tt>CHARCONSTANT</tt>, <tt>STRINGCONSTANT</tt>, <tt>INTCONSTANT</tt>,
        <tt>REALCONSTANT</tt> represent identifier names and string, character,
        integer and real number literals (defined as in the C language)
  <li>other terminals represent keywords in all lowercase
</ul>

<p>Nonterminals ending in <tt>_old</tt> are present so that message files
from the previous versions of OMNeT++ (3.x) can be parsed.


<pre class="verbatim">
msgfile
        : definitions
        ;

definitions
        : definitions definition
        |
        ;

definition
        : namespace_decl
        | cplusplus
        | struct_decl
        | class_decl
        | message_decl
        | packet_decl
        | enum_decl
        | enum
        | message
        | packet
        | class
        | struct
        ;

namespace_decl
        : NAMESPACE qname0 ';'

qname0
        : qname0 DOUBLECOLON NAME
        | NAME
        ;

qname
        : DOUBLECOLON qname0
        | qname0
        ;

cplusplus
        : CPLUSPLUS '{{' ... '}}' opt_semicolon
        ;

struct_decl
        : STRUCT qname ';'
        ;

class_decl
        : CLASS qname ';'
        | CLASS NONCOBJECT qname ';'
        | CLASS qname EXTENDS qname ';'
        ;

message_decl
        : MESSAGE qname ';'
        ;

packet_decl
        : PACKET qname ';'
        ;

enum_decl
        : ENUM qname ';'
        ;

enum
        : ENUM NAME '{'
          opt_enumfields '}' opt_semicolon
        ;

opt_enumfields
        : enumfields
        |
        ;

enumfields
        : enumfields enumfield
        | enumfield
        ;

enumfield
        : NAME ';'
        | NAME '=' enumvalue ';'
        ;

message
        : message_header body
        ;

packet
        : packet_header body
        ;

class
        : class_header body
        ;

struct
        : struct_header body
        ;

message_header
        : MESSAGE NAME '{'
        | MESSAGE NAME EXTENDS qname '{'
        ;

packet_header
        : PACKET NAME '{'
        | PACKET NAME EXTENDS qname '{'
        ;

class_header
        : CLASS NAME '{'
        | CLASS NAME EXTENDS qname '{'
        ;

struct_header
        : STRUCT NAME '{'
        | STRUCT NAME EXTENDS qname '{'
        ;

body
        : opt_fields_and_properties
          opt_propertiesblock_old
          opt_fieldsblock_old
          '}' opt_semicolon
        ;

opt_fields_and_properties
        : fields_and_properties
        |
        ;

fields_and_properties
        : fields_and_properties field
        | fields_and_properties property
        | field
        | property
        ;

field
        :  fieldtypename opt_fieldvector opt_inline_properties ';'
        |  fieldtypename opt_fieldvector opt_inline_properties '=' fieldvalue opt_inline_properties ';'
        ;

fieldtypename
        : fieldmodifiers fielddatatype NAME
        | fieldmodifiers NAME
        ;

fieldmodifiers
        : ABSTRACT
        | READONLY
        | ABSTRACT READONLY
        | READONLY ABSTRACT
        |
        ;

fielddatatype
        : qname
        | qname '*'
        | CHAR
        | SHORT
        | INT
        | LONG
        | UNSIGNED CHAR
        | UNSIGNED SHORT
        | UNSIGNED INT
        | UNSIGNED LONG
        | DOUBLE
        | STRING
        | BOOL
        ;

opt_fieldvector
        : '[' INTCONSTANT ']'
        | '[' qname ']'
        | '[' ']'
        |
        ;

fieldvalue
        : fieldvalue fieldvalueitem
        | fieldvalueitem
        ;

fieldvalueitem
        : STRINGCONSTANT
        | CHARCONSTANT
        | INTCONSTANT
        | REALCONSTANT
        | TRUE
        | FALSE
        | NAME
        | DOUBLECOLON
        | '?' | ':' | '&&' | '||' | '##' | '==' | '!=' | '&gt;' | '&gt;=' | '&lt;' | '&lt;='
        | '&' | '|' | '#' | '&lt;&lt;' | '&gt;&gt;'
        | '+' | '-' | '*' | '/' | '%' | '^' | '&' | UMIN | '!' | '~'
        | '.' | ',' | '(' | ')' | '[' | ']'
        ;

enumvalue
        : INTCONSTANT
        | '-' INTCONSTANT
        | NAME
        ;

opt_inline_properties
        : inline_properties
        |
        ;

inline_properties
        : inline_properties property_namevalue
        | property_namevalue
        ;

property
        : property_namevalue ';'
        ;

property_namevalue
        : property_name
        | property_name '(' opt_property_keys ')'
        | ENUM '(' NAME ')'
        ;

property_name
        : '@' PROPNAME
        | '@' PROPNAME '[' PROPNAME ']'
        ;

opt_property_keys
        : property_keys
        ;

property_keys
        : property_keys ';' property_key
        | property_key
        ;

property_key
        : property_literal '=' property_values
        | property_values
        ;

property_values
        : property_values ',' property_value
        | property_value
        ;

property_value
        : property_literal
        |
        ;

property_literal
        : property_literal CHAR
        | property_literal STRINGCONSTANT
        | CHAR
        | STRINGCONSTANT
        ;

opt_fieldsblock_old
        : FIELDS ':'
          opt_fields_old
        |
        ;

opt_fields_old
        : fields_old
        |
        ;

fields_old
        : fields_old field
        | field
        ;

opt_propertiesblock_old
        : PROPERTIES ':'
          opt_properties_old
        |
        ;

opt_properties_old
        : properties_old
        |
        ;

properties_old
        : properties_old property_old
        | property_old
        ;

property_old
        : NAME '=' property_value ';'
        ;

opt_semicolon : ';' | ;
</pre>

<p>
<hr class='pgbr'><h1><a name="sec563"/>24 Appendix&#58; Display String Tags</h1>
<a name="cha:display-string-tags"></a>

<p><h2><a name="sec564"/>24.1 Module and Connection Display String Tags</h2>

<p>Supported module and connection display string tags are listed in the following table.


<table border>
<TR> <TD align=left>

<p><b>Tag[argument index] - name</b> </TD> <TD align=left> <b>Description</b>
</TD></TR>
<TR> <TD align=left>
<b>p</b>[0] - x
</TD> <TD align=left>
X position of the center of the icon/shape; defaults to automatic graph layouting
</TD></TR>
<TR> <TD align=left>
<b>p</b>[1] - y
</TD> <TD align=left>
Y position of the center of the icon/shape; defaults to automatic graph layouting
</TD></TR>
<TR> <TD align=left>
<b>p</b>[2] - arrangement
</TD> <TD align=left>
Arrangement of submodule vectors. Values: row (r), column (c), matrix (m), ring (ri), exact (x)
</TD></TR>
<TR> <TD align=left>
<b>p</b>[3] - arr. par1
</TD> <TD align=left>
Depends on arrangement: matrix =&gt; ncols, ring =&gt; rx, exact =&gt; dx, row =&gt; dx, column =&gt; dy
</TD></TR>
<TR> <TD align=left>
<b>p</b>[4] - arr. par2
</TD> <TD align=left>
Depends on arrangement: matrix =&gt; dx, ring =&gt; ry, exact =&gt; dy
</TD></TR>
<TR> <TD align=left>
<b>p</b>[5] - arr. par3
</TD> <TD align=left>
Depends on arrangement: matrix =&gt; dy
</TD></TR>
<TR> <TD align=left>
<b>b</b>[0] - width
</TD> <TD align=left>
Width of object. Default: 40
</TD></TR>
<TR> <TD align=left>
<b>b</b>[1] - height
</TD> <TD align=left>
Height of object. Default: 24
</TD></TR>
<TR> <TD align=left>
<b>b</b>[2] - shape
</TD> <TD align=left>
Shape of object. Values: rectangle (rect), oval (oval). Default: rect
</TD></TR>
<TR> <TD align=left>
<b>b</b>[3] - fill color
</TD> <TD align=left>
Fill color of the object (colorname or #RRGGBB or @HHSSBB). Default: #8080ff
</TD></TR>
<TR> <TD align=left>
<b>b</b>[4] - border color
</TD> <TD align=left>
Border color of the object (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>b</b>[5] - border width
</TD> <TD align=left>
Border width of the object. Default: 2
</TD></TR>
<TR> <TD align=left>
<b>i</b>[0] - icon
</TD> <TD align=left>
An icon representing the object
</TD></TR>
<TR> <TD align=left>
<b>i</b>[1] - icon color
</TD> <TD align=left>
A color to colorize the icon (colorname or #RRGGBB or @HHSSBB)
</TD></TR>
<TR> <TD align=left>
<b>i</b>[2] - icon colorization %
</TD> <TD align=left>
Amount of colorization in percent. Default: 30
</TD></TR>
<TR> <TD align=left>
<b>is</b>[0] - icon size
</TD> <TD align=left>
The size of the image. Values: very small (vs), small (s), normal (n), large (l), very large (vl)
</TD></TR>
<TR> <TD align=left>
<b>i2</b>[0] - overlay icon
</TD> <TD align=left>
An icon added to the upper right corner of the original image
</TD></TR>
<TR> <TD align=left>
<b>i2</b>[1] - overlay icon color
</TD> <TD align=left>
A color to colorize the overlay icon (colorname or #RRGGBB or @HHSSBB)
</TD></TR>
<TR> <TD align=left>
<b>i2</b>[2] - overlay icon colorization %
</TD> <TD align=left>
Amount of colorization in percent. Default: 30
</TD></TR>
<TR> <TD align=left>
<b>r</b>[0] - range
</TD> <TD align=left>
Radius of the range indicator
</TD></TR>
<TR> <TD align=left>
<b>r</b>[1] - range fill color
</TD> <TD align=left>
Fill color of the range indicator (colorname or #RRGGBB or @HHSSBB)
</TD></TR>
<TR> <TD align=left>
<b>r</b>[2] - range border color
</TD> <TD align=left>
Border color of the range indicator (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>r</b>[3] - range border width
</TD> <TD align=left>
Border width of the range indicator. Default: 1
</TD></TR>
<TR> <TD align=left>
<b>q</b>[0] - queue object
</TD> <TD align=left>
Displays the length of the named queue object
</TD></TR>
<TR> <TD align=left>
<b>t</b>[0] - text
</TD> <TD align=left>
Additional text to display
</TD></TR>
<TR> <TD align=left>
<b>t</b>[1] - text position
</TD> <TD align=left>
Position of the text. Values: left (l), right (r), top (t). Default: t
</TD></TR>
<TR> <TD align=left>
<b>t</b>[2] - text color
</TD> <TD align=left>
Color of the displayed text (colorname or #RRGGBB or @HHSSBB). Default: blue
</TD></TR>
<TR> <TD align=left>
<b>tt</b>[0] - tooltip
</TD> <TD align=left>
Tooltip to be displayed over the object
</TD></TR>
<TR> <TD align=left>
<b>bgp</b>[0] - bg x
</TD> <TD align=left>
Module background horizontal offset
</TD></TR>
<TR> <TD align=left>
<b>bgp</b>[1] - bg y
</TD> <TD align=left>
Module background vertical offset
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[0] - bg width
</TD> <TD align=left>
Width of the module background rectangle
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[1] - bg height
</TD> <TD align=left>
Height of the module background rectangle
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[2] - bg fill color
</TD> <TD align=left>
Background fill color (colorname or #RRGGBB or @HHSSBB). Default: grey82
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[3] - bg border color
</TD> <TD align=left>
Border color of the module background rectangle (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[4] - bg border width
</TD> <TD align=left>
Border width of the module background rectangle. Default: 2
</TD></TR>
<TR> <TD align=left>
<b>bgtt</b>[0] - bg tooltip
</TD> <TD align=left>
Tooltip to be displayed over the module's background
</TD></TR>
<TR> <TD align=left>
<b>bgi</b>[0] - bg image
</TD> <TD align=left>
An image to be displayed as a module background
</TD></TR>
<TR> <TD align=left>
<b>bgi</b>[1] - bg image mode
</TD> <TD align=left>
How to arrange the module's background image. Values: fix (f), tile (t), stretch (s), center (c). Default: fixed
</TD></TR>
<TR> <TD align=left>
<b>bgg</b>[0] - grid tick distance
</TD> <TD align=left>
Distance between two major ticks measured in units
</TD></TR>
<TR> <TD align=left>
<b>bgg</b>[1] - grid minor ticks
</TD> <TD align=left>
Minor ticks per major ticks. Default: 1
</TD></TR>
<TR> <TD align=left>
<b>bgg</b>[2] - grid color
</TD> <TD align=left>
Color of the grid lines (colorname or #RRGGBB or @HHSSBB). Default: grey
</TD></TR>
<TR> <TD align=left>
<b>bgl</b>[0] - layout seed
</TD> <TD align=left>
Seed value for layout algorithm
</TD></TR>
<TR> <TD align=left>
<b>bgl</b>[1] - layout algorithm
</TD> <TD align=left>
Algorithm for child layouting
</TD></TR>
<TR> <TD align=left>
<b>bgs</b>[0] - pixels per unit
</TD> <TD align=left>
Number of pixels per distance unit
</TD></TR>
<TR> <TD align=left>
<b>bgs</b>[1] - unit name
</TD> <TD align=left>
Name of distance unit
</TD></TR>
<TR> <TD align=left>
<b>m</b>[0] - routing constraint
</TD> <TD align=left>
Connection routing constraint. Values: auto (a), south (s), north (n), east (e), west (w)
</TD></TR>
<TR> <TD align=left>
<b>ls</b>[0] - line color
</TD> <TD align=left>
Connection color (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>ls</b>[1] - line width
</TD> <TD align=left>
Connection line width. Default: 1
</TD></TR>
<TR> <TD align=left>
<b>ls</b>[2] - line style
</TD> <TD align=left>
Connection line style. Values: solid (s), dotted (d), dashed (da). Default: solid
</TD></TR>
<TR> <TD align=left>
</table>

<p>

<p>
<h2><a name="sec565"/>24.2 Message Display String Tags</h2>

<p>To customize the appearance of messages in the graphical runtime environment,
override the <tt>getDisplayString()</tt> method of <tt><a href="../api/classcMessage.html">cMessage</a></tt> or
<tt><a href="../api/classcPacket.html">cPacket</a></tt> to return a display string.

<p><table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>oval</b>
</TD> <TD align=left>
 Ellipse with the given <i>height</i> and <i>width</i>.

<p>Defaults: <i>width</i>=10, <i>height</i>=10</TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>rect</b>
</TD> <TD align=left>
 Rectangle with the given <i>height</i> and <i>width</i>.

<p>Defaults: <i>width</i>=10, <i>height</i>=10</TD></TR>
<TR> <TD align=left> <b>o=</b><i>fillcolor</i>,<i>outlinecolor</i>,<i>borderwidth</i>
</TD> <TD align=left>
 Specifies options for the rectangle or oval.
For color notation, see section <a href="#sec390">[11.3]</a>.

<p>Defaults: <i>fillcolor</i>=red, <i>outlinecolor</i>=black,
<i>borderwidth</i>=1</TD></TR>
<TR> <TD align=left> <b>i=</b><i>iconname</i>,<i>color</i>,<i>percentage</i>
</TD> <TD align=left>
 Use the named icon. It can be colorized, and percentage
specifies the amount of colorization. If color name is <tt>"kind"</tt>,
a message kind dependent colors is used (like default behaviour).

<p>Defaults: <i>iconname</i>: no default -- if no icon name is present, a small
red solid circle will be used;
<i>color</i>: no coloring; <i>percentage</i>: 30%</TD></TR>
<TR> <TD align=left> <b>tt=</b><i>tooltip-text</i>
</TD> <TD align=left>
 Displays the given text in a tooltip when the user moves
the mouse over the message icon.</TD></TR>
<TR> <TD align=left> 
</table>

<p>

<p>
<hr class='pgbr'><h1><a name="sec566"/>25 Appendix&#58; Configuration Options</h1>
<a name="cha:config-options"></a>

<p><h2><a name="sec567"/>25.1 Configuration Options</h2>


This section lists all configuration options that are available in ini files.
A similar list can be obtained from any simulation executable by running it
with the <tt>-h configdetails</tt> option.

<pre class="verbatim">
check-signals=&lt;bool&gt;, default:false; per-run setting
    Controls whether the simulation kernel will validate signals emitted by
    modules and channels against signal declarations (@signal properties) in
    NED files.

cmdenv-autoflush=&lt;bool&gt;, default:false; per-run setting
    Call fflush(stdout) after each event banner or status update; affects both
    express and normal mode. Turning on autoflush may have a performance
    penalty, but it can be useful with printf-style debugging for tracking down
    program crashes.

cmdenv-config-name=&lt;string&gt;; global setting
    Specifies the name of the configuration to be run (for a value `Foo',
    section [Config Foo] will be used from the ini file). See also
    cmdenv-runs-to-execute=. The -c command line option overrides this setting.

&lt;object-full-path&gt;.cmdenv-ev-output=&lt;bool&gt;, default:true; per-object setting
    When cmdenv-express-mode=false: whether Cmdenv should print debug messages
    (ev&lt;&lt;) from the selected modules.

cmdenv-event-banner-details=&lt;bool&gt;, default:false; per-run setting
    When cmdenv-express-mode=false: print extra information after event
    banners.

cmdenv-event-banners=&lt;bool&gt;, default:true; per-run setting
    When cmdenv-express-mode=false: turns printing event banners on/off.

cmdenv-express-mode=&lt;bool&gt;, default:true; per-run setting
    Selects &#8220;normal&#8221; (debug/trace) or &#8220;express&#8221; mode.

cmdenv-extra-stack=&lt;double&gt;, unit="B", default:8KiB; global setting
    Specifies the extra amount of stack that is reserved for each activity()
    simple module when the simulation is run under Cmdenv.

cmdenv-interactive=&lt;bool&gt;, default:false; global setting
    Defines what Cmdenv should do when the model contains unassigned
    parameters. In interactive mode, it asks the user. In non-interactive mode
    (which is more suitable for batch execution), Cmdenv stops with an error.

cmdenv-message-trace=&lt;bool&gt;, default:false; per-run setting
    When cmdenv-express-mode=false: print a line per message sending (by
    send(),scheduleAt(), etc) and delivery on the standard output.

cmdenv-module-messages=&lt;bool&gt;, default:true; per-run setting
    When cmdenv-express-mode=false: turns printing module ev&lt;&lt; output on/off.

cmdenv-output-file=&lt;filename&gt;; global setting
    When a filename is specified, Cmdenv redirects standard output into the
    given file. This is especially useful with parallel simulation. See the
    `fname-append-host' option as well.

cmdenv-performance-display=&lt;bool&gt;, default:true; per-run setting
    When cmdenv-express-mode=true: print detailed performance information.
    Turning it on results in a 3-line entry printed on each update, containing
    ev/sec, simsec/sec, ev/simsec, number of messages created/still
    present/currently scheduled in FES.

cmdenv-runs-to-execute=&lt;string&gt;; global setting
    Specifies which runs to execute from the selected configuration (see
    cmdenv-config-name=). It accepts a comma-separated list of run numbers or
    run number ranges, e.g. 1,3..4,7..9. If the value is missing, Cmdenv
    executes all runs in the selected configuration. The -r command line option
    overrides this setting.

cmdenv-status-frequency=&lt;double&gt;, unit="s", default:2s; per-run setting
    When cmdenv-express-mode=true: print status update every n seconds.

configuration-class=&lt;string&gt;; global setting
    Part of the Envir plugin mechanism: selects the class from which all
    configuration information will be obtained. This option lets you replace
    omnetpp.ini with some other implementation, e.g. database input. The
    simulation program still has to bootstrap from an omnetpp.ini (which
    contains the configuration-class setting). The class should implement the
    <a href="../api/classcConfigurationEx.html">cConfigurationEx</a> interface.

constraint=&lt;string&gt;; per-run setting
    For scenarios. Contains an expression that iteration variables (${} syntax)
    must satisfy for that simulation to run. Example: $i &lt; $j+1.

cpu-time-limit=&lt;double&gt;, unit="s"; per-run setting
    Stops the simulation when CPU usage has reached the given limit. The
    default is no limit.

debug-on-errors=&lt;bool&gt;, default:false; global setting
    When set to true, runtime errors will cause the simulation program to break
    into the C++ debugger (if the simulation is running under one, or
    just-in-time debugging is activated). Once in the debugger, you can view
    the stack trace or examine variables.

debug-statistics-recording=&lt;bool&gt;, default:false; per-run setting
    Turns on the printing of debugging information related to statistics
    recording (@statistic properties)

debugger-attach-command=&lt;string&gt;, default:nemiver --attach=%u &; global setting
    Command line to launch the debugger. It must contain exactly one percent
    sign, as '%u', which will be replaced by the PID of this process. The
    command must not block (i.e. it should end in '&' on Unix-like systems).

debugger-attach-on-error=&lt;bool&gt;, default:false; global setting
    When set to true, runtime errors and crashes will trigger an external
    debugger to be launched, allowing you to perform just-in-time debugging on
    the simulation process. The debugger command is configurable. Note that
    debugging (i.e. attaching to) a non-child process needs to be explicitly
    enabled on some systems, e.g. Ubuntu.

debugger-attach-on-startup=&lt;bool&gt;, default:false; global setting
    When set to true, the simulation program will launch an external debugger
    attached to it, allowing you to set breakpoints before proceeding. The
    debugger command is configurable.  Note that debugging (i.e. attaching to)
    a non-child process needs to be explicitly enabled on some systems, e.g.
    Ubuntu.

debugger-attach-wait-time=&lt;double&gt;, unit="s", default:20s; global setting
    An interval to wait after launching the external debugger, to give the
    debugger time to start up and attach to the simulation process.

description=&lt;string&gt;; per-run setting
    Descriptive name for the given simulation configuration. Descriptions get
    displayed in the run selection dialog.

eventlog-file=&lt;filename&gt;, default:${resultdir}/${configname}-${runnumber}.elog; per-run setting
    Name of the eventlog file to generate.

eventlog-message-detail-pattern=&lt;custom&gt;; per-run setting
    A list of patterns separated by '|' character which will be used to write
    message detail information into the eventlog for each message sent during
    the simulation. The message detail will be presented in the sequence chart
    tool. Each pattern starts with an object pattern optionally followed by ':'
    character and a comma separated list of field patterns. In both patterns
    and/or/not/* and various field match expressions can be used. The object
    pattern matches to class name, the field pattern matches to field name by
    default.
      EVENTLOG-MESSAGE-DETAIL-PATTERN := ( DETAIL-PATTERN '|' )* DETAIL_PATTERN
      DETAIL-PATTERN := OBJECT-PATTERN [ ':' FIELD-PATTERNS ]
      OBJECT-PATTERN := MATCH-EXPRESSION
      FIELD-PATTERNS := ( FIELD-PATTERN ',' )* FIELD_PATTERN
      FIELD-PATTERN := MATCH-EXPRESSION
    Examples (enter them without quotes):
      "*": captures all fields of all messages
      "*Frame:*Address,*Id": captures all fields named somethingAddress and
    somethingId from messages of any class named somethingFrame
      "MyMessage:declaredOn(MyMessage)": captures instances of MyMessage
    recording the fields declared on the MyMessage class
      "*:(not declaredOn(<a href="../api/classcMessage.html">cMessage</a>) and not declaredOn(<a href="../api/classcNamedObject.html">cNamedObject</a>) and not
    declaredOn(<a href="../api/classcObject.html">cObject</a>))": records user-defined fields from all messages

eventlog-recording-intervals=&lt;custom&gt;; per-run setting
    Simulation time interval(s) when events should be recorded. Syntax:
    [&lt;from&gt;]..[&lt;to&gt;],... That is, both start and end of an interval are
    optional, and intervals are separated by comma. Example: ..10.2, 22.2..100,
    233.3..

experiment-label=&lt;string&gt;, default:${configname}; per-run setting
    Identifies the simulation experiment (which consists of several,
    potentially repeated measurements). This string gets recorded into result
    files, and may be referred to during result analysis.

extends=&lt;string&gt;; per-run setting
    Name of the configuration this section is based on. Entries from that
    section will be inherited and can be overridden. In other words,
    configuration lookups will fall back to the base section.

fingerprint=&lt;string&gt;; per-run setting
    The expected fingerprint of the simulation. When provided, a fingerprint
    will be calculated from the simulation event times and other quantities
    during simulation, and checked against the given one. Fingerprints are
    suitable for crude regression tests. As fingerprints occasionally differ
    across platforms, more than one fingerprint values can be specified here,
    separated by spaces, and a match with any of them will be accepted. To
    obtain the initial fingerprint, enter a dummy value such as \"0000\"), 
    and run the simulation.

fname-append-host=&lt;bool&gt;; global setting
    Turning it on will cause the host name and process Id to be appended to the
    names of output files (e.g. omnetpp.vec, omnetpp.sca). This is especially
    useful with distributed simulation. The default value is true if parallel
    simulation is enabled, false otherwise.

load-libs=&lt;filenames&gt;; global setting
    A space-separated list of dynamic libraries to be loaded on startup. The
    libraries should be given without the `.dll' or `.so' suffix -- that will
    be automatically appended.

max-module-nesting=&lt;int&gt;, default:50; per-run setting
    The maximum allowed depth of submodule nesting. This is used to catch
    accidental infinite recursions in NED.

measurement-label=&lt;string&gt;, default:${iterationvars}; per-run setting
    Identifies the measurement within the experiment. This string gets recorded
    into result files, and may be referred to during result analysis.

&lt;object-full-path&gt;.module-eventlog-recording=&lt;bool&gt;, default:true; per-object setting
    Enables recording events on a per module basis. This is meaningful for
    simple modules only.
    Example:
     **.router[10..20].**.module-eventlog-recording = true
     **.module-eventlog-recording = false

ned-path=&lt;path&gt;; global setting
    A semicolon-separated list of directories. The directories will be regarded
    as roots of the NED package hierarchy, and all NED files will be loaded
    from their subdirectory trees. This option is normally left empty, as the
    OMNeT++ IDE sets the NED path automatically, and for simulations started
    outside the IDE it is more convenient to specify it via a command-line
    option or the NEDPATH environment variable.

network=&lt;string&gt;; per-run setting
    The name of the network to be simulated.  The package name can be omitted
    if the ini file is in the same directory as the NED file that contains the
    network.

num-rngs=&lt;int&gt;, default:1; per-run setting
    The number of random number generators.

output-scalar-file=&lt;filename&gt;, default:${resultdir}/${configname}-${runnumber}.sca; per-run setting
    Name for the output scalar file.

output-scalar-file-append=&lt;bool&gt;, default:false; per-run setting
    What to do when the output scalar file already exists: append to it
    (OMNeT++ 3.x behavior), or delete it and begin a new file (default).

output-scalar-precision=&lt;int&gt;, default:14; per-run setting
    The number of significant digits for recording data into the output scalar
    file. The maximum value is ~15 (IEEE double precision).

output-vector-file=&lt;filename&gt;, default:${resultdir}/${configname}-${runnumber}.vec; per-run setting
    Name for the output vector file.

output-vector-precision=&lt;int&gt;, default:14; per-run setting
    The number of significant digits for recording data into the output vector
    file. The maximum value is ~15 (IEEE double precision). This setting has no
    effect on the "time" column of output vectors, which are represented as
    fixed-point numbers and always get recorded precisely.

output-vectors-memory-limit=&lt;double&gt;, unit="B", default:16MiB; per-run setting
    Total memory that can be used for buffering output vectors. Larger values
    produce less fragmented vector files (i.e. cause vector data to be grouped
    into larger chunks), and therefore allow more efficient processing later.

outputscalarmanager-class=&lt;string&gt;, default:cFileOutputScalarManager; global setting
    Part of the Envir plugin mechanism: selects the output scalar manager class
    to be used to record data passed to recordScalar(). The class has to
    implement the <a href="../api/classcOutputScalarManager.html">cOutputScalarManager</a> interface.

outputvectormanager-class=&lt;string&gt;, default:cIndexedFileOutputVectorManager; global setting
    Part of the Envir plugin mechanism: selects the output vector manager class
    to be used to record data from output vectors. The class has to implement
    the <a href="../api/classcOutputVectorManager.html">cOutputVectorManager</a> interface.

parallel-simulation=&lt;bool&gt;, default:false; global setting
    Enables parallel distributed simulation.

&lt;object-full-path&gt;.param-record-as-scalar=&lt;bool&gt;, default:false; per-object setting
    Applicable to module parameters: specifies whether the module parameter
    should be recorded into the output scalar file. Set it for parameters whose
    value you'll need for result analysis.

parsim-communications-class=&lt;string&gt;, default:cFileCommunications; global setting
    If parallel-simulation=true, it selects the class that implements
    communication between partitions. The class must implement the
    <a href="../api/classcParsimCommunications.html">cParsimCommunications</a> interface.

parsim-debug=&lt;bool&gt;, default:true; global setting
    With parallel-simulation=true: turns on printing of log messages from the
    parallel simulation code.

parsim-filecommunications-prefix=&lt;string&gt;, default:comm/; global setting
    When cFileCommunications is selected as parsim communications class:
    specifies the prefix (directory+potential filename prefix) for creating the
    files for cross-partition messages.

parsim-filecommunications-preserve-read=&lt;bool&gt;, default:false; global setting
    When cFileCommunications is selected as parsim communications class:
    specifies that consumed files should be moved into another directory
    instead of being deleted.

parsim-filecommunications-read-prefix=&lt;string&gt;, default:comm/read/; global setting
    When cFileCommunications is selected as parsim communications class:
    specifies the prefix (directory) where files will be moved after having
    been consumed.

parsim-idealsimulationprotocol-tablesize=&lt;int&gt;, default:100000; global setting
    When cIdealSimulationProtocol is selected as parsim synchronization class:
    specifies the memory buffer size for reading the ISP event trace file.

parsim-mpicommunications-mpibuffer=&lt;int&gt;; global setting
    When cMPICommunications is selected as parsim communications class:
    specifies the size of the MPI communications buffer. The default is to
    calculate a buffer size based on the number of partitions.

parsim-namedpipecommunications-prefix=&lt;string&gt;, default:comm/; global setting
    When cNamedPipeCommunications is selected as parsim communications class:
    selects the prefix (directory+potential filename prefix) where name pipes
    are created in the file system.

parsim-nullmessageprotocol-laziness=&lt;double&gt;, default:0.5; global setting
    When cNullMessageProtocol is selected as parsim synchronization class:
    specifies the laziness of sending null messages. Values in the range [0,1)
    are accepted. Laziness=0 causes null messages to be sent out immediately as
    a new EOT is learned, which may result in excessive null message traffic.

parsim-nullmessageprotocol-lookahead-class=&lt;string&gt;, default:cLinkDelayLookahead; global setting
    When cNullMessageProtocol is selected as parsim synchronization class:
    specifies the C++ class that calculates lookahead. The class should
    subclass from cNMPLookahead.

parsim-synchronization-class=&lt;string&gt;, default:cNullMessageProtocol; global setting
    If parallel-simulation=true, it selects the parallel simulation algorithm.
    The class must implement the cParsimSynchronizer interface.

&lt;object-full-path&gt;.partition-id=&lt;string&gt;; per-object setting
    With parallel simulation: in which partition the module should be
    instantiated. Specify numeric partition ID, or a comma-separated list of
    partition IDs for compound modules that span across multiple partitions.
    Ranges ("5..9") and "*" (=all) are accepted too.

print-undisposed=&lt;bool&gt;, default:true; global setting
    Whether to report objects left (that is, not deallocated by simple module
    destructors) after network cleanup.

realtimescheduler-scaling=&lt;double&gt;; global setting
    When <a href="../api/classcRealTimeScheduler.html">cRealTimeScheduler</a> is selected as scheduler class: ratio of simulation
    time to real time. For example, scaling=2 will cause simulation time to
    progress twice as fast as runtime.

record-eventlog=&lt;bool&gt;, default:false; per-run setting
    Enables recording an eventlog file, which can be later visualized on a
    sequence chart. See eventlog-file= option too.

repeat=&lt;int&gt;, default:1; per-run setting
    For scenarios. Specifies how many replications should be done with the same
    parameters (iteration variables). This is typically used to perform
    multiple runs with different random number seeds. The loop variable is
    available as ${repetition}. See also: seed-set= key.

replication-label=&lt;string&gt;, default:#${repetition}; per-run setting
    Identifies one replication of a measurement (see repeat= and
    measurement-label= as well). This string gets recorded into result files,
    and may be referred to during result analysis.

result-dir=&lt;string&gt;, default:results; per-run setting
    Value for the ${resultdir} variable, which is used as the default directory
    for result files (output vector file, output scalar file, eventlog file,
    etc.)

&lt;object-full-path&gt;.result-recording-modes=&lt;string&gt;, default:default; per-object setting
    Defines how to calculate results from the @statistic property matched by
    the wildcard. Special values: default, all: they select the modes listed in
    the record= key of @statistic; all selects all of them, default selects the
    non-optional ones (i.e. excludes the ones that end in a question mark).
    Example values: vector, count, last, sum, mean, min, max, timeavg, stats,
    histogram. More than one values are accepted, separated by commas.
    Expressions are allowed. Items prefixed with '-' get removed from the list.
    Example: **.queueLength.result-recording-modes=default,-vector,+timeavg

&lt;object-full-path&gt;.rng-%=&lt;int&gt;; per-object setting
    Maps a module-local RNG to one of the global RNGs. Example: **.gen.rng-1=3
    maps the local RNG 1 of modules matching `**.gen' to the global RNG 3. The
    default is one-to-one mapping.

rng-class=&lt;string&gt;, default:<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>; per-run setting
    The random number generator class to be used. It can be `<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>',
    `<a href="../api/classcLCG32.html">cLCG32</a>', `cAkaroaRNG', or you can use your own RNG class (it must be
    subclassed from <a href="../api/classcRNG.html">cRNG</a>).

runnumber-width=&lt;int&gt;, default:0; per-run setting
    Setting a nonzero value will cause the $runnumber variable to get padded
    with leading zeroes to the given length.

&lt;object-full-path&gt;.scalar-recording=&lt;bool&gt;, default:true; per-object setting
    Whether the matching output scalars should be recorded. Syntax:
    &lt;module-full-path&gt;.&lt;scalar-name&gt;.scalar-recording=true/false. Example:
    **.queue.packetsDropped.scalar-recording=true

scheduler-class=&lt;string&gt;, default:<a href="../api/classcSequentialScheduler.html">cSequentialScheduler</a>; global setting
    Part of the Envir plugin mechanism: selects the scheduler class. This
    plugin interface allows for implementing real-time, hardware-in-the-loop,
    distributed and distributed parallel simulation. The class has to implement
    the <a href="../api/classcScheduler.html">cScheduler</a> interface.

sectionbasedconfig-configreader-class=&lt;string&gt;; global setting
    When configuration-class=SectionBasedConfiguration: selects the
    configuration reader C++ class, which must subclass from
    <a href="../api/classcConfigurationReader.html">cConfigurationReader</a>.

seed-%-lcg32=&lt;int&gt;; per-run setting
    When <a href="../api/classcLCG32.html">cLCG32</a> is selected as random number generator: seed for the kth RNG.
    (Substitute k for '%' in the key.)

seed-%-mt=&lt;int&gt;; per-run setting
    When Mersenne Twister is selected as random number generator (default):
    seed for RNG number k. (Substitute k for '%' in the key.)

seed-%-mt-p%=&lt;int&gt;; per-run setting
    With parallel simulation: When Mersenne Twister is selected as random
    number generator (default): seed for RNG number k in partition number p.
    (Substitute k for the first '%' in the key, and p for the second.)

seed-set=&lt;int&gt;, default:${runnumber}; per-run setting
    Selects the kth set of automatic random number seeds for the simulation.
    Meaningful values include ${repetition} which is the repeat loop counter
    (see repeat= key), and ${runnumber}.

sim-time-limit=&lt;double&gt;, unit="s"; per-run setting
    Stops the simulation when simulation time reaches the given limit. The
    default is no limit.

simtime-scale=&lt;int&gt;, default:-12; global setting
    Sets the scale exponent, and thus the resolution of time for the 64-bit
    fixed-point simulation time representation. Accepted values are -18..0; for
    example, -6 selects microsecond resolution. -12 means picosecond
    resolution, with a maximum simtime of ~110 days.

snapshot-file=&lt;filename&gt;, default:${resultdir}/${configname}-${runnumber}.sna; per-run setting
    Name of the snapshot file.

snapshotmanager-class=&lt;string&gt;, default:cFileSnapshotManager; global setting
    Part of the Envir plugin mechanism: selects the class to handle streams to
    which snapshot() writes its output. The class has to implement the
    <a href="../api/classcSnapshotManager.html">cSnapshotManager</a> interface.

tkenv-default-config=&lt;string&gt;; global setting
    Specifies which config Tkenv should set up automatically on startup. The
    default is to ask the user.

tkenv-default-run=&lt;int&gt;, default:0; global setting
    Specifies which run (of the default config, see tkenv-default-config) Tkenv
    should set up automatically on startup. The default is to ask the user.

tkenv-extra-stack=&lt;double&gt;, unit="B", default:48KiB; global setting
    Specifies the extra amount of stack that is reserved for each activity()
    simple module when the simulation is run under Tkenv.

tkenv-image-path=&lt;path&gt;; global setting
    Specifies the path for loading module icons.

tkenv-plugin-path=&lt;path&gt;; global setting
    Specifies the search path for Tkenv plugins. Tkenv plugins are .tcl files
    that get evaluated on startup.

total-stack=&lt;double&gt;, unit="B"; global setting
    Specifies the maximum memory for activity() simple module stacks. You need
    to increase this value if you get a &#8220;Cannot allocate coroutine stack&#8221;
    error.

&lt;object-full-path&gt;.typename=&lt;string&gt;; per-object setting
    Specifies type for submodules and channels declared with 'like &lt;&gt;'.

user-interface=&lt;string&gt;; global setting
    Selects the user interface to be started. Possible values are Cmdenv and
    Tkenv. This option is normally left empty, as it is more convenient to
    specify the user interface via a command-line option or the IDE's Run and
    Debug dialogs. New user interfaces can be defined by subclassing
    <a href="../api/classcRunnableEnvir.html">cRunnableEnvir</a>.

&lt;object-full-path&gt;.vector-max-buffered-values=&lt;int&gt;; per-object setting
    For output vectors: the maximum number of values to buffer per vector,
    before writing out a block into the output vector file. The default is no
    per-vector limit (i.e. only the total memory limit is in effect)

&lt;object-full-path&gt;.vector-record-eventnumbers=&lt;bool&gt;, default:true; per-object setting
    Whether to record event numbers for an output vector. Simulation time and
    value are always recorded. Event numbers are needed by the Sequence Chart
    Tool, for example.

&lt;object-full-path&gt;.vector-recording=&lt;bool&gt;, default:true; per-object setting
    Whether data written into an output vector should be recorded.

&lt;object-full-path&gt;.vector-recording-intervals=&lt;custom&gt;; per-object setting
    Recording interval(s) for an output vector. Syntax: [&lt;from&gt;]..[&lt;to&gt;],...
    That is, both start and end of an interval are optional, and intervals are
    separated by comma. Example: ..100, 200..400, 900..

warmup-period=&lt;double&gt;, unit="s"; per-run setting
    Length of the initial warm-up period. When set, results belonging to the
    first x seconds of the simulation will not be recorded into output vectors,
    and will not be counted into output scalars (see option
    **.result-recording-modes). This option is useful for steady-state
    simulations. The default is 0s (no warmup period). Note that models that
    compute and record scalar results manually (via recordScalar()) will not
    automatically obey this setting.

warnings=&lt;bool&gt;, default:true; per-run setting
    Enables warnings.

&lt;object-full-path&gt;.with-akaroa=&lt;bool&gt;, default:false; per-object setting
    Whether to the output vector should be under Akaroa control.
</pre>
<p>

<p><h2><a name="sec568"/>25.2 Predefined Configuration Variables</h2>

<p>Predefined variables that can be used in config values:

<pre class="verbatim">
${runid}
    A reasonably globally unique identifier for the run, produced by
    concatenating the configuration name, run number, date/time, etc.
${inifile}
    Name of the (primary) inifile
${configname}
    Name of the active configuration
${runnumber}
    Sequence number of the current run within all runs in the active
    configuration
${network}
    Value of the "network" configuration option
${experiment}
    Value of the "experiment-label" configuration option
${measurement}
    Value of the "measurement-label" configuration option
${replication}
    Value of the "replication-label" configuration option
${processid}
    PID of the simulation process
${datetime}
    Date and time the simulation run was started
${resultdir}
    Value of the "result-dir" configuration option
${repetition}
    The iteration number in 0..N-1, where N is the value of the "repeat"
    configuration option
${seedset}
    Value of the "seed-set" configuration option
${iterationvars}
    Concatenation of all user-defined iteration variables in name=value form
${iterationvars2}
    Concatenation of all user-defined iteration variables in name=value form,
    plus ${repetition}
</pre>
<p>
<hr class='pgbr'><h1><a name="sec569"/>26 Appendix&#58; Result File Formats</h1>
<a name="cha:result-file-formats"></a>

<p>The file format described here applies to <i>both output vector and
output scalar files</i>. Their formats are consistent, only the types of
entries occurring in them are different. This unified format also
means that they can be read with a common routine.

<p>Result files are <i>line oriented</i>. A line consists of one or more
tokens, separated by whitespace. Tokens either do not
contain whitespace, or whitespace is escaped using a backslash, or
are quoted using double quotes. Escaping within quotes using
backslashes is also permitted.

<p>The first token of a line usually identifies the type of the entry. A
notable exception is an output vector data line, which begins with a
numeric identifier of the given output vector.

<p>A line starting with # as the first non-whitespace character denotes
a comment, and is to be ignored during processing.

<p>Result files are written from simulation runs. A simulation run
generates physically contiguous sets of lines into one or more result
files. (That is, lines from different runs do not arbitrarily mix in
the files.)

<p>A run is identified by a unique textual <i>runId</i>, which appears in
all result files written during that run. The runId may appear on the
user interface, so it should be somewhat meaningful to the user.
Nothing should be assumed about the particular format of runId, but it
will be some string concatenated from the simulated network's name, the
time/date, the hostname, and other pieces of data to make it unique.

<p>A simulation run will typically write into two result files (.vec and
.sca). However, when using parallel distributed simulation, the user
will end up with several .vec and .sca files, because different
partitions (a separate process each) will write into different files.
However, all these files will contain the same runId, so it is possible
to relate data that belong together.

<p>Entry types are:

<p><ul>
    <li> <b>version</b>: result file version
    <li> <b>run</b>: simulation run identifier
    <li> <b>attr</b>: run, vector, scalar or statistics object attribute
    <li> <b>param</b>: module parameter
    <li> <b>scalar</b>: scalar data
    <li> <b>vector</b>: vector declaration
    <li> <i>vector-id</i>: vector data
    <li> <b>file</b>: vector file attributes
    <li> <b>statistic</b>: statistics object
    <li> <b>field</b>: field of a statistics object
    <li> <b>bin</b>: histogram bin
</ul>

<p>

<p><h2><a name="sec570"/>26.1 Version</h2>

<p>Specifies the format of the result file. It is written at the beginning of the file.

<p>Syntax:

<p> <b>version</b> <i>versionNumber</i>

<p>The version described in this document is 2. Version 1 files are produced
by OMNeT++ 3.3 or earlier.

<p>

<p><h2><a name="sec571"/>26.2 Run Declaration</h2>

<p>Marks the beginning of a new run in the file. Entries after this line
belong to this run.

<p>Syntax:

<p> <b>run</b> <i>runId</i>

<p>Example:

<pre class="filelisting">
run TokenRing1-0-20080514-18:19:44-3248
</pre>
<p>
Typically there will be one run per file, but this is not mandatory.
In cases when there are more than one run in a file and it is not feasible
to keep the entire file in memory during analysis, the offsets of the <i>run</i>
lines may be indexed for more efficient random access.

<p>The <i>run</i> line may be immediately followed by <i>attribute</i> lines.
Attributes may store generic data like the network name, date/time of running
the simulation, configuration options that took effect for the simulation, etc.

<p>Run attribute names used by OMNeT++ include the following:

<p>Generic attribute names:

<p><ul>
    <li> <b>network</b>: name of the network simulated
    <li> <b>datetime</b>: date/time associated with the run
    <li> <b>processid</b>: the PID of the simulation process
    <li> <b>inifile</b>: the main configuration file
    <li> <b>configname</b>: name of the inifile configuration
    <li> <b>seedset</b>: index of the seed-set use for the simulation
</ul>

<p>Attributes associated with parameter studies (iterated runs):

<p><ul>
    <li> <b>runnumber</b>: the run number within the parameter study
    <li> <b>experiment</b>: experiment label
    <li> <b>measurement</b>: measurement label
    <li> <b>replication</b>: replication label
    <li> <b>repetition</b>: the loop counter for repetitions with different seeds
    <li> <b>iterationvars</b>: string containing the values of the iteration variables
    <li> <b>iterationvars2</b>: string containing the values of the iteration variables
</ul>

<p>
An example run header:

<pre class="filelisting">
run TokenRing1-0-20080514-18:19:44-3248
attr configname TokenRing1
attr datetime 20080514-18:19:44
attr experiment TokenRing1
attr inifile omnetpp.ini
attr iterationvars ""
attr iterationvars2 $repetition=0
attr measurement ""
attr network TokenRing
attr processid 3248
attr repetition 0
attr replication #0
attr resultdir results
attr runnumber 0
attr seedset 0
</pre>
<p>

<p>
<h2><a name="sec572"/>26.3 Attributes</h2>

<p>Contains an attribute for the preceding run, vector, scalar or
statistics object. Attributes can be used for saving arbitrary
extra information for objects; processors should ignore unrecognized
attributes.

<p>Syntax:

<p> <b>attr</b> <i>name</i> <i>value</i>

<p>Example:

<pre class="filelisting">
attr network "largeNet"
</pre>
<p>

<p>
<h2><a name="sec573"/>26.4 Module Parameters</h2>

<p>Contains a module parameter value for the given run. This is needed so
that module parameters may be included in the analysis (e.g. to
identify the load for a &#8220;throughput vs load&#8221; plot).

<p>It may not be practical to simply store all parameters of all modules in the
result file, because there may be too many. We assume that NED files are
invariant and do not store parameters defined in them. However, we store
parameter assignments that come from <tt>omnetpp.ini</tt>, in their original
wildcard form (i.e. not expanded) to conserve space. Parameter values
entered interactively by the user are also stored.

<p>When the original NED files are present, it should thus be possible to
reconstruct all parameters for the given simulation.

<p>Syntax:

<p> <b>param</b> <i>parameterNamePattern</i> <i>value</i>

<p>Example:

<pre class="filelisting">
param **.gen.sendIaTime  exponential(0.01)
param **.gen.msgLength   10
param **.fifo.bitsPerSec 1000
</pre>
<p>

<p><h2><a name="sec574"/>26.5 Scalar Data</h2>

<p>Contains an output scalar value.

<p>Syntax:

<p> <b>scalar</b> <i>moduleName</i> <i>scalarName</i> <i>value</i>

<p>Examples:

<pre class="filelisting">
scalar "net.switchA.relay" "processed frames" 100
</pre>
<p>
Scalar lines may be immediately followed by <i>attribute</i> lines.
OMNeT++ uses the following attributes for scalars:

<p><ul>
    <li> <b>title</b>: suggested title on charts
    <li> <b>unit</b>: measurement unit, e.g. <tt>s</tt> for seconds
</ul>

<p>

<p><h2><a name="sec575"/>26.6 Vector Declaration</h2>

<p>Defines an output vector.

<p>Syntax:

<p> <b>vector</b> <i>vectorId</i> <i>moduleName</i> <i>vectorName</i>

<p> <b>vector</b> <i>vectorId</i> <i>moduleName</i> <i>vectorName</i> <i>columnSpec</i>

<p>Where <i>columnSpec</i> is a string, encoding the meaning and ordering
the columns of data lines. Characters of the string mean:

<p><ul>
  <li> <b>E</b> event number
  <li> <b>T</b> simulation time
  <li> <b>V</b> vector value
</ul>

<p>Common values are <tt>TV</tt> and <tt>ETV</tt>. The default value is <tt>TV</tt>.

<p>Vector lines may be immediately followed by <i>attribute</i> lines.
OMNeT++ uses the following attributes for vectors:

<p><ul>
    <li> <b>title</b>: suggested vector title on charts
    <li> <b>unit</b>: measurement unit, e.g. <tt>s</tt> for seconds
    <li> <b>enum</b>: symbolic names for values of the vector;
          syntax is <tt>"IDLE=0, BUSY=1, OFF=2"</tt>
    <li> <b>type</b>: data type, one of <tt>int</tt>, <tt>double</tt> and <tt>enum</tt>
    <li> <b>interpolationmode</b>: hint for interpolation mode on the
          chart: <tt>none</tt> (=do not connect the dots), <tt>sample-hold</tt>,
          <tt>backward-sample-hold</tt>, <tt>linear</tt>
    <li> <b>min</b>: minimum value
    <li> <b>max</b>: maximum value
</ul>

<p>

<p>
<h2><a name="sec576"/>26.7 Vector Data</h2>

<p>Adds a value to an output vector. This is the same as in older output
vector files.

<p>Syntax:

<p> <i>vectorId</i> <i>column1</i> <i>column2</i> ...

<p>Simulation times and event numbers <i>within an output vector</i> are
required to be in increasing order.

<p>Performance note: Data lines belonging to the same output vector may be
written out in clusters (of size roughly a multiple of the disk's
physical block size). Then, since an output vector file is typically
not kept in memory during analysis, indexing the start offsets of these
clusters allows one to read the file and seek in it more efficiently.
This does not require any change or extension to the file format.

<p><h2><a name="sec577"/>26.8 Index Header</h2>

<p>The first line of the index file stores the size and modification date
of the vector file. If the attributes of a vector file differ from
the information stored in the index file, then the IDE automatically
rebuilds the index file.

<p>Syntax:

<p> <b>file</b> <i>filesize</i> <i>modificationDate</i>

<p><h2><a name="sec578"/>26.9 Index Data</h2>

<p>Stores the location and statistics of blocks in the vector file.

<p>Syntax:

<p> <i>vectorId offset length firstEventNo lastEventNo
                       firstSimtime lastSimtime count min max sum sqrsum</i>

<p>where

<p><ul>
    <li><i>offset</i>: the start offset of the block
    <li><i>length</i>: the length of the block
    <li><i>firstEventNo</i>, <i>lastEventNo</i>:
        the event number range of the block (optional)
    <li><i>firstSimtime</i>, <i>lastSimtime</i>:
        the simtime range of the block
    <li><i>count, min, max, sum, sqrsum</i>:
        collected statistics of the values in the block

<p></ul>

<p><h2><a name="sec579"/>26.10 Statistics Object</h2>

<p>Represents a statistics object.

<p>Syntax:

<p> <b>statistic</b> <i>moduleName</i> <i>statisticName</i>

<p>Example:

<pre class="filelisting">
statistic Aloha.server 	"collision multiplicity"
</pre>
<p>
A <i>statistic</i> line may be followed by <i>field</i> and <i>attribute</i> lines,
and a series of <i>bin</i> lines that represent histogram data.

<p>OMNeT++ uses the following attributes:

<p><ul>
    <li> <b>title</b>: suggested title on charts
    <li> <b>unit</b>: measurement unit, e.g. <tt>s</tt> for seconds
    <li> <b>type</b>: type of the collected values: <tt>int</tt> or <tt>double</tt>; 
                         the default is <tt>double</tt>
</ul>

<p>A full example with fields, attributes and histogram bins:

<pre class="filelisting">
statistic Aloha.server 	"collision multiplicity"
field count 13908
field mean 6.8510209951107
field stddev 5.2385484477843
field sum 95284
field sqrsum 1034434
field min 2
field max 65
attr type int
attr unit packets
bin	-INF	0
bin	0	0
bin	1	0
bin	2	2254
bin	3	2047
bin	4	1586
bin	5	1428
bin	6	1101
bin	7	952
bin	8	785
...
bin	52	2
</pre>
<p>

<p><h2><a name="sec580"/>26.11 Field</h2>

<p>Represents a field in a statistics object.

<p>Syntax:

<p> <b>field</b> <i>fieldName</i> <i>value</i>

<p>Example:

<pre class="filelisting">
field sum 95284
</pre>
<p>
Fields:

<p><ul>
    <li> <b>count</b>: observation count
    <li> <b>mean</b>: mean of the observations
    <li> <b>stddev</b>: standard deviation
    <li> <b>sum</b>: sum of the observations
    <li> <b>sqrsum</b>: sum of the squared observations
    <li> <b>min</b>: minimum of the observations
    <li> <b>max</b>: maximum of the observations
</ul>

<p>For weighted statistics, additionally the following fields may be recorded:

<p><ul>
    <li> <b>weights</b>: sum of the weights
    <li> <b>weightedSum</b>: the weighted sum of the observations
    <li> <b>sqrSumWeights</b>:  sum of the squared weights
    <li> <b>weightedSqrSum</b>: weighted sum of the squared observations
</ul>

<p>

<p><h2><a name="sec581"/>26.12 Histogram Bin</h2>

<p>Represents a bin in a histogram object.

<p>Syntax:

<p> <b>bin</b> <i>binLowerBound</i> <i>value</i>

<p>Histogram name and module is defined on the <b>statistic</b> line,
which is followed by several <b>bin</b> lines to contain data. Any
non-<b>bin</b> line marks the end of the histogram data.

<p>The <i>binLowerBound</i> column of <b>bin</b> lines represent the
(inclusive) lower bound of the given histogram cell. <b>Bin</b> lines are in
increasing <i>binLowerBound</i> order.

<p>The <i>value</i> column of a <b>bin</b> line represents the observation
count in the given cell: <i>value k</i> is the number of observations
greater or equal to <i>binLowerBound k</i>, but smaller than
<i>binLowerBound k+1</i>. <i>Value</i> is not necessarily an
integer, because the <a href="../api/classcKSplit.html">cKSplit</a> and <a href="../api/classcPSquare.html">cPSquare</a> algorithms produce
non-integer estimates. The first <b>bin</b> line is the underflow
cell, and the last <b>bin</b> line is the overflow cell.

<p>
Example:

<pre class="filelisting">
bin -INF  0
bin 0 4
bin 2 6
bin 4 2
bin 6 1
</pre>
<p>

<hr class='pgbr'><h1><a name="sec582"/>27 Appendix&#58; Eventlog File Format</h1>
<a name="cha:eventlog-file-format"></a>

<p>This appendix documents the format of the eventlog file. Eventlog
files are written by the simulation (when enabled). Everything
that happens during the simulation is recorded into the file,
  <br><ul><font size=-1>[With certain granularity of course, and subject to
  filters that were active during simulation]</font></ul>
so the file can later be used to reproduce the history of the
simulation on a sequence chart, or in some other form.

<p>The file is a line-oriented text file. Blank lines and lines beginning
with "#" (comments) will be ignored. Other lines begin with an
<i>entry identifier</i> like <tt>E</tt> for <i>Event</i> or
<tt>BS</tt> for <i>BeginSend</i>, followed by <i>attribute-identifier</i>
and <i>value</i> pairs. One exception is debug output
(recorded from <tt>ev&lt;&lt;...</tt> statements), which are represented
by lines that begin with a hyphen, and continue with the actual text.

<p>The grammar of the eventlog file is the following:

<pre class="verbatim">
&lt;file&gt; ::= &lt;line&gt;*
&lt;line&gt; ::= &lt;empty-line&gt; | &lt;user-log-message&gt; | &lt;event-log-entry&gt;
&lt;empty-line&gt; ::= CR LF
&lt;user-log-message&gt; ::= - SPACE &lt;text&gt; CR LF
&lt;event-log-entry&gt; ::= &lt;event-log-entry-type&gt; SPACE &lt;parameters&gt; CR LF
&lt;event-log-entry-type&gt; ::= SB | SE | BU | MB | ME | MC | MD | MR | GC | GD |
                           CC | CD | CS | MS | CE | BS | ES | SD | SH | DM | E
&lt;parameters&gt; ::= (&lt;parameter&gt;)*
&lt;parameter&gt; ::= &lt;name&gt; SPACE &lt;value&gt;
&lt;name&gt; ::= &lt;text&gt;
&lt;value&gt; ::= &lt;boolean&gt; | &lt;integer&gt; | &lt;text&gt; | &lt;quoted-text&gt;
</pre>
<p>
The eventlog file must also fulfill the following requirements:
<ul>
   <li> simulation events are in increasing event number and simulation time order
</ul>

<p>Here is a fragment of an existing eventlog file as an example:

<pre class="filelisting">
E # 14 t 1.018454036455 m 8 ce 9 msg 6
BS id 6 tid 6 c <a href="../api/classcMessage.html">cMessage</a> n send/endTx pe 14
ES t 4.840247053855
MS id 8 d t=TRANSMIT,,#808000;i=device/pc_s
MS id 8 d t=,,#808000;i=device/pc_s

E # 15 t 1.025727827674 m 2 ce 13 msg 25
- another frame arrived while receiving -- collision!
CE id 0 pe 12
BS id 0 tid 0 c <a href="../api/classcMessage.html">cMessage</a> n end-reception pe 15
ES t 1.12489449434
BU id 2 txt "Collision! (3 frames)"
DM id 25 pe 15
</pre>
<p>
<h2><a name="sec583"/>27.1 Supported Entry Types and Their Attributes</h2>

<p>The following entries and attributes are supported in the eventlog file:


<b>SB</b> <i>(SimulationBegin)</i>: mandatory first line of an eventlog file

<p><ul>
  <li> <b>v</b> (<i>version</i>, int): OMNeT++ version, e.g. 0x401 (=1025) is release 4.1
  <li> <b>rid</b> (<i>runId</i>, string): identifies the simulation run
  <li> <b>b</b> (<i>keyframeBlockSize</i>, int): the distance between keyframes in event numbers
</ul>

<p><b>SE</b> <i>(SimulationEnd)</i>: optional last line of an eventlog file

<p><ul>
  <li> <b>e</b> (<i>isError</i>, bool): specifies if the simulation terminated due to an error
  <li> <b>c</b> (<i>resultCode</i>, int): the error code in case of an error, otherwise the normal result code
  <li> <b>m</b> (<i>message</i>, string): human readable description
</ul>

<p><b>BU</b> <i>(Bubble)</i>: display a bubble message

<p><ul>
  <li> <b>id</b> (<i>moduleId</i>, int): id of the module which printed the bubble message
  <li> <b>txt</b> (<i>text</i>, string): displayed message text
</ul>

<p><b>MB</b> <i>(ModuleMethodBegin)</i>: beginning of a call to another module

<p><ul>
  <li> <b>sm</b> (<i>fromModuleId</i>, int): id of the caller module
  <li> <b>tm</b> (<i>toModuleId</i>, int): id of the module being called
  <li> <b>m</b> (<i>method</i>, string): C++ method name
</ul>

<p><b>ME</b> <i>(ModuleMethodEnd)</i>: end of a call to another module

<p><ul>
  <li> no parameters
</ul>

<p><b>MC</b> <i>(ModuleCreated)</i>: creating a module

<p><ul>
  <li> <b>id</b> (<i>moduleId</i>, int): id of the new module
  <li> <b>c</b> (<i>moduleClassName</i>, string): C++ class name of the module
  <li> <b>t</b> (<i>nedTypeName</i>, string): fully qualified NED type name
  <li> <b>pid</b> (<i>parentModuleId</i>, int): id of the parent module
  <li> <b>n</b> (<i>fullName</i>, string): full dotted hierarchical module name
  <li> <b>cm</b> (<i>compoundModule</i>, bool): whether module is a simple or compound module
</ul>

<p><b>MD</b> <i>(ModuleDeleted)</i>: deleting a module

<p><ul>
  <li> <b>id</b> (<i>moduleId</i>, int): id of the module being deleted
</ul>

<p><b>MR</b> <i>(ModuleReparented)</i>: reparenting a module

<p><ul>
  <li> <b>id</b> (<i>moduleId</i>, int): id of the module being reparented
  <li> <b>p</b> (<i>newParentModuleId</i>, int): id of the new parent module
</ul>

<p><b>GC</b> <i>(GateCreated)</i>: gate created

<p><ul>
  <li> <b>m</b> (<i>moduleId</i>, int): module in which the gate was created
  <li> <b>g</b> (<i>gateId</i>, int): id of the new gate
  <li> <b>n</b> (<i>name</i>, string): gate name
  <li> <b>i</b> (<i>index</i>, int): gate index if vector, -1 otherwise
  <li> <b>o</b> (<i>isOutput</i>, bool): whether the gate is input or output
</ul>

<p><b>GD</b> <i>(GateDeleted)</i>: gate deleted

<p><ul>
  <li> <b>m</b> (<i>moduleId</i>, int): module in which the gate was created
  <li> <b>g</b> (<i>gateId</i>, int): id of the deleted gate
</ul>

<p><b>CC</b> <i>(ConnectionCreated)</i>: creating a connection

<p><ul>
  <li> <b>sm</b> (<i>sourceModuleId</i>, int): id of the source module identifying the connection
  <li> <b>sg</b> (<i>sourceGateId</i>, int): id of the gate at the source module identifying the connection
  <li> <b>dm</b> (<i>destModuleId</i>, int): id of the destination module
  <li> <b>dg</b> (<i>destGateId</i>, int): id of the gate at the destination module
</ul>

<p><b>CD</b> <i>(ConnectionDeleted)</i>: deleting a connection

<p><ul>
  <li> <b>sm</b> (<i>sourceModuleId</i>, int): id of the source module identifying the connection
  <li> <b>sg</b> (<i>sourceGateId</i>, int): id of the gate at the source module identifying the connection
</ul>

<p><b>CS</b> <i>(ConnectionDisplayStringChanged)</i>: a connection display string change

<p><ul>
  <li> <b>sm</b> (<i>sourceModuleId</i>, int): id of the source module identifying the connection
  <li> <b>sg</b> (<i>sourceGateId</i>, int): id of the gate at the source module identifying the connection
  <li> <b>d</b> (<i>displayString</i>, string): the new display string
</ul>

<p><b>MS</b> <i>(ModuleDisplayStringChanged)</i>: a module display string change

<p><ul>
  <li> <b>id</b> (<i>moduleId</i>, int): id of the module
  <li> <b>d</b> (<i>displayString</i>, string): the new display string
</ul>

<p><b>E</b> <i>(Event)</i>: an event that is processing a message

<p><ul>
  <li> <b>#</b> (<i>eventNumber</i>, eventnumber_t): unique event number
  <li> <b>t</b> (<i>simulationTime</i>, simtime_t): simulation time when the event occurred
  <li> <b>m</b> (<i>moduleId</i>, int): id of the processing module
  <li> <b>ce</b> (<i>causeEventNumber</i>, eventnumber_t): event number from which the message being processed was sent, or -1 if the message was sent from initialize
  <li> <b>msg</b> (<i>messageId</i>, long): lifetime-unique id of the message being processed
</ul>

<p><b>KF</b> <i>(Keyframe)</i>:

<p><ul>
  <li> <b>p</b> (<i>previousKeyframeFileOffset</i>, int64): file offset of the previous keyframe entry
  <li> <b>c</b> (<i>consequenceLookaheadLimits</i>, string): consequence lookahead data
  <li> <b>s</b> (<i>simulationStateEntries</i>, string): simulation state data
</ul>

<p><b>abstract</b> <i>(Message)</i>: base class for entries referring to a message

<p><ul>
  <li> <b>id</b> (<i>messageId</i>, long): lifetime-unique id of the message
  <li> <b>tid</b> (<i>messageTreeId</i>, long): id of the message inherited by dup
  <li> <b>eid</b> (<i>messageEncapsulationId</i>, long): id of the message inherited by encapsulation
  <li> <b>etid</b> (<i>messageEncapsulationTreeId</i>, long): id of the message inherited by both dup and encapsulation
  <li> <b>c</b> (<i>messageClassName</i>, string): C++ class name of the message
  <li> <b>n</b> (<i>messageName</i>, string): message name
  <li> <b>k</b> (<i>messageKind</i>, short): message kind
  <li> <b>p</b> (<i>messagePriority</i>, short): message priority
  <li> <b>l</b> (<i>messageLength</i>, int64): message length in bits
  <li> <b>er</b> (<i>hasBitError</i>, bool): true indicates that the message has bit errors
  <li> <b>d</b> (<i>detail</i>, string): detailed information of message content when recording message data is turned on
  <li> <b>pe</b> (<i>previousEventNumber</i>, eventnumber_t): event number from which the message being cloned was sent, or -1 if the message was sent from initialize
</ul>

<p><b>CE</b> <i>(CancelEvent)</i>: canceling an event caused by a self message

<p><ul>
  <li> no parameters
</ul>

<p><b>BS</b> <i>(BeginSend)</i>: beginning to send a message

<p><ul>
  <li> no parameters
</ul>

<p><b>ES</b> <i>(EndSend)</i>: prediction of the arrival of a message

<p><ul>
  <li> <b>t</b> (<i>arrivalTime</i>, simtime_t): when the message will arrive to its destination module
  <li> <b>is</b> (<i>isReceptionStart</i>, bool): true indicates the message arrives with the first bit
</ul>

<p><b>SD</b> <i>(SendDirect)</i>: sending a message directly to a destination gate

<p><ul>
  <li> <b>sm</b> (<i>senderModuleId</i>, int): id of the source module from which the message is being sent
  <li> <b>dm</b> (<i>destModuleId</i>, int): id of the destination module to which the message is being sent
  <li> <b>dg</b> (<i>destGateId</i>, int): id of the gate at the destination module to which the message is being sent
  <li> <b>pd</b> (<i>propagationDelay</i>, simtime_t): propagation delay as the message is propagated through the connection
  <li> <b>td</b> (<i>transmissionDelay</i>, simtime_t): transmission duration as the whole message is sent from the source gate
</ul>

<p><b>SH</b> <i>(SendHop)</i>: sending a message through a connection identified by its source module and gate id

<p><ul>
  <li> <b>sm</b> (<i>senderModuleId</i>, int): id of the source module from which the message is being sent
  <li> <b>sg</b> (<i>senderGateId</i>, int): id of the gate at the source module from which the message is being sent
  <li> <b>pd</b> (<i>propagationDelay</i>, simtime_t): propagation delay as the message is propagated through the connection
  <li> <b>td</b> (<i>transmissionDelay</i>, simtime_t): transmission duration as the whole message is sent from the source gate
</ul>

<p><b>CM</b> <i>(CreateMessage)</i>: creating a message

<p><ul>
  <li> no parameters
</ul>

<p><b>CL</b> <i>(CloneMessage)</i>: cloning a message either via the copy constructor or dup

<p><ul>
  <li> <b>cid</b> (<i>cloneId</i>, long): lifetime-unique id of the clone
</ul>

<p><b>DM</b> <i>(DeleteMessage)</i>: deleting a message

<p><ul>
  <li> no parameters
</ul>



</body>
</html>


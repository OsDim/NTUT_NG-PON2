<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OMNeT++ Simulation Library: cPar Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cPar Class Reference<br/>
<small>
[<a class="el" href="group__SimCore.html">Simulation core classes</a>]</small>
</h1><!-- doxytag: class="cPar" --><!-- doxytag: inherits="cObject" -->
<p>Represents a module or channel parameter.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cpar_8h_source.html">cpar.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cPar:</div>
<div class="dynsection">
 <div class="center">
  <img src="classcPar.png" usemap="#cPar_map" alt=""/>
  <map id="cPar_map" name="cPar_map">
<area href="classcObject.html" alt="cObject" shape="rect" coords="0,0,56,24"/>
</map>
 </div>
</div>

<p><a href="classcPar-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e5c4866715df10306944b40a4b4d7a7"></a><!-- doxytag: member="cPar::~cPar" ref="a2e5c4866715df10306944b40a4b4d7a7" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a2e5c4866715df10306944b40a4b4d7a7">~cPar</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b2446654469e13ddccb0cda79019387"></a><!-- doxytag: member="cPar::getName" ref="a8b2446654469e13ddccb0cda79019387" args="() const " -->
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a8b2446654469e13ddccb0cda79019387">getName</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a1686cb7355efc74b9915ddadb396b6aa">info</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b5779f794cf7da066fba383291b8ab8"></a><!-- doxytag: member="cPar::detailedInfo" ref="a8b5779f794cf7da066fba383291b8ab8" args="() const " -->
virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a8b5779f794cf7da066fba383291b8ab8">detailedInfo</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcObject.html">cObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a7c075de681c7443c731e408fdfa487b4">getOwner</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d381106a18b64daaa8bdd0a4f32eaf7"></a><!-- doxytag: member="cPar::operator=" ref="a0d381106a18b64daaa8bdd0a4f32eaf7" args="(const cPar &amp;other)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a0d381106a18b64daaa8bdd0a4f32eaf7">operator=</a> (const <a class="el" href="classcPar.html">cPar</a> &amp;other)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Setter functions. Note that overloaded assignment operators also exist.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp07d3ae0fc4dccaad103fd41cedcd9d65"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae690d063c89fec4a53a10089b4e4f8e8"></a><!-- doxytag: member="cPar::setBoolValue" ref="ae690d063c89fec4a53a10089b4e4f8e8" args="(bool b)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#ae690d063c89fec4a53a10089b4e4f8e8">setBoolValue</a> (bool b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcb90fd2503fef812d3d83f7a3c9c25e"></a><!-- doxytag: member="cPar::setLongValue" ref="abcb90fd2503fef812d3d83f7a3c9c25e" args="(long l)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#abcb90fd2503fef812d3d83f7a3c9c25e">setLongValue</a> (long l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a825a88f561c8604efef9e05b9e3f6aef"></a><!-- doxytag: member="cPar::setDoubleValue" ref="a825a88f561c8604efef9e05b9e3f6aef" args="(double d)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a825a88f561c8604efef9e05b9e3f6aef">setDoubleValue</a> (double d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#aa50d3dc5c63bb89e96919798b1c155ad">setStringValue</a> (const char *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0f9ff53283ce7f8239605ba0e497984"></a><!-- doxytag: member="cPar::setStringValue" ref="aa0f9ff53283ce7f8239605ba0e497984" args="(const std::string &amp;s)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#aa0f9ff53283ce7f8239605ba0e497984">setStringValue</a> (const std::string &amp;s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c8a7722af52478afcb0bcec17fa16aa"></a><!-- doxytag: member="cPar::setXMLValue" ref="a5c8a7722af52478afcb0bcec17fa16aa" args="(cXMLElement *node)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a5c8a7722af52478afcb0bcec17fa16aa">setXMLValue</a> (<a class="el" href="classcXMLElement.html">cXMLElement</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a0a8f32bf28452e9b79040ebbbd9f6c85">setExpression</a> (<a class="el" href="classcExpression.html">cExpression</a> *e, <a class="el" href="classcComponent.html">cComponent</a> *evalcontext=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a3b27e476e8f18a54c2064ac4b24da6d9">setEvaluationContext</a> (<a class="el" href="classcComponent.html">cComponent</a> *ctx)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getter functions. Note that overloaded conversion operators also exist.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2d86bf309feb469758ca2dc583c95a1b"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#af54ea2fcc7ad0048f216ed0e67af2a44">boolValue</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#abf151b2b709538c7618ed9160567bfe3">longValue</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a0127b9c09f69503b5cf91e49ce473ddf">doubleValue</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a545efbca9036f3088c95be412b018d0e">getUnit</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#ad5ca3c2ab551adc7b57ec1937710a8b2">stringValue</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#aea60efd9c5f66088badcf921c8decd68">stdstringValue</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcXMLElement.html">cXMLElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#abc642480c56e9b5717e2c2a11d908ee3">xmlValue</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81b3a87784f9d5a73614c7b3b8910c9b"></a><!-- doxytag: member="cPar::getExpression" ref="a81b3a87784f9d5a73614c7b3b8910c9b" args="() const " -->
<a class="el" href="classcExpression.html">cExpression</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a81b3a87784f9d5a73614c7b3b8910c9b">getExpression</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcComponent.html">cComponent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a3fb2266418ac3de0823f45397c94b96d">getEvaluationContext</a> () const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous utility functions.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2c81007c83772af35d5dca133d3e4426"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#aabf41198ae04656e91dc38c20db774d0">read</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a725c47e1002faf0720715a6a78a334ed">finalize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04906d868bfcb0878fd1f34649cfe605"></a><!-- doxytag: member="cPar::convertToConst" ref="a04906d868bfcb0878fd1f34649cfe605" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a04906d868bfcb0878fd1f34649cfe605">convertToConst</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2add2a12f2d19a6bf9bbcfe02becd886"></a><!-- doxytag: member="cPar::str" ref="a2add2a12f2d19a6bf9bbcfe02becd886" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a2add2a12f2d19a6bf9bbcfe02becd886">str</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#ad39f3db3a2d39b2166b74741dfef5f80">parse</a> (const char *text)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Overloaded assignment and conversion operators.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp29c1b0a31e0234538e8da77b549d79ec"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af61e613e63ecc31336e66caa2b5bc25e"></a><!-- doxytag: member="cPar::operator=" ref="af61e613e63ecc31336e66caa2b5bc25e" args="(bool b)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#af61e613e63ecc31336e66caa2b5bc25e">operator=</a> (bool b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24018a63215a90b142f73ab5809dda28"></a><!-- doxytag: member="cPar::operator=" ref="a24018a63215a90b142f73ab5809dda28" args="(char c)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a24018a63215a90b142f73ab5809dda28">operator=</a> (char c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71392f93ab6308ae876a3792936b48b0"></a><!-- doxytag: member="cPar::operator=" ref="a71392f93ab6308ae876a3792936b48b0" args="(unsigned char c)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a71392f93ab6308ae876a3792936b48b0">operator=</a> (unsigned char c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dd8575bef9e1612eeba83bbb9f126e4"></a><!-- doxytag: member="cPar::operator=" ref="a7dd8575bef9e1612eeba83bbb9f126e4" args="(int i)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a7dd8575bef9e1612eeba83bbb9f126e4">operator=</a> (int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad16173d4aa99242d57fd64c514a73dcb"></a><!-- doxytag: member="cPar::operator=" ref="ad16173d4aa99242d57fd64c514a73dcb" args="(unsigned int i)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#ad16173d4aa99242d57fd64c514a73dcb">operator=</a> (unsigned int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4aa6fda159d4e9924dc9b32f3b32515"></a><!-- doxytag: member="cPar::operator=" ref="ac4aa6fda159d4e9924dc9b32f3b32515" args="(short i)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#ac4aa6fda159d4e9924dc9b32f3b32515">operator=</a> (short i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc4b24b48e37b6fa4d315bb24299e8d7"></a><!-- doxytag: member="cPar::operator=" ref="acc4b24b48e37b6fa4d315bb24299e8d7" args="(unsigned short i)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#acc4b24b48e37b6fa4d315bb24299e8d7">operator=</a> (unsigned short i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a030e1183948a61b1e060c3ae6f9a659c"></a><!-- doxytag: member="cPar::operator=" ref="a030e1183948a61b1e060c3ae6f9a659c" args="(long l)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a030e1183948a61b1e060c3ae6f9a659c">operator=</a> (long l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfb9b6134333b6dc60c49c988511a3b1"></a><!-- doxytag: member="cPar::operator=" ref="adfb9b6134333b6dc60c49c988511a3b1" args="(unsigned long l)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#adfb9b6134333b6dc60c49c988511a3b1">operator=</a> (unsigned long l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71020fefa6dc58ca57402fea8786ddf0"></a><!-- doxytag: member="cPar::operator=" ref="a71020fefa6dc58ca57402fea8786ddf0" args="(double d)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a71020fefa6dc58ca57402fea8786ddf0">operator=</a> (double d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51ad6de8e9d7eb0c3d6ed3a8d6600f4a"></a><!-- doxytag: member="cPar::operator=" ref="a51ad6de8e9d7eb0c3d6ed3a8d6600f4a" args="(long double d)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a51ad6de8e9d7eb0c3d6ed3a8d6600f4a">operator=</a> (long double d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c19238f9d8374f733bdd4bd629476d0"></a><!-- doxytag: member="cPar::operator=" ref="a7c19238f9d8374f733bdd4bd629476d0" args="(const char *s)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a7c19238f9d8374f733bdd4bd629476d0">operator=</a> (const char *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0202786df41ab54855f8294c41db37b"></a><!-- doxytag: member="cPar::operator=" ref="ae0202786df41ab54855f8294c41db37b" args="(const std::string &amp;s)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#ae0202786df41ab54855f8294c41db37b">operator=</a> (const std::string &amp;s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7f6513e6aff2591f79528b88534bccc"></a><!-- doxytag: member="cPar::operator=" ref="ac7f6513e6aff2591f79528b88534bccc" args="(cXMLElement *node)" -->
<a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#ac7f6513e6aff2591f79528b88534bccc">operator=</a> (<a class="el" href="classcXMLElement.html">cXMLElement</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44ac8fea59a38f3628219994c8103065"></a><!-- doxytag: member="cPar::operator bool" ref="a44ac8fea59a38f3628219994c8103065" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a44ac8fea59a38f3628219994c8103065">operator bool</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a576de150333dfd53d34fa57738a1800a"></a><!-- doxytag: member="cPar::operator char" ref="a576de150333dfd53d34fa57738a1800a" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a576de150333dfd53d34fa57738a1800a">operator char</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56a00f119aca10d0396486ff3d5b3647"></a><!-- doxytag: member="cPar::operator unsigned char" ref="a56a00f119aca10d0396486ff3d5b3647" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a56a00f119aca10d0396486ff3d5b3647">operator unsigned char</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fed29322689044b0f5b071d830041d1"></a><!-- doxytag: member="cPar::operator int" ref="a7fed29322689044b0f5b071d830041d1" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a7fed29322689044b0f5b071d830041d1">operator int</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb7a264264dac586c4e462f1a2b87d64"></a><!-- doxytag: member="cPar::operator unsigned int" ref="acb7a264264dac586c4e462f1a2b87d64" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#acb7a264264dac586c4e462f1a2b87d64">operator unsigned int</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3138e196f330a20a746a11286cef5bf5"></a><!-- doxytag: member="cPar::operator short" ref="a3138e196f330a20a746a11286cef5bf5" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a3138e196f330a20a746a11286cef5bf5">operator short</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af954e1119d9949395ef8f8c96b5450a5"></a><!-- doxytag: member="cPar::operator unsigned short" ref="af954e1119d9949395ef8f8c96b5450a5" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#af954e1119d9949395ef8f8c96b5450a5">operator unsigned short</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f7b034a7cc2ef1b2d192e658feece78"></a><!-- doxytag: member="cPar::operator long" ref="a0f7b034a7cc2ef1b2d192e658feece78" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a0f7b034a7cc2ef1b2d192e658feece78">operator long</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b5cc2e48ee135cd96dfd7fd65bc7b25"></a><!-- doxytag: member="cPar::operator unsigned long" ref="a6b5cc2e48ee135cd96dfd7fd65bc7b25" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a6b5cc2e48ee135cd96dfd7fd65bc7b25">operator unsigned long</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aede384a3aad47c832f811b0c03548f7e"></a><!-- doxytag: member="cPar::operator double" ref="aede384a3aad47c832f811b0c03548f7e" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#aede384a3aad47c832f811b0c03548f7e">operator double</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a727c89b262ddc12becea71dc50e014ba"></a><!-- doxytag: member="cPar::operator long double" ref="a727c89b262ddc12becea71dc50e014ba" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a727c89b262ddc12becea71dc50e014ba">operator long double</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae63b4700f5b6a75f95f45914efd00300"></a><!-- doxytag: member="cPar::operator const char *" ref="ae63b4700f5b6a75f95f45914efd00300" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#ae63b4700f5b6a75f95f45914efd00300">operator const char *</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a689c0c2539a2db2e4402276feaf11ea4"></a><!-- doxytag: member="cPar::operator std::string" ref="a689c0c2539a2db2e4402276feaf11ea4" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a689c0c2539a2db2e4402276feaf11ea4">operator std::string</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a4efa1106a8fee8d3d1a5eeb3b42fc745">operator cXMLElement *</a> () const </td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add0207c9829c1a1ae29f9c10cc899454"></a><!-- doxytag: member="cPar::cComponent" ref="add0207c9829c1a1ae29f9c10cc899454" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#add0207c9829c1a1ae29f9c10cc899454">cComponent</a></td></tr>
<tr><td colspan="2"><h2>Type, flags.</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp6c234b99a2bb0c07f4363a72aa3a77cb"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af09b972cdd3dbd82f41dae9648438b4e"></a><!-- doxytag: member="cPar::getType" ref="af09b972cdd3dbd82f41dae9648438b4e" args="() const " -->
Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#af09b972cdd3dbd82f41dae9648438b4e">getType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf6a488de1fab30cf2a2b079cfc47332"></a><!-- doxytag: member="cPar::isNumeric" ref="acf6a488de1fab30cf2a2b079cfc47332" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#acf6a488de1fab30cf2a2b079cfc47332">isNumeric</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a2efc067e4972249872517276459a512b">isVolatile</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a81be32834131db993ff31ecea2ee7bb0">isExpression</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#ac6647305da528211bf803bcc6aebf3d9">isShared</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a22919d939a9b511ac3cecf2332bddbc4">isSet</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#af550c34774f542a20250628b3b175215">containsValue</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcProperties.html">cProperties</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a39a116c5efe433a3b14bb7046dcf6ae8">getProperties</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33f262088ed148c88d1a20112d468372"></a><!-- doxytag: member="cPar::getTypeName" ref="a33f262088ed148c88d1a20112d468372" args="(Type t)" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPar.html#a33f262088ed148c88d1a20112d468372">getTypeName</a> (Type t)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Represents a module or channel parameter. </p>
<p>When a module or channel is created, parameter objects are added automatically, based on the NED declaration of the module/channel. It is not possible to create further parameters (or to remove parameters) at runtime. This is enforced by the <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> constructor being private.</p>
<p>Parameters get their initial values automatically, from the NED declarations and the configuration. It is possible to change the parameter value during runtime (see various setter methods and operator='s), but not the type of the parameter (see <a class="el" href="classcPar.html#af09b972cdd3dbd82f41dae9648438b4e" title="Returns the parameter type.">getType()</a>). The type correspond to NED types (bool, double, long, string, xml), and cannot be changed at runtime.</p>
<p>The module or channel object can get notified when a parameter is changed; one has to override <a class="el" href="classcComponent.html#a2c290c145b8c16e2de68def880659506" title="This method is called by the simulation kernel to notify the module or channel that...">cComponent::handleParameterChange()</a> for that.</p>
<p><b>Note:</b> In earlier versions of OMNeT++, <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> could be used as a general value storage object, and attached to cMessages as well. From the 4.0 version, simulation models should use <a class="el" href="classcMsgPar.html" title="cMsgPar objects store a (string, bool, double, etc) value, and can be attached to...">cMsgPar</a> for that.</p>
<p><b>Implementation note:</b> from the 4.0 version, almost all methods of <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> delegates to an internal <a class="el" href="classcParImpl.html" title="Internal class that stores parameter values.">cParImpl</a> object, which actually stores the value, and generally does the real job. This was done to allow sharing parameter objects which have the same name, same value, etc. among module/channel instances. This significantly reduces memory consumption of most simulation models. Because <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> is just a thin wrapper around <a class="el" href="classcParImpl.html" title="Internal class that stores parameter values.">cParImpl</a>, <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> is not meant for subclassing, and none if its methods are virtual. <a class="el" href="classcParImpl.html" title="Internal class that stores parameter values.">cParImpl</a> and subclasses should also be regarded as internal data structures, and they should not be directly accessed or manipulated from model code. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af54ea2fcc7ad0048f216ed0e67af2a44"></a><!-- doxytag: member="cPar::boolValue" ref="af54ea2fcc7ad0048f216ed0e67af2a44" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cPar::boolValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns value as a boolean. </p>
<p>The <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> type must be BOOL. </p>

</div>
</div>
<a class="anchor" id="af550c34774f542a20250628b3b175215"></a><!-- doxytag: member="cPar::containsValue" ref="af550c34774f542a20250628b3b175215" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cPar::containsValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the parameter is set (see <a class="el" href="classcPar.html#a22919d939a9b511ac3cecf2332bddbc4" title="Returns true if the parameter is assigned a value, and false otherwise.">isSet()</a>) or contains a default value, and false otherwise. </p>
<p>Parameters of an already initialized module or channel are guaranteed to be assigned, so this method will return true for them. </p>

</div>
</div>
<a class="anchor" id="a0127b9c09f69503b5cf91e49ce473ddf"></a><!-- doxytag: member="cPar::doubleValue" ref="a0127b9c09f69503b5cf91e49ce473ddf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cPar::doubleValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns value as double. </p>
<p>The <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> type must be LONG or DOUBLE. </p>

</div>
</div>
<a class="anchor" id="a725c47e1002faf0720715a6a78a334ed"></a><!-- doxytag: member="cPar::finalize" ref="a725c47e1002faf0720715a6a78a334ed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cPar::finalize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><ul>
<li>if the parameter is non-volatile, (<a class="el" href="classcPar.html#a2efc067e4972249872517276459a512b" title="Returns true if this parameter is marked in the NED file as &quot;volatile&quot;...">isVolatile()</a>==false), converts possible expression value to a constant (see <a class="el" href="classcPar.html#a04906d868bfcb0878fd1f34649cfe605" title="For non-const values, replaces the stored expression with its evaluation.">convertToConst()</a>). </li>
</ul>
</p>
<ul>
<li>if the parameter is volatile but contains "const" subexpressions, these parts are converted to a constant value. </li>
</ul>

</div>
</div>
<a class="anchor" id="a3fb2266418ac3de0823f45397c94b96d"></a><!-- doxytag: member="cPar::getEvaluationContext" ref="a3fb2266418ac3de0823f45397c94b96d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcComponent.html">cComponent</a>* cPar::getEvaluationContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the parameter contains an expression, this method returns the module or channel in the context of which the expression will be evaluated. </p>
<p>(The context affects the resolution of parameter references, and NED operators like <code>index</code> or <code>sizeof()</code>.) If the parameter does not contain an expression, the return value is undefined.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcPar.html#a81be32834131db993ff31ecea2ee7bb0" title="Returns false if the stored value is a constant, and true if it is an expression...">isExpression()</a>, <a class="el" href="classcPar.html#a3b27e476e8f18a54c2064ac4b24da6d9" title="If the parameter contains an expression (see isExpression()), this method sets the...">setEvaluationContext()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7c075de681c7443c731e408fdfa487b4"></a><!-- doxytag: member="cPar::getOwner" ref="a7c075de681c7443c731e408fdfa487b4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcObject.html">cObject</a>* cPar::getOwner </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the component (module/channel) this parameter belongs to. </p>
<p>Note: return type is <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarchy.">cObject</a> only for technical reasons, it can be safely cast to <a class="el" href="classcComponent.html" title="Common base for module and channel classes: cModule and cChannel.">cComponent</a>. </p>

<p>Reimplemented from <a class="el" href="classcObject.html#a4684772537578a151166b7a99e3fde4d">cObject</a>.</p>

</div>
</div>
<a class="anchor" id="a39a116c5efe433a3b14bb7046dcf6ae8"></a><!-- doxytag: member="cPar::getProperties" ref="a39a116c5efe433a3b14bb7046dcf6ae8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcProperties.html">cProperties</a>* cPar::getProperties </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the properties for this parameter. </p>
<p>Properties cannot be changed at runtime. </p>

</div>
</div>
<a class="anchor" id="a545efbca9036f3088c95be412b018d0e"></a><!-- doxytag: member="cPar::getUnit" ref="a545efbca9036f3088c95be412b018d0e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cPar::getUnit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the parameter's unit ("s", "mW", "Hz", "bps", etc), as declared with the @unit property of the parameter in NED, or NULL if no unit was specified. </p>
<p>Unit is only valid for LONG and DOUBLE types. </p>

</div>
</div>
<a class="anchor" id="a1686cb7355efc74b9915ddadb396b6aa"></a><!-- doxytag: member="cPar::info" ref="a1686cb7355efc74b9915ddadb396b6aa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cPar::info </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a one-line description of the object. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcPar.html#a8b5779f794cf7da066fba383291b8ab8" title="Returns a long description of the object.">detailedInfo()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classcObject.html#a28c24b5dcb3703c5f6ae92a67bd61c31">cObject</a>.</p>

</div>
</div>
<a class="anchor" id="a81be32834131db993ff31ecea2ee7bb0"></a><!-- doxytag: member="cPar::isExpression" ref="a81be32834131db993ff31ecea2ee7bb0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cPar::isExpression </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns false if the stored value is a constant, and true if it is an expression. </p>
<p>(It is not examined whether the expression yields a constant value.) </p>

</div>
</div>
<a class="anchor" id="a22919d939a9b511ac3cecf2332bddbc4"></a><!-- doxytag: member="cPar::isSet" ref="a22919d939a9b511ac3cecf2332bddbc4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cPar::isSet </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the parameter is assigned a value, and false otherwise. </p>
<p>Parameters of an already initialized module or channel are guaranteed to assigned, so this method will return true for them. </p>

</div>
</div>
<a class="anchor" id="ac6647305da528211bf803bcc6aebf3d9"></a><!-- doxytag: member="cPar::isShared" ref="ac6647305da528211bf803bcc6aebf3d9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cPar::isShared </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the parameter value expression is shared among several modules to save memory. </p>
<p>This flag is purely informational, and whether a parameter is shared or not does not affect operation at all. </p>

</div>
</div>
<a class="anchor" id="a2efc067e4972249872517276459a512b"></a><!-- doxytag: member="cPar::isVolatile" ref="a2efc067e4972249872517276459a512b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cPar::isVolatile </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this parameter is marked in the NED file as "volatile". </p>
<p>This flag affects the operation of <a class="el" href="classcPar.html#a0a8f32bf28452e9b79040ebbbd9f6c85" title="Sets the value to the given expression.">setExpression()</a>. </p>

</div>
</div>
<a class="anchor" id="abf151b2b709538c7618ed9160567bfe3"></a><!-- doxytag: member="cPar::longValue" ref="abf151b2b709538c7618ed9160567bfe3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long cPar::longValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns value as long. </p>
<p>The <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> type must be LONG or DOUBLE. </p>

</div>
</div>
<a class="anchor" id="a4efa1106a8fee8d3d1a5eeb3b42fc745"></a><!-- doxytag: member="cPar::operator cXMLElement *" ref="a4efa1106a8fee8d3d1a5eeb3b42fc745" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cPar::operator <a class="el" href="classcXMLElement.html">cXMLElement</a> * </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equivalent to <a class="el" href="classcPar.html#abc642480c56e9b5717e2c2a11d908ee3" title="Returns value as pointer to cXMLElement.">xmlValue()</a>. </p>
<p>NOTE: The lifetime of the returned object tree is limited; see <a class="el" href="classcPar.html#abc642480c56e9b5717e2c2a11d908ee3" title="Returns value as pointer to cXMLElement.">xmlValue()</a> for details. </p>

</div>
</div>
<a class="anchor" id="ad39f3db3a2d39b2166b74741dfef5f80"></a><!-- doxytag: member="cPar::parse" ref="ad39f3db3a2d39b2166b74741dfef5f80" args="(const char *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cPar::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts the value from string, and stores the result. </p>
<p>If the text cannot be parsed, an exception is thrown, which can be caught as std::runtime_error&amp; if necessary.</p>
<p>Note: this method understands expressions too, but does NOT handle the special values "default" and "ask". </p>

</div>
</div>
<a class="anchor" id="aabf41198ae04656e91dc38c20db774d0"></a><!-- doxytag: member="cPar::read" ref="aabf41198ae04656e91dc38c20db774d0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cPar::read </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method does the final touches on the parameter. </p>
<p>It is invoked at some point on all parameter objects before we start the simulation.</p>
<ul>
<li>if the parameter is not set, gets the value from omnetpp.ini or interactively from the user, or sets the default value. </li>
</ul>

</div>
</div>
<a class="anchor" id="a3b27e476e8f18a54c2064ac4b24da6d9"></a><!-- doxytag: member="cPar::setEvaluationContext" ref="a3b27e476e8f18a54c2064ac4b24da6d9" args="(cComponent *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cPar::setEvaluationContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcComponent.html">cComponent</a> *&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the parameter contains an expression (see <a class="el" href="classcPar.html#a81be32834131db993ff31ecea2ee7bb0" title="Returns false if the stored value is a constant, and true if it is an expression...">isExpression()</a>), this method sets the evaluation context for the expression. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcPar.html#a3fb2266418ac3de0823f45397c94b96d" title="If the parameter contains an expression, this method returns the module or channel...">getEvaluationContext()</a>, <a class="el" href="classcPar.html#a81be32834131db993ff31ecea2ee7bb0" title="Returns false if the stored value is a constant, and true if it is an expression...">isExpression()</a>, <a class="el" href="classcPar.html#a0a8f32bf28452e9b79040ebbbd9f6c85" title="Sets the value to the given expression.">setExpression()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0a8f32bf28452e9b79040ebbbd9f6c85"></a><!-- doxytag: member="cPar::setExpression" ref="a0a8f32bf28452e9b79040ebbbd9f6c85" args="(cExpression *e, cComponent *evalcontext=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcPar.html">cPar</a>&amp; cPar::setExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcExpression.html">cExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcComponent.html">cComponent</a> *&nbsp;</td>
          <td class="paramname"> <em>evalcontext</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the value to the given expression. </p>
<p>This object will assume the responsibility to delete the expression object.</p>
<p>The evalcontext parameter determines the module or channel in the context of which the expression will be evaluated. If evalcontext is NULL, the owner of this parameter will be used.</p>
<p>Note: if the parameter is marked as non-volatile (<a class="el" href="classcPar.html#a2efc067e4972249872517276459a512b" title="Returns true if this parameter is marked in the NED file as &quot;volatile&quot;...">isVolatile()</a>==false), one should not set an expression as value. This is not enforced by <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> though.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcPar.html#a7c075de681c7443c731e408fdfa487b4" title="Returns the component (module/channel) this parameter belongs to.">getOwner()</a>, <a class="el" href="classcPar.html#a3fb2266418ac3de0823f45397c94b96d" title="If the parameter contains an expression, this method returns the module or channel...">getEvaluationContext()</a>, <a class="el" href="classcPar.html#a3b27e476e8f18a54c2064ac4b24da6d9" title="If the parameter contains an expression (see isExpression()), this method sets the...">setEvaluationContext()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa50d3dc5c63bb89e96919798b1c155ad"></a><!-- doxytag: member="cPar::setStringValue" ref="aa50d3dc5c63bb89e96919798b1c155ad" args="(const char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcPar.html">cPar</a>&amp; cPar::setStringValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the value to the given string value. </p>
<p>The <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> will make its own copy of the string. NULL is also accepted and treated as an empty string. </p>

</div>
</div>
<a class="anchor" id="aea60efd9c5f66088badcf921c8decd68"></a><!-- doxytag: member="cPar::stdstringValue" ref="aea60efd9c5f66088badcf921c8decd68" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cPar::stdstringValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns value as string. </p>
<p>The <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> type must be STRING. </p>

<p>Referenced by <a class="el" href="cpar_8h_source.html#l00515">operator std::string()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5ca3c2ab551adc7b57ec1937710a8b2"></a><!-- doxytag: member="cPar::stringValue" ref="ad5ca3c2ab551adc7b57ec1937710a8b2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cPar::stringValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns value as const char *. </p>
<p>The <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> type must be STRING. This method may only be invoked when the parameter's value is a string constant and not the result of expression evaluation, otherwise an error is thrown. This practically means this method cannot be used on parameters declared as "volatile string" in NED; they can only be accessed using <a class="el" href="classcPar.html#aea60efd9c5f66088badcf921c8decd68" title="Returns value as string.">stdstringValue()</a>. </p>

</div>
</div>
<a class="anchor" id="abc642480c56e9b5717e2c2a11d908ee3"></a><!-- doxytag: member="cPar::xmlValue" ref="abc642480c56e9b5717e2c2a11d908ee3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcXMLElement.html">cXMLElement</a>* cPar::xmlValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns value as pointer to <a class="el" href="classcXMLElement.html" title="Represents an XML element in an XML configuration file.">cXMLElement</a>. </p>
<p>The <a class="el" href="classcPar.html" title="Represents a module or channel parameter.">cPar</a> type must be XML.</p>
<p>The lifetime of the returned object tree is undefined, but it is valid at least until the end of the current simulation event or initialize() call. Modules are expected to process their XML configurations at once (within one event or within initialize()), and not hang on to pointers returned from this method. The reason for the limited lifetime is that this method may return pointers to objects stored in an internal XML document cache, and the simulation kernel reserves the right to discard cached XML documents at any time to free up memory, and re-load them on demand (i.e. when <a class="el" href="classcPar.html#abc642480c56e9b5717e2c2a11d908ee3" title="Returns value as pointer to cXMLElement.">xmlValue()</a> is called again). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cpar_8h_source.html">cpar.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Dec 2 11:16:29 2014 for OMNeT++ Simulation Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
